// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"strconv"
)

type Tag interface {
	IsTag()
	GetID() string
	GetName() string
	GetDescription() *string
	GetAggregatedRating() *AggregatedRating
	GetRatings() []*UserRating
	GetMyRating() *UserRating
}

type AggregatedRating struct {
	Average float64 `json:"average"`
	Count   int     `json:"count"`
}

type AssignTagInput struct {
	TagID  string `json:"tagID"`
	CardID string `json:"cardID"`
}

type CardTag struct {
	ID               string            `json:"_key"`
	Name             string            `json:"name"`
	Description      *string           `json:"description,omitempty"`
	AggregatedRating *AggregatedRating `json:"aggregatedRating"`
	Ratings          []*UserRating     `json:"ratings"`
	MyRating         *UserRating       `json:"myRating,omitempty"`
}

func (CardTag) IsTag()                                      {}
func (this CardTag) GetID() string                          { return this.ID }
func (this CardTag) GetName() string                        { return this.Name }
func (this CardTag) GetDescription() *string                { return this.Description }
func (this CardTag) GetAggregatedRating() *AggregatedRating { return this.AggregatedRating }
func (this CardTag) GetRatings() []*UserRating {
	if this.Ratings == nil {
		return nil
	}
	interfaceSlice := make([]*UserRating, 0, len(this.Ratings))
	for _, concrete := range this.Ratings {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this CardTag) GetMyRating() *UserRating { return this.MyRating }

type CreateTagInput struct {
	Type        TagType    `json:"type"`
	Name        string     `json:"name"`
	Description *string    `json:"description,omitempty"`
	Colors      []MtgColor `json:"colors,omitempty"`
	CardID      *string    `json:"cardID,omitempty"`
}

type DeckTag struct {
	ID               string            `json:"_key"`
	Name             string            `json:"name"`
	Description      *string           `json:"description,omitempty"`
	AggregatedRating *AggregatedRating `json:"aggregatedRating"`
	Ratings          []*UserRating     `json:"ratings"`
	MyRating         *UserRating       `json:"myRating,omitempty"`
	Colors           []MtgColor        `json:"colors"`
}

func (DeckTag) IsTag()                                      {}
func (this DeckTag) GetID() string                          { return this.ID }
func (this DeckTag) GetName() string                        { return this.Name }
func (this DeckTag) GetDescription() *string                { return this.Description }
func (this DeckTag) GetAggregatedRating() *AggregatedRating { return this.AggregatedRating }
func (this DeckTag) GetRatings() []*UserRating {
	if this.Ratings == nil {
		return nil
	}
	interfaceSlice := make([]*UserRating, 0, len(this.Ratings))
	for _, concrete := range this.Ratings {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this DeckTag) GetMyRating() *UserRating { return this.MyRating }

type FlowZone struct {
	ID          string    `json:"ID"`
	Name        string    `json:"name"`
	Position    *Position `json:"position"`
	Width       float64   `json:"width"`
	Height      float64   `json:"height"`
	ChildrenIDs []string  `json:"childrenIDs"`
}

type FlowZoneInput struct {
	ID          string         `json:"ID"`
	Name        string         `json:"name"`
	Position    *PositionInput `json:"position"`
	Width       float64        `json:"width"`
	Height      float64        `json:"height"`
	ChildrenIDs []string       `json:"childrenIDs"`
}

type MtgAddCardToCardPackageInput struct {
	CardPackageID string `json:"cardPackageID"`
	Card          string `json:"card"`
	Count         int    `json:"count"`
}

type MtgCard struct {
	ID               string            `json:"_key"`
	Layout           MtgLayout         `json:"layout"`
	Cmc              float64           `json:"CMC"`
	ColorIdentity    []MtgColor        `json:"colorIdentity"`
	ColorIndicator   []string          `json:"colorIndicator,omitempty"`
	Colors           []MtgColor        `json:"colors,omitempty"`
	EDHRecRank       *int              `json:"EDHRecRank,omitempty"`
	Keywords         []string          `json:"keywords"`
	Loyalty          *string           `json:"loyalty,omitempty"`
	ManaCost         *string           `json:"manaCost,omitempty"`
	Name             string            `json:"name"`
	OracleText       *string           `json:"oracleText,omitempty"`
	Power            *string           `json:"power,omitempty"`
	ProducedMana     []MtgColor        `json:"producedMana,omitempty"`
	Toughness        *string           `json:"toughness,omitempty"`
	TypeLine         string            `json:"typeLine"`
	Versions         []*MtgCardVersion `json:"versions"`
	AggregatedRating *AggregatedRating `json:"aggregatedRating"`
	Ratings          []*UserRating     `json:"ratings"`
	MyRating         *UserRating       `json:"myRating,omitempty"`
	CardTags         []*CardTag        `json:"cardTags"`
	DeckTags         []*DeckTag        `json:"deckTags"`
}

type MtgCardFace struct {
	Artist         *string    `json:"artist,omitempty"`
	Cmc            *float64   `json:"CMC,omitempty"`
	ColorIndicator []string   `json:"colorIndicator,omitempty"`
	Colors         []MtgColor `json:"colors,omitempty"`
	FlavorText     *string    `json:"flavorText,omitempty"`
	ImageUris      *MtgImage  `json:"imageUris,omitempty"`
	Layout         *MtgLayout `json:"layout,omitempty"`
	Loyalty        *string    `json:"loyalty,omitempty"`
	ManaCost       string     `json:"manaCost"`
	Name           string     `json:"name"`
	OracleText     *string    `json:"oracleText,omitempty"`
	Power          *string    `json:"power,omitempty"`
	Toughness      *string    `json:"toughness,omitempty"`
	TypeLine       *string    `json:"typeLine,omitempty"`
}

type MtgCardPackage struct {
	ID    string                `json:"_key"`
	Name  string                `json:"name"`
	Cards []*MtgCardPackageCard `json:"cards"`
}

type MtgCardPackageCard struct {
	Card              *MtgCard   `json:"card"`
	SelectedVersionID *string    `json:"selectedVersionID,omitempty"`
	Count             int        `json:"count"`
	MainOrSide        MainOrSide `json:"mainOrSide"`
}

type MtgCardPackageCardInput struct {
	Card              string     `json:"card"`
	SelectedVersionID *string    `json:"selectedVersionID,omitempty"`
	Count             int        `json:"count"`
	MainOrSide        MainOrSide `json:"mainOrSide"`
}

type MtgCardVersion struct {
	ID          string         `json:"ID"`
	IsDefault   bool           `json:"isDefault"`
	IsAlchemy   bool           `json:"isAlchemy"`
	Artist      *string        `json:"artist,omitempty"`
	Lang        string         `json:"lang"`
	FlavorName  *string        `json:"flavorName,omitempty"`
	FlavorText  *string        `json:"flavorText,omitempty"`
	CardFaces   []*MtgCardFace `json:"cardFaces,omitempty"`
	Legalities  map[string]any `json:"legalities"`
	Games       []MtgGame      `json:"games"`
	ImageUris   *MtgImage      `json:"imageUris,omitempty"`
	Rarity      MtgRarity      `json:"rarity"`
	ReleasedAt  string         `json:"releasedAt"`
	Reprint     bool           `json:"reprint"`
	SetName     string         `json:"setName"`
	SetType     string         `json:"setType"`
	Set         string         `json:"set"`
	SetID       string         `json:"setID"`
	Variation   bool           `json:"variation"`
	VariationOf *string        `json:"variationOf,omitempty"`
}

type MtgCreateCardPackageInput struct {
	Name string `json:"name"`
}

type MtgCreateDeckInput struct {
	Name string `json:"name"`
}

type MtgDeck struct {
	ID             string         `json:"_key"`
	Name           string         `json:"name"`
	CardFrontImage *MtgCard       `json:"cardFrontImage,omitempty"`
	Cards          []*MtgDeckCard `json:"cards"`
	Zones          []*FlowZone    `json:"zones"`
	IgnoredCards   []string       `json:"ignoredCards"`
}

type MtgDeckCard struct {
	Card              *MtgCard        `json:"card"`
	SelectedVersionID *string         `json:"selectedVersionID,omitempty"`
	Count             int             `json:"count"`
	Position          *Position       `json:"position"`
	MainOrSide        MainOrSide      `json:"mainOrSide"`
	DeckCardType      MtgDeckCardType `json:"deckCardType"`
	Phantoms          []*Phantom      `json:"phantoms"`
}

type MtgDeckCardFrontImageInput struct {
	CardID    string `json:"cardID"`
	VersionID string `json:"versionID"`
}

type MtgDeckCardInput struct {
	ID                string          `json:"ID"`
	Card              string          `json:"card"`
	SelectedVersionID *string         `json:"selectedVersionID,omitempty"`
	Count             int             `json:"count"`
	Position          *PositionInput  `json:"position"`
	MainOrSide        MainOrSide      `json:"mainOrSide"`
	DeckCardType      MtgDeckCardType `json:"deckCardType"`
	Phantoms          []*PhantomInput `json:"phantoms"`
}

type MtgDeleteCardPackageInput struct {
	CardPackageID string `json:"cardPackageID"`
}

type MtgDeleteDeckInput struct {
	DeckID string `json:"deckID"`
}

type MtgFilterCardTypes struct {
	CardType string   `json:"cardType"`
	Subtypes []string `json:"subtypes"`
}

type MtgFilterEntries struct {
	Types      []*MtgFilterCardTypes `json:"types"`
	Expansions []*MtgFilterExpansion `json:"expansions"`
	Legality   *MtgFilterLegality    `json:"legality"`
	Layouts    []MtgLayout           `json:"layouts"`
}

type MtgFilterExpansion struct {
	Set        string    `json:"set"`
	SetName    string    `json:"setName"`
	ReleasedAt int       `json:"releasedAt"`
	ImageURL   string    `json:"imageURL"`
	SetType    string    `json:"setType"`
	Games      []MtgGame `json:"games"`
}

type MtgFilterLegality struct {
	Formats        []string `json:"formats"`
	LegalityValues []string `json:"legalityValues"`
}

type MtgImage struct {
	ArtCrop    string `json:"artCrop"`
	BorderCrop string `json:"borderCrop"`
	Large      string `json:"large"`
	Normal     string `json:"normal"`
	Png        string `json:"PNG"`
	Small      string `json:"small"`
}

type MtgRemoveCardFromCardPackageInput struct {
	CardPackageID string `json:"cardPackageID"`
	Card          string `json:"card"`
}

type MtgUpdateDeckInput struct {
	DeckID         string                      `json:"deckID"`
	Name           string                      `json:"name"`
	CardFrontImage *MtgDeckCardFrontImageInput `json:"cardFrontImage,omitempty"`
	Cards          []*MtgDeckCardInput         `json:"cards"`
	Zones          []*FlowZoneInput            `json:"zones"`
	IgnoredCards   []string                    `json:"ignoredCards"`
}

type Mutation struct {
}

type Phantom struct {
	Position *Position `json:"position"`
	ID       string    `json:"ID"`
}

type PhantomInput struct {
	ID       string         `json:"ID"`
	Position *PositionInput `json:"position"`
}

type Position struct {
	X float64 `json:"x"`
	Y float64 `json:"y"`
}

type PositionInput struct {
	X float64 `json:"x"`
	Y float64 `json:"y"`
}

type Query struct {
}

type RateInput struct {
	UserID     string            `json:"userID"`
	EntityID   string            `json:"entityID"`
	EntityType RatableEntityType `json:"entityType"`
	Value      int               `json:"value"`
}

type Response struct {
	Status  bool    `json:"status"`
	Message *string `json:"message,omitempty"`
}

type UnassignTagInput struct {
	TagID  string `json:"tagID"`
	CardID string `json:"cardID"`
}

type UpdateTagInput struct {
	ID          string     `json:"ID"`
	Name        *string    `json:"name,omitempty"`
	Description *string    `json:"description,omitempty"`
	Colors      []MtgColor `json:"colors,omitempty"`
}

type User struct {
	ID string `json:"_key"`
}

type UserRating struct {
	User  *User `json:"user"`
	Value int   `json:"value"`
}

type DeckType string

const (
	DeckTypeBrawl60  DeckType = "BRAWL_60"
	DeckTypeBrawl100 DeckType = "BRAWL_100"
)

var AllDeckType = []DeckType{
	DeckTypeBrawl60,
	DeckTypeBrawl100,
}

func (e DeckType) IsValid() bool {
	switch e {
	case DeckTypeBrawl60, DeckTypeBrawl100:
		return true
	}
	return false
}

func (e DeckType) String() string {
	return string(e)
}

func (e *DeckType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DeckType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DeckType", str)
	}
	return nil
}

func (e DeckType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type MtgColor string

const (
	MtgColorC MtgColor = "C"
	MtgColorW MtgColor = "W"
	MtgColorU MtgColor = "U"
	MtgColorB MtgColor = "B"
	MtgColorR MtgColor = "R"
	MtgColorG MtgColor = "G"
)

var AllMtgColor = []MtgColor{
	MtgColorC,
	MtgColorW,
	MtgColorU,
	MtgColorB,
	MtgColorR,
	MtgColorG,
}

func (e MtgColor) IsValid() bool {
	switch e {
	case MtgColorC, MtgColorW, MtgColorU, MtgColorB, MtgColorR, MtgColorG:
		return true
	}
	return false
}

func (e MtgColor) String() string {
	return string(e)
}

func (e *MtgColor) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MtgColor(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MTG_Color", str)
	}
	return nil
}

func (e MtgColor) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type MtgDeckCardType string

const (
	MtgDeckCardTypeNormal    MtgDeckCardType = "NORMAL"
	MtgDeckCardTypeCommander MtgDeckCardType = "COMMANDER"
)

var AllMtgDeckCardType = []MtgDeckCardType{
	MtgDeckCardTypeNormal,
	MtgDeckCardTypeCommander,
}

func (e MtgDeckCardType) IsValid() bool {
	switch e {
	case MtgDeckCardTypeNormal, MtgDeckCardTypeCommander:
		return true
	}
	return false
}

func (e MtgDeckCardType) String() string {
	return string(e)
}

func (e *MtgDeckCardType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MtgDeckCardType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MTG_DeckCardType", str)
	}
	return nil
}

func (e MtgDeckCardType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type MtgGame string

const (
	MtgGamePaper MtgGame = "paper"
	MtgGameMtgo  MtgGame = "mtgo"
	MtgGameArena MtgGame = "arena"
)

var AllMtgGame = []MtgGame{
	MtgGamePaper,
	MtgGameMtgo,
	MtgGameArena,
}

func (e MtgGame) IsValid() bool {
	switch e {
	case MtgGamePaper, MtgGameMtgo, MtgGameArena:
		return true
	}
	return false
}

func (e MtgGame) String() string {
	return string(e)
}

func (e *MtgGame) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MtgGame(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MTG_Game", str)
	}
	return nil
}

func (e MtgGame) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type MtgLayout string

const (
	MtgLayoutNormal           MtgLayout = "normal"
	MtgLayoutSplit            MtgLayout = "split"
	MtgLayoutFlip             MtgLayout = "flip"
	MtgLayoutTransform        MtgLayout = "transform"
	MtgLayoutModalDfc         MtgLayout = "modal_dfc"
	MtgLayoutMeld             MtgLayout = "meld"
	MtgLayoutLeveler          MtgLayout = "leveler"
	MtgLayoutClass            MtgLayout = "class"
	MtgLayoutCase             MtgLayout = "case"
	MtgLayoutSaga             MtgLayout = "saga"
	MtgLayoutAdventure        MtgLayout = "adventure"
	MtgLayoutMutate           MtgLayout = "mutate"
	MtgLayoutPrototype        MtgLayout = "prototype"
	MtgLayoutBattle           MtgLayout = "battle"
	MtgLayoutPlanar           MtgLayout = "planar"
	MtgLayoutScheme           MtgLayout = "scheme"
	MtgLayoutVanguard         MtgLayout = "vanguard"
	MtgLayoutToken            MtgLayout = "token"
	MtgLayoutDoubleFacedToken MtgLayout = "double_faced_token"
	MtgLayoutEmblem           MtgLayout = "emblem"
	MtgLayoutAugment          MtgLayout = "augment"
	MtgLayoutHost             MtgLayout = "host"
	MtgLayoutArtSeries        MtgLayout = "art_series"
	MtgLayoutReversibleCard   MtgLayout = "reversible_card"
)

var AllMtgLayout = []MtgLayout{
	MtgLayoutNormal,
	MtgLayoutSplit,
	MtgLayoutFlip,
	MtgLayoutTransform,
	MtgLayoutModalDfc,
	MtgLayoutMeld,
	MtgLayoutLeveler,
	MtgLayoutClass,
	MtgLayoutCase,
	MtgLayoutSaga,
	MtgLayoutAdventure,
	MtgLayoutMutate,
	MtgLayoutPrototype,
	MtgLayoutBattle,
	MtgLayoutPlanar,
	MtgLayoutScheme,
	MtgLayoutVanguard,
	MtgLayoutToken,
	MtgLayoutDoubleFacedToken,
	MtgLayoutEmblem,
	MtgLayoutAugment,
	MtgLayoutHost,
	MtgLayoutArtSeries,
	MtgLayoutReversibleCard,
}

func (e MtgLayout) IsValid() bool {
	switch e {
	case MtgLayoutNormal, MtgLayoutSplit, MtgLayoutFlip, MtgLayoutTransform, MtgLayoutModalDfc, MtgLayoutMeld, MtgLayoutLeveler, MtgLayoutClass, MtgLayoutCase, MtgLayoutSaga, MtgLayoutAdventure, MtgLayoutMutate, MtgLayoutPrototype, MtgLayoutBattle, MtgLayoutPlanar, MtgLayoutScheme, MtgLayoutVanguard, MtgLayoutToken, MtgLayoutDoubleFacedToken, MtgLayoutEmblem, MtgLayoutAugment, MtgLayoutHost, MtgLayoutArtSeries, MtgLayoutReversibleCard:
		return true
	}
	return false
}

func (e MtgLayout) String() string {
	return string(e)
}

func (e *MtgLayout) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MtgLayout(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MTG_Layout", str)
	}
	return nil
}

func (e MtgLayout) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type MtgRarity string

const (
	MtgRarityCommon   MtgRarity = "common"
	MtgRarityUncommon MtgRarity = "uncommon"
	MtgRarityRare     MtgRarity = "rare"
	MtgRarityMythic   MtgRarity = "mythic"
)

var AllMtgRarity = []MtgRarity{
	MtgRarityCommon,
	MtgRarityUncommon,
	MtgRarityRare,
	MtgRarityMythic,
}

func (e MtgRarity) IsValid() bool {
	switch e {
	case MtgRarityCommon, MtgRarityUncommon, MtgRarityRare, MtgRarityMythic:
		return true
	}
	return false
}

func (e MtgRarity) String() string {
	return string(e)
}

func (e *MtgRarity) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MtgRarity(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MTG_Rarity", str)
	}
	return nil
}

func (e MtgRarity) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type MainOrSide string

const (
	MainOrSideMain      MainOrSide = "MAIN"
	MainOrSideSideboard MainOrSide = "SIDEBOARD"
)

var AllMainOrSide = []MainOrSide{
	MainOrSideMain,
	MainOrSideSideboard,
}

func (e MainOrSide) IsValid() bool {
	switch e {
	case MainOrSideMain, MainOrSideSideboard:
		return true
	}
	return false
}

func (e MainOrSide) String() string {
	return string(e)
}

func (e *MainOrSide) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MainOrSide(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MainOrSide", str)
	}
	return nil
}

func (e MainOrSide) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type RatableEntityType string

const (
	RatableEntityTypeCard RatableEntityType = "CARD"
	RatableEntityTypeTag  RatableEntityType = "TAG"
)

var AllRatableEntityType = []RatableEntityType{
	RatableEntityTypeCard,
	RatableEntityTypeTag,
}

func (e RatableEntityType) IsValid() bool {
	switch e {
	case RatableEntityTypeCard, RatableEntityTypeTag:
		return true
	}
	return false
}

func (e RatableEntityType) String() string {
	return string(e)
}

func (e *RatableEntityType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RatableEntityType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RatableEntityType", str)
	}
	return nil
}

func (e RatableEntityType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TagType string

const (
	TagTypeCardTag TagType = "CardTag"
	TagTypeDeckTag TagType = "DeckTag"
)

var AllTagType = []TagType{
	TagTypeCardTag,
	TagTypeDeckTag,
}

func (e TagType) IsValid() bool {
	switch e {
	case TagTypeCardTag, TagTypeDeckTag:
		return true
	}
	return false
}

func (e TagType) String() string {
	return string(e)
}

func (e *TagType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TagType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TagType", str)
	}
	return nil
}

func (e TagType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
