// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"strconv"
)

// A tag that can annotate cards or decks.
type Tag interface {
	IsTag()
	GetID() string
	GetName() string
	GetDescription() *string
	GetMyRating() *UserRating
}

// Mark a card as ignored for the specified deck.
type AddIgnoredCardInput struct {
	CardID string `json:"cardID"`
	DeckID string `json:"deckID"`
}

// Aggregate admin dashboard information.
type AdminDashboard struct {
	Imports              []*AdminImportSummary `json:"imports"`
	LatestLegalitiesDiff *AdminLegalitiesDiff  `json:"latestLegalitiesDiff,omitempty"`
}

// Parameters to trigger or backfill import jobs.
type AdminImportActionInput struct {
	Job   AdminJob `json:"job"`
	Force *bool    `json:"force,omitempty"`
}

// Detailed import report data exposed to admins.
type AdminImportReport struct {
	ID               string            `json:"id"`
	JobName          AdminJob          `json:"jobName"`
	Status           AdminImportStatus `json:"status"`
	StartedAt        int               `json:"startedAt"`
	CompletedAt      *int              `json:"completedAt,omitempty"`
	DurationMs       *int              `json:"durationMs,omitempty"`
	RecordsProcessed *int              `json:"recordsProcessed,omitempty"`
	ErrorMessage     *string           `json:"errorMessage,omitempty"`
	Metadata         map[string]any    `json:"metadata,omitempty"`
}

// Summary for an import job with recent runs and metrics.
type AdminImportSummary struct {
	JobName     AdminJob             `json:"jobName"`
	LastRun     *AdminImportReport   `json:"lastRun,omitempty"`
	PreviousRun *AdminImportReport   `json:"previousRun,omitempty"`
	Latency     *AdminLatencyMetrics `json:"latency"`
}

// Latency metrics derived from recent import runs.
type AdminLatencyMetrics struct {
	LastDurationMs *int `json:"lastDurationMs,omitempty"`
	AvgDurationMs  *int `json:"avgDurationMs,omitempty"`
	P50DurationMs  *int `json:"p50DurationMs,omitempty"`
	P90DurationMs  *int `json:"p90DurationMs,omitempty"`
	TotalRuns      int  `json:"totalRuns"`
	LastStartedAt  *int `json:"lastStartedAt,omitempty"`
}

// Collection of legality changes tied to an import run.
type AdminLegalitiesDiff struct {
	ImportID string                      `json:"importId"`
	JobName  AdminJob                    `json:"jobName"`
	Entries  []*AdminLegalitiesDiffEntry `json:"entries"`
}

// Single legality change entry between consecutive imports.
type AdminLegalitiesDiffEntry struct {
	CardID         string  `json:"cardID"`
	CardName       string  `json:"cardName"`
	Format         string  `json:"format"`
	PreviousStatus *string `json:"previousStatus,omitempty"`
	CurrentStatus  *string `json:"currentStatus,omitempty"`
	SetCode        *string `json:"setCode,omitempty"`
	SetName        *string `json:"setName,omitempty"`
	ChangedAt      int     `json:"changedAt"`
}

// Assign a tag to a card.
type AssignTagInput struct {
	TagID  string `json:"tagID"`
	CardID string `json:"cardID"`
}

// A tag intended for annotating cards.
type CardTag struct {
	ID          string      `json:"_key"`
	Name        string      `json:"name"`
	Description *string     `json:"description,omitempty"`
	MyRating    *UserRating `json:"myRating,omitempty"`
}

func (CardTag) IsTag()                        {}
func (this CardTag) GetID() string            { return this.ID }
func (this CardTag) GetName() string          { return this.Name }
func (this CardTag) GetDescription() *string  { return this.Description }
func (this CardTag) GetMyRating() *UserRating { return this.MyRating }

// Create a new tag, optionally linked to a card.
type CreateTagInput struct {
	Type        TagType    `json:"type"`
	Name        string     `json:"name"`
	Description *string    `json:"description,omitempty"`
	Colors      []MtgColor `json:"colors,omitempty"`
	CardID      *string    `json:"cardID,omitempty"`
}

type DeckTag struct {
	ID          string      `json:"_key"`
	Name        string      `json:"name"`
	Description *string     `json:"description,omitempty"`
	MyRating    *UserRating `json:"myRating,omitempty"`
	Colors      []MtgColor  `json:"colors"`
}

func (DeckTag) IsTag()                        {}
func (this DeckTag) GetID() string            { return this.ID }
func (this DeckTag) GetName() string          { return this.Name }
func (this DeckTag) GetDescription() *string  { return this.Description }
func (this DeckTag) GetMyRating() *UserRating { return this.MyRating }

// Represents a zone in the deck builder.
type FlowZone struct {
	ID           string    `json:"ID"`
	Name         string    `json:"name"`
	Position     *Position `json:"position"`
	Width        float64   `json:"width"`
	Height       float64   `json:"height"`
	CardChildren []string  `json:"cardChildren"`
	ZoneChildren []string  `json:"zoneChildren"`
}

// Used to save the deck builder zones and their children.
type FlowZoneInput struct {
	ID           string         `json:"ID"`
	Name         string         `json:"name"`
	Position     *PositionInput `json:"position"`
	Width        float64        `json:"width"`
	Height       float64        `json:"height"`
	CardChildren []string       `json:"cardChildren"`
	ZoneChildren []string       `json:"zoneChildren"`
}

// Add a card to a package with count.
type MtgAddCardToCardPackageInput struct {
	CardPackageID string `json:"cardPackageID"`
	Card          string `json:"card"`
	Count         int    `json:"count"`
}

// Aggregated MTG card entity with curated versions and user context.
type MtgCard struct {
	ID             string            `json:"_key"`
	Layout         MtgLayout         `json:"layout"`
	Cmc            float64           `json:"CMC"`
	ColorIdentity  []MtgColor        `json:"colorIdentity"`
	ColorIndicator []string          `json:"colorIndicator,omitempty"`
	Colors         []MtgColor        `json:"colors,omitempty"`
	EDHRecRank     *int              `json:"EDHRecRank,omitempty"`
	Keywords       []string          `json:"keywords"`
	Loyalty        *string           `json:"loyalty,omitempty"`
	ManaCost       *string           `json:"manaCost,omitempty"`
	Name           string            `json:"name"`
	OracleText     *string           `json:"oracleText,omitempty"`
	Power          *string           `json:"power,omitempty"`
	ProducedMana   []MtgColor        `json:"producedMana,omitempty"`
	Toughness      *string           `json:"toughness,omitempty"`
	TypeLine       string            `json:"typeLine"`
	Versions       []*MtgCardVersion `json:"versions"`
	MyRating       *UserRating       `json:"myRating,omitempty"`
	CardTags       []*CardTag        `json:"cardTags"`
	DeckTags       []*DeckTag        `json:"deckTags"`
}

// One face of a multi-faced card version.
type MtgCardFace struct {
	Artist         *string    `json:"artist,omitempty"`
	Cmc            *float64   `json:"CMC,omitempty"`
	ColorIndicator []string   `json:"colorIndicator,omitempty"`
	Colors         []MtgColor `json:"colors,omitempty"`
	FlavorText     *string    `json:"flavorText,omitempty"`
	ImageUris      *MtgImage  `json:"imageUris,omitempty"`
	Layout         *MtgLayout `json:"layout,omitempty"`
	Loyalty        *string    `json:"loyalty,omitempty"`
	ManaCost       string     `json:"manaCost"`
	Name           string     `json:"name"`
	OracleText     *string    `json:"oracleText,omitempty"`
	Power          *string    `json:"power,omitempty"`
	Toughness      *string    `json:"toughness,omitempty"`
	TypeLine       *string    `json:"typeLine,omitempty"`
}

// Minimal face data for dashboard UI.
type MtgCardFaceDashboard struct {
	ImageUris *MtgImage `json:"imageUris,omitempty"`
}

// A package grouping cards outside of a deck context.
type MtgCardPackage struct {
	ID    string                `json:"_key"`
	Name  string                `json:"name"`
	Cards []*MtgCardPackageCard `json:"cards"`
	Zones []*FlowZone           `json:"zones"`
}

// A card entry inside a card package.
type MtgCardPackageCard struct {
	Card              *MtgCard   `json:"card"`
	SelectedVersionID *string    `json:"selectedVersionID,omitempty"`
	Count             int        `json:"count"`
	MainOrSide        MainOrSide `json:"mainOrSide"`
	Position          *Position  `json:"position"`
	Phantoms          []*Phantom `json:"phantoms"`
}

// Card entry details for a package.
type MtgCardPackageCardInput struct {
	Card              string     `json:"card"`
	SelectedVersionID *string    `json:"selectedVersionID,omitempty"`
	Count             int        `json:"count"`
	MainOrSide        MainOrSide `json:"mainOrSide"`
}

// A specific printing/version of a card used by the app.
type MtgCardVersion struct {
	ID          string         `json:"ID"`
	IsDefault   bool           `json:"isDefault"`
	IsAlchemy   bool           `json:"isAlchemy"`
	Artist      *string        `json:"artist,omitempty"`
	Lang        string         `json:"lang"`
	FlavorName  *string        `json:"flavorName,omitempty"`
	FlavorText  *string        `json:"flavorText,omitempty"`
	CardFaces   []*MtgCardFace `json:"cardFaces,omitempty"`
	Legalities  map[string]any `json:"legalities"`
	Games       []MtgGame      `json:"games"`
	ImageUris   *MtgImage      `json:"imageUris,omitempty"`
	Rarity      MtgRarity      `json:"rarity"`
	ReleasedAt  string         `json:"releasedAt"`
	Reprint     bool           `json:"reprint"`
	SetName     string         `json:"setName"`
	SetType     string         `json:"setType"`
	Set         string         `json:"set"`
	SetID       string         `json:"setID"`
	Variation   bool           `json:"variation"`
	VariationOf *string        `json:"variationOf,omitempty"`
}

// Minimal card version data for dashboard UI.
type MtgCardVersionDashboard struct {
	ID        string                  `json:"ID"`
	IsDefault bool                    `json:"isDefault"`
	IsAlchemy bool                    `json:"isAlchemy"`
	CardFaces []*MtgCardFaceDashboard `json:"cardFaces"`
	ImageUris *MtgImage               `json:"imageUris,omitempty"`
}

// Minimal card representation for dashboard listings.
type MtgCardDashboard struct {
	ID       string                     `json:"_key"`
	Versions []*MtgCardVersionDashboard `json:"versions"`
}

// Create a new card package.
type MtgCreateCardPackageInput struct {
	Name string `json:"name"`
}

// Input to create a new deck.
type MtgCreateDeckInput struct {
	Name string `json:"name"`
}

// A user deck with cards, positions, zones and optional front image.
type MtgDeck struct {
	ID             string                 `json:"_key"`
	Name           string                 `json:"name"`
	CardFrontImage *MtgDeckCardFrontImage `json:"cardFrontImage,omitempty"`
	Cards          []*MtgDeckCard         `json:"cards"`
	Zones          []*FlowZone            `json:"zones"`
	IgnoredCards   []string               `json:"ignoredCards"`
}

// A card entry in a deck with selection and positioning metadata.
type MtgDeckCard struct {
	Card              *MtgCard        `json:"card"`
	SelectedVersionID *string         `json:"selectedVersionID,omitempty"`
	Count             int             `json:"count"`
	Position          *Position       `json:"position"`
	MainOrSide        MainOrSide      `json:"mainOrSide"`
	DeckCardType      MtgDeckCardType `json:"deckCardType"`
	Phantoms          []*Phantom      `json:"phantoms"`
}

// Front image selection referencing a card version.
type MtgDeckCardFrontImageInput struct {
	CardID    string `json:"cardID"`
	VersionID string `json:"versionID"`
}

// Deck card entry with position and selection metadata.
type MtgDeckCardInput struct {
	ID                string          `json:"ID"`
	Card              string          `json:"card"`
	SelectedVersionID *string         `json:"selectedVersionID,omitempty"`
	Count             int             `json:"count"`
	Position          *PositionInput  `json:"position"`
	MainOrSide        MainOrSide      `json:"mainOrSide"`
	DeckCardType      MtgDeckCardType `json:"deckCardType"`
	Phantoms          []*PhantomInput `json:"phantoms"`
}

// Minimal deck card data for dashboard UI.
type MtgDeckCardDashboard struct {
	Card              *MtgCardDashboard `json:"card"`
	SelectedVersionID *string           `json:"selectedVersionID,omitempty"`
}

// Deck summary for dashboard listings.
type MtgDeckDashboard struct {
	ID             string                  `json:"_key"`
	Name           string                  `json:"name"`
	CardFrontImage *MtgDeckCardFrontImage  `json:"cardFrontImage,omitempty"`
	Cards          []*MtgDeckCardDashboard `json:"cards"`
}

// Selected front image for a deck, referencing a card version.
type MtgDeckCardFrontImage struct {
	CardID    string `json:"cardID"`
	VersionID string `json:"versionID"`
	Image     string `json:"image"`
}

// Delete a card package by ID.
type MtgDeleteCardPackageInput struct {
	CardPackageID string `json:"cardPackageID"`
}

// Input to delete a deck by ID.
type MtgDeleteDeckInput struct {
	DeckID string `json:"deckID"`
}

// Edit a card package name.
type MtgEditCardPackageNameInput struct {
	CardPackageID string `json:"cardPackageID"`
	Name          string `json:"name"`
}

// Card type filter entry with ternary state.
type MtgFilterCardTypeInput struct {
	CardType string         `json:"cardType"`
	Value    TernaryBoolean `json:"value"`
}

// A card type and its associated subtypes.
type MtgFilterCardTypes struct {
	CardType string   `json:"cardType"`
	Subtypes []string `json:"subtypes"`
}

// Color filter entry with ternary state.
type MtgFilterColorInput struct {
	Color MtgColor       `json:"color"`
	Value TernaryBoolean `json:"value"`
}

// Aggregated entries used to render filter UI.
type MtgFilterEntries struct {
	Types      []*MtgFilterCardTypes `json:"types"`
	Expansions []*MtgFilterExpansion `json:"expansions"`
	Legality   *MtgFilterLegality    `json:"legality"`
	Layouts    []MtgLayout           `json:"layouts"`
}

// Expansion metadata used by filters and sorting.
type MtgFilterExpansion struct {
	Set        string    `json:"set"`
	SetName    string    `json:"setName"`
	ReleasedAt int       `json:"releasedAt"`
	ImageURL   string    `json:"imageURL"`
	SetType    string    `json:"setType"`
	Games      []MtgGame `json:"games"`
}

// Game platform filter entry with ternary state.
type MtgFilterGameInput struct {
	Game  MtgGame        `json:"game"`
	Value TernaryBoolean `json:"value"`
}

// Layout filter entry with ternary state.
type MtgFilterLayoutInput struct {
	Layout MtgLayout      `json:"layout"`
	Value  TernaryBoolean `json:"value"`
}

// Distinct legality formats and statuses collected from cards.
type MtgFilterLegality struct {
	Formats        []string `json:"formats"`
	LegalityValues []string `json:"legalityValues"`
}

// Single legality value with ternary state.
type MtgFilterLegalityEntryInput struct {
	LegalityValue string         `json:"legalityValue"`
	Value         TernaryBoolean `json:"value"`
}

// Legality format and associated statuses.
type MtgFilterLegalityInput struct {
	Format          string                         `json:"format"`
	LegalityEntries []*MtgFilterLegalityEntryInput `json:"legalityEntries"`
}

// Mana cost filter entry with ternary state or special values.
type MtgFilterManaCostInput struct {
	ManaCost string         `json:"manaCost"`
	Value    TernaryBoolean `json:"value"`
}

// Page and page size for cursorless pagination.
type MtgFilterPaginationInput struct {
	Page     int `json:"page"`
	PageSize int `json:"pageSize"`
}

// Rarity filter entry with ternary state.
type MtgFilterRarityInput struct {
	Rarity MtgRarity      `json:"rarity"`
	Value  TernaryBoolean `json:"value"`
}

// Min/max rating bounds for filtering.
type MtgFilterRatingInput struct {
	Min *int `json:"min,omitempty"`
	Max *int `json:"max,omitempty"`
}

// Search results and total count for pagination.
type MtgFilterSearch struct {
	PagedCards []*MtgCard `json:"pagedCards"`
	TotalCount int        `json:"totalCount"`
}

// Combined filter input used to filter cards.
type MtgFilterSearchInput struct {
	SearchString         *string                   `json:"searchString,omitempty"`
	Rarity               []*MtgFilterRarityInput   `json:"rarity"`
	Color                []*MtgFilterColorInput    `json:"color"`
	MultiColor           TernaryBoolean            `json:"multiColor"`
	ManaCosts            []*MtgFilterManaCostInput `json:"manaCosts"`
	CardTypes            []*MtgFilterCardTypeInput `json:"cardTypes"`
	Subtypes             []*MtgFilterSubtypeInput  `json:"subtypes"`
	Sets                 []*MtgFilterSetInput      `json:"sets"`
	Legalities           []*MtgFilterLegalityInput `json:"legalities"`
	Layouts              []*MtgFilterLayoutInput   `json:"layouts"`
	Games                []*MtgFilterGameInput     `json:"games"`
	HideIgnored          bool                      `json:"hideIgnored"`
	Tags                 []*MtgFilterTagInput      `json:"tags"`
	Rating               *MtgFilterRatingInput     `json:"rating"`
	Commander            *string                   `json:"commander,omitempty"`
	DeckID               *string                   `json:"deckID,omitempty"`
	IsSelectingCommander bool                      `json:"isSelectingCommander"`
}

// Set filter entry with ternary state.
type MtgFilterSetInput struct {
	Set   string         `json:"set"`
	Value TernaryBoolean `json:"value"`
}

// Sort directive with field, direction, and enabled flag.
type MtgFilterSortInput struct {
	SortBy        MtgFilterSortBy        `json:"sortBy"`
	SortDirection MtgFilterSortDirection `json:"sortDirection"`
	Enabled       bool                   `json:"enabled"`
}

// Subtype filter entry with ternary state.
type MtgFilterSubtypeInput struct {
	Subtype string         `json:"subtype"`
	Value   TernaryBoolean `json:"value"`
}

// Tag filter entry by name or id with ternary state.
type MtgFilterTagInput struct {
	Tag   string         `json:"tag"`
	Value TernaryBoolean `json:"value"`
}

// Image URLs in multiple sizes from Scryfall.
type MtgImage struct {
	ArtCrop    string `json:"artCrop"`
	BorderCrop string `json:"borderCrop"`
	Large      string `json:"large"`
	Normal     string `json:"normal"`
	Png        string `json:"PNG"`
	Small      string `json:"small"`
}

// Remove a card from a package.
type MtgRemoveCardFromCardPackageInput struct {
	CardPackageID string `json:"cardPackageID"`
	Card          string `json:"card"`
}

// Input to update deck fields, cards, zones and front image.
type MtgUpdateDeckInput struct {
	DeckID         string                      `json:"deckID"`
	Name           string                      `json:"name"`
	CardFrontImage *MtgDeckCardFrontImageInput `json:"cardFrontImage,omitempty"`
	Cards          []*MtgDeckCardInput         `json:"cards"`
	Zones          []*FlowZoneInput            `json:"zones"`
}

// Root-level write operations.
type Mutation struct {
}

// A phantom placeholder used for visual grouping on the board.
type Phantom struct {
	Position *Position `json:"position"`
	ID       string    `json:"ID"`
}

// Phantom placeholder to aid UI grouping.
type PhantomInput struct {
	ID       string         `json:"ID"`
	Position *PositionInput `json:"position"`
}

// Represents the position of an entity in the deck builder.
type Position struct {
	X float64 `json:"x"`
	Y float64 `json:"y"`
}

// Used to save the position of an entity in the deck builder.
type PositionInput struct {
	X float64 `json:"x"`
	Y float64 `json:"y"`
}

// Root-level read operations.
type Query struct {
}

// Rate a card or tag by ID.
type RateInput struct {
	EntityID   string            `json:"entityID"`
	EntityType RatableEntityType `json:"entityType"`
	Value      int               `json:"value"`
}

// Remove an ignored mark for a deck/card pair.
type RemoveIgnoredCardInput struct {
	CardID string `json:"cardID"`
	DeckID string `json:"deckID"`
}

// Generic response wrapper with status and optional message.
type Response struct {
	Status  bool    `json:"status"`
	Message *string `json:"message,omitempty"`
}

// Remove a tag from a card.
type UnassignTagInput struct {
	TagID  string `json:"tagID"`
	CardID string `json:"cardID"`
}

// Update tag fields.
type UpdateTagInput struct {
	ID          string     `json:"ID"`
	Name        *string    `json:"name,omitempty"`
	Description *string    `json:"description,omitempty"`
	Colors      []MtgColor `json:"colors,omitempty"`
}

// A user entity used for ratings and ownership.
type User struct {
	ID    string     `json:"_key"`
	Roles []UserRole `json:"roles"`
}

// A user's rating for an entity (card or tag).
type UserRating struct {
	User  *User `json:"user"`
	Value int   `json:"value"`
}

// Execution status values for an import run.
type AdminImportStatus string

const (
	AdminImportStatusRunning AdminImportStatus = "RUNNING"
	AdminImportStatusSuccess AdminImportStatus = "SUCCESS"
	AdminImportStatusFailed  AdminImportStatus = "FAILED"
	AdminImportStatusSkipped AdminImportStatus = "SKIPPED"
)

var AllAdminImportStatus = []AdminImportStatus{
	AdminImportStatusRunning,
	AdminImportStatusSuccess,
	AdminImportStatusFailed,
	AdminImportStatusSkipped,
}

func (e AdminImportStatus) IsValid() bool {
	switch e {
	case AdminImportStatusRunning, AdminImportStatusSuccess, AdminImportStatusFailed, AdminImportStatusSkipped:
		return true
	}
	return false
}

func (e AdminImportStatus) String() string {
	return string(e)
}

func (e *AdminImportStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AdminImportStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AdminImportStatus", str)
	}
	return nil
}

func (e AdminImportStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Background jobs supported by the importer.
type AdminJob string

const (
	AdminJobMtgCards AdminJob = "MTG_CARDS"
	AdminJobMtgSets  AdminJob = "MTG_SETS"
)

var AllAdminJob = []AdminJob{
	AdminJobMtgCards,
	AdminJobMtgSets,
}

func (e AdminJob) IsValid() bool {
	switch e {
	case AdminJobMtgCards, AdminJobMtgSets:
		return true
	}
	return false
}

func (e AdminJob) String() string {
	return string(e)
}

func (e *AdminJob) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AdminJob(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AdminJob", str)
	}
	return nil
}

func (e AdminJob) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Supported deck archetypes.
type DeckType string

const (
	DeckTypeBrawl60  DeckType = "BRAWL_60"
	DeckTypeBrawl100 DeckType = "BRAWL_100"
)

var AllDeckType = []DeckType{
	DeckTypeBrawl60,
	DeckTypeBrawl100,
}

func (e DeckType) IsValid() bool {
	switch e {
	case DeckTypeBrawl60, DeckTypeBrawl100:
		return true
	}
	return false
}

func (e DeckType) String() string {
	return string(e)
}

func (e *DeckType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DeckType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DeckType", str)
	}
	return nil
}

func (e DeckType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Magic color identity abbreviations.
type MtgColor string

const (
	MtgColorC MtgColor = "C"
	MtgColorW MtgColor = "W"
	MtgColorU MtgColor = "U"
	MtgColorB MtgColor = "B"
	MtgColorR MtgColor = "R"
	MtgColorG MtgColor = "G"
)

var AllMtgColor = []MtgColor{
	MtgColorC,
	MtgColorW,
	MtgColorU,
	MtgColorB,
	MtgColorR,
	MtgColorG,
}

func (e MtgColor) IsValid() bool {
	switch e {
	case MtgColorC, MtgColorW, MtgColorU, MtgColorB, MtgColorR, MtgColorG:
		return true
	}
	return false
}

func (e MtgColor) String() string {
	return string(e)
}

func (e *MtgColor) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MtgColor(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MTG_Color", str)
	}
	return nil
}

func (e MtgColor) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Card role in deck (normal or commander).
type MtgDeckCardType string

const (
	MtgDeckCardTypeNormal    MtgDeckCardType = "NORMAL"
	MtgDeckCardTypeCommander MtgDeckCardType = "COMMANDER"
)

var AllMtgDeckCardType = []MtgDeckCardType{
	MtgDeckCardTypeNormal,
	MtgDeckCardTypeCommander,
}

func (e MtgDeckCardType) IsValid() bool {
	switch e {
	case MtgDeckCardTypeNormal, MtgDeckCardTypeCommander:
		return true
	}
	return false
}

func (e MtgDeckCardType) String() string {
	return string(e)
}

func (e *MtgDeckCardType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MtgDeckCardType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MTG_DeckCardType", str)
	}
	return nil
}

func (e MtgDeckCardType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Sortable fields for card lists.
type MtgFilterSortBy string

const (
	MtgFilterSortByName       MtgFilterSortBy = "NAME"
	MtgFilterSortByCmc        MtgFilterSortBy = "CMC"
	MtgFilterSortByRarity     MtgFilterSortBy = "RARITY"
	MtgFilterSortByColor      MtgFilterSortBy = "COLOR"
	MtgFilterSortByType       MtgFilterSortBy = "TYPE"
	MtgFilterSortBySet        MtgFilterSortBy = "SET"
	MtgFilterSortByReleasedAt MtgFilterSortBy = "RELEASED_AT"
)

var AllMtgFilterSortBy = []MtgFilterSortBy{
	MtgFilterSortByName,
	MtgFilterSortByCmc,
	MtgFilterSortByRarity,
	MtgFilterSortByColor,
	MtgFilterSortByType,
	MtgFilterSortBySet,
	MtgFilterSortByReleasedAt,
}

func (e MtgFilterSortBy) IsValid() bool {
	switch e {
	case MtgFilterSortByName, MtgFilterSortByCmc, MtgFilterSortByRarity, MtgFilterSortByColor, MtgFilterSortByType, MtgFilterSortBySet, MtgFilterSortByReleasedAt:
		return true
	}
	return false
}

func (e MtgFilterSortBy) String() string {
	return string(e)
}

func (e *MtgFilterSortBy) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MtgFilterSortBy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MTG_Filter_SortBy", str)
	}
	return nil
}

func (e MtgFilterSortBy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Sort direction.
type MtgFilterSortDirection string

const (
	MtgFilterSortDirectionAsc  MtgFilterSortDirection = "ASC"
	MtgFilterSortDirectionDesc MtgFilterSortDirection = "DESC"
)

var AllMtgFilterSortDirection = []MtgFilterSortDirection{
	MtgFilterSortDirectionAsc,
	MtgFilterSortDirectionDesc,
}

func (e MtgFilterSortDirection) IsValid() bool {
	switch e {
	case MtgFilterSortDirectionAsc, MtgFilterSortDirectionDesc:
		return true
	}
	return false
}

func (e MtgFilterSortDirection) String() string {
	return string(e)
}

func (e *MtgFilterSortDirection) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MtgFilterSortDirection(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MTG_Filter_SortDirection", str)
	}
	return nil
}

func (e MtgFilterSortDirection) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Game platforms where a print is available.
type MtgGame string

const (
	MtgGamePaper MtgGame = "paper"
	MtgGameMtgo  MtgGame = "mtgo"
	MtgGameArena MtgGame = "arena"
)

var AllMtgGame = []MtgGame{
	MtgGamePaper,
	MtgGameMtgo,
	MtgGameArena,
}

func (e MtgGame) IsValid() bool {
	switch e {
	case MtgGamePaper, MtgGameMtgo, MtgGameArena:
		return true
	}
	return false
}

func (e MtgGame) String() string {
	return string(e)
}

func (e *MtgGame) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MtgGame(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MTG_Game", str)
	}
	return nil
}

func (e MtgGame) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Card layouts as defined by Scryfall.
type MtgLayout string

const (
	MtgLayoutNormal           MtgLayout = "normal"
	MtgLayoutSplit            MtgLayout = "split"
	MtgLayoutFlip             MtgLayout = "flip"
	MtgLayoutTransform        MtgLayout = "transform"
	MtgLayoutModalDfc         MtgLayout = "modal_dfc"
	MtgLayoutMeld             MtgLayout = "meld"
	MtgLayoutLeveler          MtgLayout = "leveler"
	MtgLayoutClass            MtgLayout = "class"
	MtgLayoutCase             MtgLayout = "case"
	MtgLayoutSaga             MtgLayout = "saga"
	MtgLayoutAdventure        MtgLayout = "adventure"
	MtgLayoutMutate           MtgLayout = "mutate"
	MtgLayoutPrototype        MtgLayout = "prototype"
	MtgLayoutBattle           MtgLayout = "battle"
	MtgLayoutPlanar           MtgLayout = "planar"
	MtgLayoutScheme           MtgLayout = "scheme"
	MtgLayoutVanguard         MtgLayout = "vanguard"
	MtgLayoutToken            MtgLayout = "token"
	MtgLayoutDoubleFacedToken MtgLayout = "double_faced_token"
	MtgLayoutEmblem           MtgLayout = "emblem"
	MtgLayoutAugment          MtgLayout = "augment"
	MtgLayoutHost             MtgLayout = "host"
	MtgLayoutArtSeries        MtgLayout = "art_series"
	MtgLayoutReversibleCard   MtgLayout = "reversible_card"
)

var AllMtgLayout = []MtgLayout{
	MtgLayoutNormal,
	MtgLayoutSplit,
	MtgLayoutFlip,
	MtgLayoutTransform,
	MtgLayoutModalDfc,
	MtgLayoutMeld,
	MtgLayoutLeveler,
	MtgLayoutClass,
	MtgLayoutCase,
	MtgLayoutSaga,
	MtgLayoutAdventure,
	MtgLayoutMutate,
	MtgLayoutPrototype,
	MtgLayoutBattle,
	MtgLayoutPlanar,
	MtgLayoutScheme,
	MtgLayoutVanguard,
	MtgLayoutToken,
	MtgLayoutDoubleFacedToken,
	MtgLayoutEmblem,
	MtgLayoutAugment,
	MtgLayoutHost,
	MtgLayoutArtSeries,
	MtgLayoutReversibleCard,
}

func (e MtgLayout) IsValid() bool {
	switch e {
	case MtgLayoutNormal, MtgLayoutSplit, MtgLayoutFlip, MtgLayoutTransform, MtgLayoutModalDfc, MtgLayoutMeld, MtgLayoutLeveler, MtgLayoutClass, MtgLayoutCase, MtgLayoutSaga, MtgLayoutAdventure, MtgLayoutMutate, MtgLayoutPrototype, MtgLayoutBattle, MtgLayoutPlanar, MtgLayoutScheme, MtgLayoutVanguard, MtgLayoutToken, MtgLayoutDoubleFacedToken, MtgLayoutEmblem, MtgLayoutAugment, MtgLayoutHost, MtgLayoutArtSeries, MtgLayoutReversibleCard:
		return true
	}
	return false
}

func (e MtgLayout) String() string {
	return string(e)
}

func (e *MtgLayout) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MtgLayout(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MTG_Layout", str)
	}
	return nil
}

func (e MtgLayout) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Rarity tiers for a printing.
type MtgRarity string

const (
	MtgRarityCommon   MtgRarity = "common"
	MtgRarityUncommon MtgRarity = "uncommon"
	MtgRarityRare     MtgRarity = "rare"
	MtgRarityMythic   MtgRarity = "mythic"
)

var AllMtgRarity = []MtgRarity{
	MtgRarityCommon,
	MtgRarityUncommon,
	MtgRarityRare,
	MtgRarityMythic,
}

func (e MtgRarity) IsValid() bool {
	switch e {
	case MtgRarityCommon, MtgRarityUncommon, MtgRarityRare, MtgRarityMythic:
		return true
	}
	return false
}

func (e MtgRarity) String() string {
	return string(e)
}

func (e *MtgRarity) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MtgRarity(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MTG_Rarity", str)
	}
	return nil
}

func (e MtgRarity) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Indicates whether a card is in main or sideboard.
type MainOrSide string

const (
	MainOrSideMain      MainOrSide = "MAIN"
	MainOrSideSideboard MainOrSide = "SIDEBOARD"
)

var AllMainOrSide = []MainOrSide{
	MainOrSideMain,
	MainOrSideSideboard,
}

func (e MainOrSide) IsValid() bool {
	switch e {
	case MainOrSideMain, MainOrSideSideboard:
		return true
	}
	return false
}

func (e MainOrSide) String() string {
	return string(e)
}

func (e *MainOrSide) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MainOrSide(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MainOrSide", str)
	}
	return nil
}

func (e MainOrSide) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Entities that can be rated by users.
type RatableEntityType string

const (
	RatableEntityTypeCard RatableEntityType = "CARD"
	RatableEntityTypeTag  RatableEntityType = "TAG"
)

var AllRatableEntityType = []RatableEntityType{
	RatableEntityTypeCard,
	RatableEntityTypeTag,
}

func (e RatableEntityType) IsValid() bool {
	switch e {
	case RatableEntityTypeCard, RatableEntityTypeTag:
		return true
	}
	return false
}

func (e RatableEntityType) String() string {
	return string(e)
}

func (e *RatableEntityType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RatableEntityType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RatableEntityType", str)
	}
	return nil
}

func (e RatableEntityType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Union discriminator for tag concrete types.
type TagType string

const (
	TagTypeCardTag TagType = "CardTag"
	TagTypeDeckTag TagType = "DeckTag"
)

var AllTagType = []TagType{
	TagTypeCardTag,
	TagTypeDeckTag,
}

func (e TagType) IsValid() bool {
	switch e {
	case TagTypeCardTag, TagTypeDeckTag:
		return true
	}
	return false
}

func (e TagType) String() string {
	return string(e)
}

func (e *TagType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TagType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TagType", str)
	}
	return nil
}

func (e TagType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Three-state boolean used for filter entries.
type TernaryBoolean string

const (
	TernaryBooleanTrue  TernaryBoolean = "TRUE"
	TernaryBooleanFalse TernaryBoolean = "FALSE"
	TernaryBooleanUnset TernaryBoolean = "UNSET"
)

var AllTernaryBoolean = []TernaryBoolean{
	TernaryBooleanTrue,
	TernaryBooleanFalse,
	TernaryBooleanUnset,
}

func (e TernaryBoolean) IsValid() bool {
	switch e {
	case TernaryBooleanTrue, TernaryBooleanFalse, TernaryBooleanUnset:
		return true
	}
	return false
}

func (e TernaryBoolean) String() string {
	return string(e)
}

func (e *TernaryBoolean) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TernaryBoolean(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TernaryBoolean", str)
	}
	return nil
}

func (e TernaryBoolean) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Roles that can be assigned to a user.
type UserRole string

const (
	UserRoleAdmin UserRole = "ADMIN"
	UserRoleUser  UserRole = "USER"
)

var AllUserRole = []UserRole{
	UserRoleAdmin,
	UserRoleUser,
}

func (e UserRole) IsValid() bool {
	switch e {
	case UserRoleAdmin, UserRoleUser:
		return true
	}
	return false
}

func (e UserRole) String() string {
	return string(e)
}

func (e *UserRole) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UserRole(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UserRole", str)
	}
	return nil
}

func (e UserRole) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
