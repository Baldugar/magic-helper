// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package gentypes

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"magic-helper/graph/model"
	"strconv"
	"sync"
	"sync/atomic"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Mutation() MutationResolver
	Query() QueryResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	AdminDashboard struct {
		Imports              func(childComplexity int) int
		LatestLegalitiesDiff func(childComplexity int) int
	}

	AdminImportReport struct {
		CompletedAt      func(childComplexity int) int
		DurationMs       func(childComplexity int) int
		ErrorMessage     func(childComplexity int) int
		ID               func(childComplexity int) int
		JobName          func(childComplexity int) int
		Metadata         func(childComplexity int) int
		RecordsProcessed func(childComplexity int) int
		StartedAt        func(childComplexity int) int
		Status           func(childComplexity int) int
	}

	AdminImportSummary struct {
		JobName     func(childComplexity int) int
		LastRun     func(childComplexity int) int
		Latency     func(childComplexity int) int
		PreviousRun func(childComplexity int) int
	}

	AdminLatencyMetrics struct {
		AvgDurationMs  func(childComplexity int) int
		LastDurationMs func(childComplexity int) int
		LastStartedAt  func(childComplexity int) int
		P50DurationMs  func(childComplexity int) int
		P90DurationMs  func(childComplexity int) int
		TotalRuns      func(childComplexity int) int
	}

	AdminLegalitiesDiff struct {
		Entries  func(childComplexity int) int
		ImportID func(childComplexity int) int
		JobName  func(childComplexity int) int
	}

	AdminLegalitiesDiffEntry struct {
		CardID         func(childComplexity int) int
		CardName       func(childComplexity int) int
		ChangedAt      func(childComplexity int) int
		CurrentStatus  func(childComplexity int) int
		Format         func(childComplexity int) int
		PreviousStatus func(childComplexity int) int
		SetCode        func(childComplexity int) int
		SetName        func(childComplexity int) int
	}

	CardTag struct {
		Description func(childComplexity int) int
		ID          func(childComplexity int) int
		MyRating    func(childComplexity int) int
		Name        func(childComplexity int) int
	}

	DeckTag struct {
		Colors      func(childComplexity int) int
		Description func(childComplexity int) int
		ID          func(childComplexity int) int
		MyRating    func(childComplexity int) int
		Name        func(childComplexity int) int
	}

	FlowZone struct {
		CardChildren func(childComplexity int) int
		Height       func(childComplexity int) int
		ID           func(childComplexity int) int
		Name         func(childComplexity int) int
		Position     func(childComplexity int) int
		Width        func(childComplexity int) int
		ZoneChildren func(childComplexity int) int
	}

	MTG_Card struct {
		CardTags       func(childComplexity int) int
		Cmc            func(childComplexity int) int
		ColorIdentity  func(childComplexity int) int
		ColorIndicator func(childComplexity int) int
		Colors         func(childComplexity int) int
		DeckTags       func(childComplexity int) int
		EDHRecRank     func(childComplexity int) int
		ID             func(childComplexity int) int
		Keywords       func(childComplexity int) int
		Layout         func(childComplexity int) int
		Loyalty        func(childComplexity int) int
		ManaCost       func(childComplexity int) int
		MyRating       func(childComplexity int) int
		Name           func(childComplexity int) int
		OracleText     func(childComplexity int) int
		Power          func(childComplexity int) int
		ProducedMana   func(childComplexity int) int
		Toughness      func(childComplexity int) int
		TypeLine       func(childComplexity int) int
		Versions       func(childComplexity int) int
	}

	MTG_CardFace struct {
		Artist         func(childComplexity int) int
		Cmc            func(childComplexity int) int
		ColorIndicator func(childComplexity int) int
		Colors         func(childComplexity int) int
		FlavorText     func(childComplexity int) int
		ImageUris      func(childComplexity int) int
		Layout         func(childComplexity int) int
		Loyalty        func(childComplexity int) int
		ManaCost       func(childComplexity int) int
		Name           func(childComplexity int) int
		OracleText     func(childComplexity int) int
		Power          func(childComplexity int) int
		Toughness      func(childComplexity int) int
		TypeLine       func(childComplexity int) int
	}

	MTG_CardFace_Dashboard struct {
		ImageUris func(childComplexity int) int
	}

	MTG_CardPackage struct {
		Cards    func(childComplexity int) int
		ID       func(childComplexity int) int
		IsPublic func(childComplexity int) int
		Name     func(childComplexity int) int
		OwnerID  func(childComplexity int) int
		Zones    func(childComplexity int) int
	}

	MTG_CardPackageCard struct {
		Card              func(childComplexity int) int
		Count             func(childComplexity int) int
		MainOrSide        func(childComplexity int) int
		Phantoms          func(childComplexity int) int
		Position          func(childComplexity int) int
		SelectedVersionID func(childComplexity int) int
	}

	MTG_CardVersion struct {
		Artist      func(childComplexity int) int
		CardFaces   func(childComplexity int) int
		FlavorName  func(childComplexity int) int
		FlavorText  func(childComplexity int) int
		Games       func(childComplexity int) int
		ID          func(childComplexity int) int
		ImageUris   func(childComplexity int) int
		IsAlchemy   func(childComplexity int) int
		IsDefault   func(childComplexity int) int
		Lang        func(childComplexity int) int
		Legalities  func(childComplexity int) int
		PrintedName func(childComplexity int) int
		Rarity      func(childComplexity int) int
		ReleasedAt  func(childComplexity int) int
		Reprint     func(childComplexity int) int
		Set         func(childComplexity int) int
		SetID       func(childComplexity int) int
		SetName     func(childComplexity int) int
		SetType     func(childComplexity int) int
		Variation   func(childComplexity int) int
		VariationOf func(childComplexity int) int
	}

	MTG_CardVersion_Dashboard struct {
		CardFaces func(childComplexity int) int
		ID        func(childComplexity int) int
		ImageUris func(childComplexity int) int
		IsAlchemy func(childComplexity int) int
		IsDefault func(childComplexity int) int
	}

	MTG_Card_Dashboard struct {
		ID       func(childComplexity int) int
		Versions func(childComplexity int) int
	}

	MTG_Deck struct {
		CardFrontImage func(childComplexity int) int
		Cards          func(childComplexity int) int
		ID             func(childComplexity int) int
		IgnoredCards   func(childComplexity int) int
		Name           func(childComplexity int) int
		Zones          func(childComplexity int) int
	}

	MTG_DeckCard struct {
		Card              func(childComplexity int) int
		Count             func(childComplexity int) int
		DeckCardType      func(childComplexity int) int
		MainOrSide        func(childComplexity int) int
		Phantoms          func(childComplexity int) int
		Position          func(childComplexity int) int
		SelectedVersionID func(childComplexity int) int
	}

	MTG_DeckCard_Dashboard struct {
		Card              func(childComplexity int) int
		SelectedVersionID func(childComplexity int) int
	}

	MTG_DeckDashboard struct {
		CardFrontImage func(childComplexity int) int
		Cards          func(childComplexity int) int
		ID             func(childComplexity int) int
		Name           func(childComplexity int) int
	}

	MTG_Deck_CardFrontImage struct {
		CardID    func(childComplexity int) int
		Image     func(childComplexity int) int
		VersionID func(childComplexity int) int
	}

	MTG_Filter_CardTypes struct {
		CardType func(childComplexity int) int
		Subtypes func(childComplexity int) int
	}

	MTG_Filter_Entries struct {
		Expansions func(childComplexity int) int
		Layouts    func(childComplexity int) int
		Legality   func(childComplexity int) int
		Types      func(childComplexity int) int
	}

	MTG_Filter_Expansion struct {
		Games      func(childComplexity int) int
		ImageURL   func(childComplexity int) int
		ReleasedAt func(childComplexity int) int
		Set        func(childComplexity int) int
		SetName    func(childComplexity int) int
		SetType    func(childComplexity int) int
	}

	MTG_Filter_Legality struct {
		Formats        func(childComplexity int) int
		LegalityValues func(childComplexity int) int
	}

	MTG_Filter_Search struct {
		PagedCards func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	MTG_Image struct {
		ArtCrop    func(childComplexity int) int
		BorderCrop func(childComplexity int) int
		Large      func(childComplexity int) int
		Normal     func(childComplexity int) int
		Png        func(childComplexity int) int
		Small      func(childComplexity int) int
	}

	Mutation struct {
		AddIgnoredCard               func(childComplexity int, input model.AddIgnoredCardInput) int
		AddMTGCardToCardPackage      func(childComplexity int, input model.MtgAddCardToCardPackageInput) int
		AdminBackfillImport          func(childComplexity int, input model.AdminImportActionInput) int
		AdminRetryImport             func(childComplexity int, input model.AdminImportActionInput) int
		AssignTag                    func(childComplexity int, input model.AssignTagInput) int
		CreateMTGCardPackage         func(childComplexity int, input model.MtgCreateCardPackageInput) int
		CreateMTGDeck                func(childComplexity int, input model.MtgCreateDeckInput) int
		CreateTag                    func(childComplexity int, input model.CreateTagInput) int
		DeleteMTGCardPackage         func(childComplexity int, input model.MtgDeleteCardPackageInput) int
		DeleteMTGDeck                func(childComplexity int, input model.MtgDeleteDeckInput) int
		DeleteTag                    func(childComplexity int, tagID string) int
		EditMTGCardPackageName       func(childComplexity int, input model.MtgEditCardPackageNameInput) int
		EditMTGCardPackageVisibility func(childComplexity int, input model.MtgEditCardPackageVisibilityInput) int
		Rate                         func(childComplexity int, input model.RateInput) int
		RemoveIgnoredCard            func(childComplexity int, input model.RemoveIgnoredCardInput) int
		RemoveMTGCardFromCardPackage func(childComplexity int, input model.MtgRemoveCardFromCardPackageInput) int
		SaveMTGDeckAsCopy            func(childComplexity int, input model.MtgUpdateDeckInput) int
		UnassignTag                  func(childComplexity int, input model.UnassignTagInput) int
		UpdateMTGDeck                func(childComplexity int, input model.MtgUpdateDeckInput) int
		UpdateTag                    func(childComplexity int, input model.UpdateTagInput) int
	}

	Phantom struct {
		ID       func(childComplexity int) int
		Position func(childComplexity int) int
	}

	Position struct {
		X func(childComplexity int) int
		Y func(childComplexity int) int
	}

	Query struct {
		AdminDashboard      func(childComplexity int) int
		AdminImportReports  func(childComplexity int, job model.AdminJob, limit *int) int
		AdminLegalitiesDiff func(childComplexity int, importID string) int
		CardTags            func(childComplexity int) int
		DeckTags            func(childComplexity int) int
		GetMTGCardPackages  func(childComplexity int, cardPackageID *string, includePublic *bool) int
		GetMTGCards         func(childComplexity int) int
		GetMTGCardsFiltered func(childComplexity int, filter model.MtgFilterSearchInput, pagination model.MtgFilterPaginationInput, sort []*model.MtgFilterSortInput) int
		GetMTGDeck          func(childComplexity int, deckID string) int
		GetMTGDecks         func(childComplexity int) int
		GetMTGFilters       func(childComplexity int) int
		Tag                 func(childComplexity int, id string) int
		Tags                func(childComplexity int) int
	}

	Response struct {
		Message func(childComplexity int) int
		Status  func(childComplexity int) int
	}

	User struct {
		ID    func(childComplexity int) int
		Roles func(childComplexity int) int
	}

	UserRating struct {
		User  func(childComplexity int) int
		Value func(childComplexity int) int
	}
}

type MutationResolver interface {
	CreateMTGDeck(ctx context.Context, input model.MtgCreateDeckInput) (*model.Response, error)
	DeleteMTGDeck(ctx context.Context, input model.MtgDeleteDeckInput) (*model.Response, error)
	UpdateMTGDeck(ctx context.Context, input model.MtgUpdateDeckInput) (*model.Response, error)
	SaveMTGDeckAsCopy(ctx context.Context, input model.MtgUpdateDeckInput) (*model.Response, error)
	CreateMTGCardPackage(ctx context.Context, input model.MtgCreateCardPackageInput) (*model.Response, error)
	DeleteMTGCardPackage(ctx context.Context, input model.MtgDeleteCardPackageInput) (*model.Response, error)
	EditMTGCardPackageName(ctx context.Context, input model.MtgEditCardPackageNameInput) (*model.Response, error)
	EditMTGCardPackageVisibility(ctx context.Context, input model.MtgEditCardPackageVisibilityInput) (*model.Response, error)
	AddMTGCardToCardPackage(ctx context.Context, input model.MtgAddCardToCardPackageInput) (*model.Response, error)
	RemoveMTGCardFromCardPackage(ctx context.Context, input model.MtgRemoveCardFromCardPackageInput) (*model.Response, error)
	CreateTag(ctx context.Context, input model.CreateTagInput) (*model.Response, error)
	UpdateTag(ctx context.Context, input model.UpdateTagInput) (*model.Response, error)
	DeleteTag(ctx context.Context, tagID string) (*model.Response, error)
	AssignTag(ctx context.Context, input model.AssignTagInput) (*model.Response, error)
	UnassignTag(ctx context.Context, input model.UnassignTagInput) (*model.Response, error)
	Rate(ctx context.Context, input model.RateInput) (*model.Response, error)
	AddIgnoredCard(ctx context.Context, input model.AddIgnoredCardInput) (*model.Response, error)
	RemoveIgnoredCard(ctx context.Context, input model.RemoveIgnoredCardInput) (*model.Response, error)
	AdminRetryImport(ctx context.Context, input model.AdminImportActionInput) (*model.Response, error)
	AdminBackfillImport(ctx context.Context, input model.AdminImportActionInput) (*model.Response, error)
}
type QueryResolver interface {
	GetMTGCards(ctx context.Context) ([]*model.MtgCard, error)
	GetMTGCardsFiltered(ctx context.Context, filter model.MtgFilterSearchInput, pagination model.MtgFilterPaginationInput, sort []*model.MtgFilterSortInput) (*model.MtgFilterSearch, error)
	GetMTGFilters(ctx context.Context) (*model.MtgFilterEntries, error)
	GetMTGDecks(ctx context.Context) ([]*model.MtgDeckDashboard, error)
	GetMTGDeck(ctx context.Context, deckID string) (*model.MtgDeck, error)
	GetMTGCardPackages(ctx context.Context, cardPackageID *string, includePublic *bool) ([]*model.MtgCardPackage, error)
	Tags(ctx context.Context) ([]model.Tag, error)
	CardTags(ctx context.Context) ([]*model.CardTag, error)
	DeckTags(ctx context.Context) ([]*model.DeckTag, error)
	Tag(ctx context.Context, id string) (model.Tag, error)
	AdminDashboard(ctx context.Context) (*model.AdminDashboard, error)
	AdminLegalitiesDiff(ctx context.Context, importID string) (*model.AdminLegalitiesDiff, error)
	AdminImportReports(ctx context.Context, job model.AdminJob, limit *int) ([]*model.AdminImportReport, error)
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]any) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "AdminDashboard.imports":
		if e.complexity.AdminDashboard.Imports == nil {
			break
		}

		return e.complexity.AdminDashboard.Imports(childComplexity), true

	case "AdminDashboard.latestLegalitiesDiff":
		if e.complexity.AdminDashboard.LatestLegalitiesDiff == nil {
			break
		}

		return e.complexity.AdminDashboard.LatestLegalitiesDiff(childComplexity), true

	case "AdminImportReport.completedAt":
		if e.complexity.AdminImportReport.CompletedAt == nil {
			break
		}

		return e.complexity.AdminImportReport.CompletedAt(childComplexity), true

	case "AdminImportReport.durationMs":
		if e.complexity.AdminImportReport.DurationMs == nil {
			break
		}

		return e.complexity.AdminImportReport.DurationMs(childComplexity), true

	case "AdminImportReport.errorMessage":
		if e.complexity.AdminImportReport.ErrorMessage == nil {
			break
		}

		return e.complexity.AdminImportReport.ErrorMessage(childComplexity), true

	case "AdminImportReport.id":
		if e.complexity.AdminImportReport.ID == nil {
			break
		}

		return e.complexity.AdminImportReport.ID(childComplexity), true

	case "AdminImportReport.jobName":
		if e.complexity.AdminImportReport.JobName == nil {
			break
		}

		return e.complexity.AdminImportReport.JobName(childComplexity), true

	case "AdminImportReport.metadata":
		if e.complexity.AdminImportReport.Metadata == nil {
			break
		}

		return e.complexity.AdminImportReport.Metadata(childComplexity), true

	case "AdminImportReport.recordsProcessed":
		if e.complexity.AdminImportReport.RecordsProcessed == nil {
			break
		}

		return e.complexity.AdminImportReport.RecordsProcessed(childComplexity), true

	case "AdminImportReport.startedAt":
		if e.complexity.AdminImportReport.StartedAt == nil {
			break
		}

		return e.complexity.AdminImportReport.StartedAt(childComplexity), true

	case "AdminImportReport.status":
		if e.complexity.AdminImportReport.Status == nil {
			break
		}

		return e.complexity.AdminImportReport.Status(childComplexity), true

	case "AdminImportSummary.jobName":
		if e.complexity.AdminImportSummary.JobName == nil {
			break
		}

		return e.complexity.AdminImportSummary.JobName(childComplexity), true

	case "AdminImportSummary.lastRun":
		if e.complexity.AdminImportSummary.LastRun == nil {
			break
		}

		return e.complexity.AdminImportSummary.LastRun(childComplexity), true

	case "AdminImportSummary.latency":
		if e.complexity.AdminImportSummary.Latency == nil {
			break
		}

		return e.complexity.AdminImportSummary.Latency(childComplexity), true

	case "AdminImportSummary.previousRun":
		if e.complexity.AdminImportSummary.PreviousRun == nil {
			break
		}

		return e.complexity.AdminImportSummary.PreviousRun(childComplexity), true

	case "AdminLatencyMetrics.avgDurationMs":
		if e.complexity.AdminLatencyMetrics.AvgDurationMs == nil {
			break
		}

		return e.complexity.AdminLatencyMetrics.AvgDurationMs(childComplexity), true

	case "AdminLatencyMetrics.lastDurationMs":
		if e.complexity.AdminLatencyMetrics.LastDurationMs == nil {
			break
		}

		return e.complexity.AdminLatencyMetrics.LastDurationMs(childComplexity), true

	case "AdminLatencyMetrics.lastStartedAt":
		if e.complexity.AdminLatencyMetrics.LastStartedAt == nil {
			break
		}

		return e.complexity.AdminLatencyMetrics.LastStartedAt(childComplexity), true

	case "AdminLatencyMetrics.p50DurationMs":
		if e.complexity.AdminLatencyMetrics.P50DurationMs == nil {
			break
		}

		return e.complexity.AdminLatencyMetrics.P50DurationMs(childComplexity), true

	case "AdminLatencyMetrics.p90DurationMs":
		if e.complexity.AdminLatencyMetrics.P90DurationMs == nil {
			break
		}

		return e.complexity.AdminLatencyMetrics.P90DurationMs(childComplexity), true

	case "AdminLatencyMetrics.totalRuns":
		if e.complexity.AdminLatencyMetrics.TotalRuns == nil {
			break
		}

		return e.complexity.AdminLatencyMetrics.TotalRuns(childComplexity), true

	case "AdminLegalitiesDiff.entries":
		if e.complexity.AdminLegalitiesDiff.Entries == nil {
			break
		}

		return e.complexity.AdminLegalitiesDiff.Entries(childComplexity), true

	case "AdminLegalitiesDiff.importId":
		if e.complexity.AdminLegalitiesDiff.ImportID == nil {
			break
		}

		return e.complexity.AdminLegalitiesDiff.ImportID(childComplexity), true

	case "AdminLegalitiesDiff.jobName":
		if e.complexity.AdminLegalitiesDiff.JobName == nil {
			break
		}

		return e.complexity.AdminLegalitiesDiff.JobName(childComplexity), true

	case "AdminLegalitiesDiffEntry.cardID":
		if e.complexity.AdminLegalitiesDiffEntry.CardID == nil {
			break
		}

		return e.complexity.AdminLegalitiesDiffEntry.CardID(childComplexity), true

	case "AdminLegalitiesDiffEntry.cardName":
		if e.complexity.AdminLegalitiesDiffEntry.CardName == nil {
			break
		}

		return e.complexity.AdminLegalitiesDiffEntry.CardName(childComplexity), true

	case "AdminLegalitiesDiffEntry.changedAt":
		if e.complexity.AdminLegalitiesDiffEntry.ChangedAt == nil {
			break
		}

		return e.complexity.AdminLegalitiesDiffEntry.ChangedAt(childComplexity), true

	case "AdminLegalitiesDiffEntry.currentStatus":
		if e.complexity.AdminLegalitiesDiffEntry.CurrentStatus == nil {
			break
		}

		return e.complexity.AdminLegalitiesDiffEntry.CurrentStatus(childComplexity), true

	case "AdminLegalitiesDiffEntry.format":
		if e.complexity.AdminLegalitiesDiffEntry.Format == nil {
			break
		}

		return e.complexity.AdminLegalitiesDiffEntry.Format(childComplexity), true

	case "AdminLegalitiesDiffEntry.previousStatus":
		if e.complexity.AdminLegalitiesDiffEntry.PreviousStatus == nil {
			break
		}

		return e.complexity.AdminLegalitiesDiffEntry.PreviousStatus(childComplexity), true

	case "AdminLegalitiesDiffEntry.setCode":
		if e.complexity.AdminLegalitiesDiffEntry.SetCode == nil {
			break
		}

		return e.complexity.AdminLegalitiesDiffEntry.SetCode(childComplexity), true

	case "AdminLegalitiesDiffEntry.setName":
		if e.complexity.AdminLegalitiesDiffEntry.SetName == nil {
			break
		}

		return e.complexity.AdminLegalitiesDiffEntry.SetName(childComplexity), true

	case "CardTag.description":
		if e.complexity.CardTag.Description == nil {
			break
		}

		return e.complexity.CardTag.Description(childComplexity), true

	case "CardTag.ID":
		if e.complexity.CardTag.ID == nil {
			break
		}

		return e.complexity.CardTag.ID(childComplexity), true

	case "CardTag.myRating":
		if e.complexity.CardTag.MyRating == nil {
			break
		}

		return e.complexity.CardTag.MyRating(childComplexity), true

	case "CardTag.name":
		if e.complexity.CardTag.Name == nil {
			break
		}

		return e.complexity.CardTag.Name(childComplexity), true

	case "DeckTag.colors":
		if e.complexity.DeckTag.Colors == nil {
			break
		}

		return e.complexity.DeckTag.Colors(childComplexity), true

	case "DeckTag.description":
		if e.complexity.DeckTag.Description == nil {
			break
		}

		return e.complexity.DeckTag.Description(childComplexity), true

	case "DeckTag.ID":
		if e.complexity.DeckTag.ID == nil {
			break
		}

		return e.complexity.DeckTag.ID(childComplexity), true

	case "DeckTag.myRating":
		if e.complexity.DeckTag.MyRating == nil {
			break
		}

		return e.complexity.DeckTag.MyRating(childComplexity), true

	case "DeckTag.name":
		if e.complexity.DeckTag.Name == nil {
			break
		}

		return e.complexity.DeckTag.Name(childComplexity), true

	case "FlowZone.cardChildren":
		if e.complexity.FlowZone.CardChildren == nil {
			break
		}

		return e.complexity.FlowZone.CardChildren(childComplexity), true

	case "FlowZone.height":
		if e.complexity.FlowZone.Height == nil {
			break
		}

		return e.complexity.FlowZone.Height(childComplexity), true

	case "FlowZone.ID":
		if e.complexity.FlowZone.ID == nil {
			break
		}

		return e.complexity.FlowZone.ID(childComplexity), true

	case "FlowZone.name":
		if e.complexity.FlowZone.Name == nil {
			break
		}

		return e.complexity.FlowZone.Name(childComplexity), true

	case "FlowZone.position":
		if e.complexity.FlowZone.Position == nil {
			break
		}

		return e.complexity.FlowZone.Position(childComplexity), true

	case "FlowZone.width":
		if e.complexity.FlowZone.Width == nil {
			break
		}

		return e.complexity.FlowZone.Width(childComplexity), true

	case "FlowZone.zoneChildren":
		if e.complexity.FlowZone.ZoneChildren == nil {
			break
		}

		return e.complexity.FlowZone.ZoneChildren(childComplexity), true

	case "MTG_Card.cardTags":
		if e.complexity.MTG_Card.CardTags == nil {
			break
		}

		return e.complexity.MTG_Card.CardTags(childComplexity), true

	case "MTG_Card.CMC":
		if e.complexity.MTG_Card.Cmc == nil {
			break
		}

		return e.complexity.MTG_Card.Cmc(childComplexity), true

	case "MTG_Card.colorIdentity":
		if e.complexity.MTG_Card.ColorIdentity == nil {
			break
		}

		return e.complexity.MTG_Card.ColorIdentity(childComplexity), true

	case "MTG_Card.colorIndicator":
		if e.complexity.MTG_Card.ColorIndicator == nil {
			break
		}

		return e.complexity.MTG_Card.ColorIndicator(childComplexity), true

	case "MTG_Card.colors":
		if e.complexity.MTG_Card.Colors == nil {
			break
		}

		return e.complexity.MTG_Card.Colors(childComplexity), true

	case "MTG_Card.deckTags":
		if e.complexity.MTG_Card.DeckTags == nil {
			break
		}

		return e.complexity.MTG_Card.DeckTags(childComplexity), true

	case "MTG_Card.EDHRecRank":
		if e.complexity.MTG_Card.EDHRecRank == nil {
			break
		}

		return e.complexity.MTG_Card.EDHRecRank(childComplexity), true

	case "MTG_Card.ID":
		if e.complexity.MTG_Card.ID == nil {
			break
		}

		return e.complexity.MTG_Card.ID(childComplexity), true

	case "MTG_Card.keywords":
		if e.complexity.MTG_Card.Keywords == nil {
			break
		}

		return e.complexity.MTG_Card.Keywords(childComplexity), true

	case "MTG_Card.layout":
		if e.complexity.MTG_Card.Layout == nil {
			break
		}

		return e.complexity.MTG_Card.Layout(childComplexity), true

	case "MTG_Card.loyalty":
		if e.complexity.MTG_Card.Loyalty == nil {
			break
		}

		return e.complexity.MTG_Card.Loyalty(childComplexity), true

	case "MTG_Card.manaCost":
		if e.complexity.MTG_Card.ManaCost == nil {
			break
		}

		return e.complexity.MTG_Card.ManaCost(childComplexity), true

	case "MTG_Card.myRating":
		if e.complexity.MTG_Card.MyRating == nil {
			break
		}

		return e.complexity.MTG_Card.MyRating(childComplexity), true

	case "MTG_Card.name":
		if e.complexity.MTG_Card.Name == nil {
			break
		}

		return e.complexity.MTG_Card.Name(childComplexity), true

	case "MTG_Card.oracleText":
		if e.complexity.MTG_Card.OracleText == nil {
			break
		}

		return e.complexity.MTG_Card.OracleText(childComplexity), true

	case "MTG_Card.power":
		if e.complexity.MTG_Card.Power == nil {
			break
		}

		return e.complexity.MTG_Card.Power(childComplexity), true

	case "MTG_Card.producedMana":
		if e.complexity.MTG_Card.ProducedMana == nil {
			break
		}

		return e.complexity.MTG_Card.ProducedMana(childComplexity), true

	case "MTG_Card.toughness":
		if e.complexity.MTG_Card.Toughness == nil {
			break
		}

		return e.complexity.MTG_Card.Toughness(childComplexity), true

	case "MTG_Card.typeLine":
		if e.complexity.MTG_Card.TypeLine == nil {
			break
		}

		return e.complexity.MTG_Card.TypeLine(childComplexity), true

	case "MTG_Card.versions":
		if e.complexity.MTG_Card.Versions == nil {
			break
		}

		return e.complexity.MTG_Card.Versions(childComplexity), true

	case "MTG_CardFace.artist":
		if e.complexity.MTG_CardFace.Artist == nil {
			break
		}

		return e.complexity.MTG_CardFace.Artist(childComplexity), true

	case "MTG_CardFace.CMC":
		if e.complexity.MTG_CardFace.Cmc == nil {
			break
		}

		return e.complexity.MTG_CardFace.Cmc(childComplexity), true

	case "MTG_CardFace.colorIndicator":
		if e.complexity.MTG_CardFace.ColorIndicator == nil {
			break
		}

		return e.complexity.MTG_CardFace.ColorIndicator(childComplexity), true

	case "MTG_CardFace.colors":
		if e.complexity.MTG_CardFace.Colors == nil {
			break
		}

		return e.complexity.MTG_CardFace.Colors(childComplexity), true

	case "MTG_CardFace.flavorText":
		if e.complexity.MTG_CardFace.FlavorText == nil {
			break
		}

		return e.complexity.MTG_CardFace.FlavorText(childComplexity), true

	case "MTG_CardFace.imageUris":
		if e.complexity.MTG_CardFace.ImageUris == nil {
			break
		}

		return e.complexity.MTG_CardFace.ImageUris(childComplexity), true

	case "MTG_CardFace.layout":
		if e.complexity.MTG_CardFace.Layout == nil {
			break
		}

		return e.complexity.MTG_CardFace.Layout(childComplexity), true

	case "MTG_CardFace.loyalty":
		if e.complexity.MTG_CardFace.Loyalty == nil {
			break
		}

		return e.complexity.MTG_CardFace.Loyalty(childComplexity), true

	case "MTG_CardFace.manaCost":
		if e.complexity.MTG_CardFace.ManaCost == nil {
			break
		}

		return e.complexity.MTG_CardFace.ManaCost(childComplexity), true

	case "MTG_CardFace.name":
		if e.complexity.MTG_CardFace.Name == nil {
			break
		}

		return e.complexity.MTG_CardFace.Name(childComplexity), true

	case "MTG_CardFace.oracleText":
		if e.complexity.MTG_CardFace.OracleText == nil {
			break
		}

		return e.complexity.MTG_CardFace.OracleText(childComplexity), true

	case "MTG_CardFace.power":
		if e.complexity.MTG_CardFace.Power == nil {
			break
		}

		return e.complexity.MTG_CardFace.Power(childComplexity), true

	case "MTG_CardFace.toughness":
		if e.complexity.MTG_CardFace.Toughness == nil {
			break
		}

		return e.complexity.MTG_CardFace.Toughness(childComplexity), true

	case "MTG_CardFace.typeLine":
		if e.complexity.MTG_CardFace.TypeLine == nil {
			break
		}

		return e.complexity.MTG_CardFace.TypeLine(childComplexity), true

	case "MTG_CardFace_Dashboard.imageUris":
		if e.complexity.MTG_CardFace_Dashboard.ImageUris == nil {
			break
		}

		return e.complexity.MTG_CardFace_Dashboard.ImageUris(childComplexity), true

	case "MTG_CardPackage.cards":
		if e.complexity.MTG_CardPackage.Cards == nil {
			break
		}

		return e.complexity.MTG_CardPackage.Cards(childComplexity), true

	case "MTG_CardPackage.ID":
		if e.complexity.MTG_CardPackage.ID == nil {
			break
		}

		return e.complexity.MTG_CardPackage.ID(childComplexity), true

	case "MTG_CardPackage.isPublic":
		if e.complexity.MTG_CardPackage.IsPublic == nil {
			break
		}

		return e.complexity.MTG_CardPackage.IsPublic(childComplexity), true

	case "MTG_CardPackage.name":
		if e.complexity.MTG_CardPackage.Name == nil {
			break
		}

		return e.complexity.MTG_CardPackage.Name(childComplexity), true

	case "MTG_CardPackage.ownerID":
		if e.complexity.MTG_CardPackage.OwnerID == nil {
			break
		}

		return e.complexity.MTG_CardPackage.OwnerID(childComplexity), true

	case "MTG_CardPackage.zones":
		if e.complexity.MTG_CardPackage.Zones == nil {
			break
		}

		return e.complexity.MTG_CardPackage.Zones(childComplexity), true

	case "MTG_CardPackageCard.card":
		if e.complexity.MTG_CardPackageCard.Card == nil {
			break
		}

		return e.complexity.MTG_CardPackageCard.Card(childComplexity), true

	case "MTG_CardPackageCard.count":
		if e.complexity.MTG_CardPackageCard.Count == nil {
			break
		}

		return e.complexity.MTG_CardPackageCard.Count(childComplexity), true

	case "MTG_CardPackageCard.mainOrSide":
		if e.complexity.MTG_CardPackageCard.MainOrSide == nil {
			break
		}

		return e.complexity.MTG_CardPackageCard.MainOrSide(childComplexity), true

	case "MTG_CardPackageCard.phantoms":
		if e.complexity.MTG_CardPackageCard.Phantoms == nil {
			break
		}

		return e.complexity.MTG_CardPackageCard.Phantoms(childComplexity), true

	case "MTG_CardPackageCard.position":
		if e.complexity.MTG_CardPackageCard.Position == nil {
			break
		}

		return e.complexity.MTG_CardPackageCard.Position(childComplexity), true

	case "MTG_CardPackageCard.selectedVersionID":
		if e.complexity.MTG_CardPackageCard.SelectedVersionID == nil {
			break
		}

		return e.complexity.MTG_CardPackageCard.SelectedVersionID(childComplexity), true

	case "MTG_CardVersion.artist":
		if e.complexity.MTG_CardVersion.Artist == nil {
			break
		}

		return e.complexity.MTG_CardVersion.Artist(childComplexity), true

	case "MTG_CardVersion.cardFaces":
		if e.complexity.MTG_CardVersion.CardFaces == nil {
			break
		}

		return e.complexity.MTG_CardVersion.CardFaces(childComplexity), true

	case "MTG_CardVersion.flavorName":
		if e.complexity.MTG_CardVersion.FlavorName == nil {
			break
		}

		return e.complexity.MTG_CardVersion.FlavorName(childComplexity), true

	case "MTG_CardVersion.flavorText":
		if e.complexity.MTG_CardVersion.FlavorText == nil {
			break
		}

		return e.complexity.MTG_CardVersion.FlavorText(childComplexity), true

	case "MTG_CardVersion.games":
		if e.complexity.MTG_CardVersion.Games == nil {
			break
		}

		return e.complexity.MTG_CardVersion.Games(childComplexity), true

	case "MTG_CardVersion.ID":
		if e.complexity.MTG_CardVersion.ID == nil {
			break
		}

		return e.complexity.MTG_CardVersion.ID(childComplexity), true

	case "MTG_CardVersion.imageUris":
		if e.complexity.MTG_CardVersion.ImageUris == nil {
			break
		}

		return e.complexity.MTG_CardVersion.ImageUris(childComplexity), true

	case "MTG_CardVersion.isAlchemy":
		if e.complexity.MTG_CardVersion.IsAlchemy == nil {
			break
		}

		return e.complexity.MTG_CardVersion.IsAlchemy(childComplexity), true

	case "MTG_CardVersion.isDefault":
		if e.complexity.MTG_CardVersion.IsDefault == nil {
			break
		}

		return e.complexity.MTG_CardVersion.IsDefault(childComplexity), true

	case "MTG_CardVersion.lang":
		if e.complexity.MTG_CardVersion.Lang == nil {
			break
		}

		return e.complexity.MTG_CardVersion.Lang(childComplexity), true

	case "MTG_CardVersion.legalities":
		if e.complexity.MTG_CardVersion.Legalities == nil {
			break
		}

		return e.complexity.MTG_CardVersion.Legalities(childComplexity), true

	case "MTG_CardVersion.printedName":
		if e.complexity.MTG_CardVersion.PrintedName == nil {
			break
		}

		return e.complexity.MTG_CardVersion.PrintedName(childComplexity), true

	case "MTG_CardVersion.rarity":
		if e.complexity.MTG_CardVersion.Rarity == nil {
			break
		}

		return e.complexity.MTG_CardVersion.Rarity(childComplexity), true

	case "MTG_CardVersion.releasedAt":
		if e.complexity.MTG_CardVersion.ReleasedAt == nil {
			break
		}

		return e.complexity.MTG_CardVersion.ReleasedAt(childComplexity), true

	case "MTG_CardVersion.reprint":
		if e.complexity.MTG_CardVersion.Reprint == nil {
			break
		}

		return e.complexity.MTG_CardVersion.Reprint(childComplexity), true

	case "MTG_CardVersion.set":
		if e.complexity.MTG_CardVersion.Set == nil {
			break
		}

		return e.complexity.MTG_CardVersion.Set(childComplexity), true

	case "MTG_CardVersion.setID":
		if e.complexity.MTG_CardVersion.SetID == nil {
			break
		}

		return e.complexity.MTG_CardVersion.SetID(childComplexity), true

	case "MTG_CardVersion.setName":
		if e.complexity.MTG_CardVersion.SetName == nil {
			break
		}

		return e.complexity.MTG_CardVersion.SetName(childComplexity), true

	case "MTG_CardVersion.setType":
		if e.complexity.MTG_CardVersion.SetType == nil {
			break
		}

		return e.complexity.MTG_CardVersion.SetType(childComplexity), true

	case "MTG_CardVersion.variation":
		if e.complexity.MTG_CardVersion.Variation == nil {
			break
		}

		return e.complexity.MTG_CardVersion.Variation(childComplexity), true

	case "MTG_CardVersion.variationOf":
		if e.complexity.MTG_CardVersion.VariationOf == nil {
			break
		}

		return e.complexity.MTG_CardVersion.VariationOf(childComplexity), true

	case "MTG_CardVersion_Dashboard.cardFaces":
		if e.complexity.MTG_CardVersion_Dashboard.CardFaces == nil {
			break
		}

		return e.complexity.MTG_CardVersion_Dashboard.CardFaces(childComplexity), true

	case "MTG_CardVersion_Dashboard.ID":
		if e.complexity.MTG_CardVersion_Dashboard.ID == nil {
			break
		}

		return e.complexity.MTG_CardVersion_Dashboard.ID(childComplexity), true

	case "MTG_CardVersion_Dashboard.imageUris":
		if e.complexity.MTG_CardVersion_Dashboard.ImageUris == nil {
			break
		}

		return e.complexity.MTG_CardVersion_Dashboard.ImageUris(childComplexity), true

	case "MTG_CardVersion_Dashboard.isAlchemy":
		if e.complexity.MTG_CardVersion_Dashboard.IsAlchemy == nil {
			break
		}

		return e.complexity.MTG_CardVersion_Dashboard.IsAlchemy(childComplexity), true

	case "MTG_CardVersion_Dashboard.isDefault":
		if e.complexity.MTG_CardVersion_Dashboard.IsDefault == nil {
			break
		}

		return e.complexity.MTG_CardVersion_Dashboard.IsDefault(childComplexity), true

	case "MTG_Card_Dashboard.ID":
		if e.complexity.MTG_Card_Dashboard.ID == nil {
			break
		}

		return e.complexity.MTG_Card_Dashboard.ID(childComplexity), true

	case "MTG_Card_Dashboard.versions":
		if e.complexity.MTG_Card_Dashboard.Versions == nil {
			break
		}

		return e.complexity.MTG_Card_Dashboard.Versions(childComplexity), true

	case "MTG_Deck.cardFrontImage":
		if e.complexity.MTG_Deck.CardFrontImage == nil {
			break
		}

		return e.complexity.MTG_Deck.CardFrontImage(childComplexity), true

	case "MTG_Deck.cards":
		if e.complexity.MTG_Deck.Cards == nil {
			break
		}

		return e.complexity.MTG_Deck.Cards(childComplexity), true

	case "MTG_Deck.ID":
		if e.complexity.MTG_Deck.ID == nil {
			break
		}

		return e.complexity.MTG_Deck.ID(childComplexity), true

	case "MTG_Deck.ignoredCards":
		if e.complexity.MTG_Deck.IgnoredCards == nil {
			break
		}

		return e.complexity.MTG_Deck.IgnoredCards(childComplexity), true

	case "MTG_Deck.name":
		if e.complexity.MTG_Deck.Name == nil {
			break
		}

		return e.complexity.MTG_Deck.Name(childComplexity), true

	case "MTG_Deck.zones":
		if e.complexity.MTG_Deck.Zones == nil {
			break
		}

		return e.complexity.MTG_Deck.Zones(childComplexity), true

	case "MTG_DeckCard.card":
		if e.complexity.MTG_DeckCard.Card == nil {
			break
		}

		return e.complexity.MTG_DeckCard.Card(childComplexity), true

	case "MTG_DeckCard.count":
		if e.complexity.MTG_DeckCard.Count == nil {
			break
		}

		return e.complexity.MTG_DeckCard.Count(childComplexity), true

	case "MTG_DeckCard.deckCardType":
		if e.complexity.MTG_DeckCard.DeckCardType == nil {
			break
		}

		return e.complexity.MTG_DeckCard.DeckCardType(childComplexity), true

	case "MTG_DeckCard.mainOrSide":
		if e.complexity.MTG_DeckCard.MainOrSide == nil {
			break
		}

		return e.complexity.MTG_DeckCard.MainOrSide(childComplexity), true

	case "MTG_DeckCard.phantoms":
		if e.complexity.MTG_DeckCard.Phantoms == nil {
			break
		}

		return e.complexity.MTG_DeckCard.Phantoms(childComplexity), true

	case "MTG_DeckCard.position":
		if e.complexity.MTG_DeckCard.Position == nil {
			break
		}

		return e.complexity.MTG_DeckCard.Position(childComplexity), true

	case "MTG_DeckCard.selectedVersionID":
		if e.complexity.MTG_DeckCard.SelectedVersionID == nil {
			break
		}

		return e.complexity.MTG_DeckCard.SelectedVersionID(childComplexity), true

	case "MTG_DeckCard_Dashboard.card":
		if e.complexity.MTG_DeckCard_Dashboard.Card == nil {
			break
		}

		return e.complexity.MTG_DeckCard_Dashboard.Card(childComplexity), true

	case "MTG_DeckCard_Dashboard.selectedVersionID":
		if e.complexity.MTG_DeckCard_Dashboard.SelectedVersionID == nil {
			break
		}

		return e.complexity.MTG_DeckCard_Dashboard.SelectedVersionID(childComplexity), true

	case "MTG_DeckDashboard.cardFrontImage":
		if e.complexity.MTG_DeckDashboard.CardFrontImage == nil {
			break
		}

		return e.complexity.MTG_DeckDashboard.CardFrontImage(childComplexity), true

	case "MTG_DeckDashboard.cards":
		if e.complexity.MTG_DeckDashboard.Cards == nil {
			break
		}

		return e.complexity.MTG_DeckDashboard.Cards(childComplexity), true

	case "MTG_DeckDashboard.ID":
		if e.complexity.MTG_DeckDashboard.ID == nil {
			break
		}

		return e.complexity.MTG_DeckDashboard.ID(childComplexity), true

	case "MTG_DeckDashboard.name":
		if e.complexity.MTG_DeckDashboard.Name == nil {
			break
		}

		return e.complexity.MTG_DeckDashboard.Name(childComplexity), true

	case "MTG_Deck_CardFrontImage.cardID":
		if e.complexity.MTG_Deck_CardFrontImage.CardID == nil {
			break
		}

		return e.complexity.MTG_Deck_CardFrontImage.CardID(childComplexity), true

	case "MTG_Deck_CardFrontImage.image":
		if e.complexity.MTG_Deck_CardFrontImage.Image == nil {
			break
		}

		return e.complexity.MTG_Deck_CardFrontImage.Image(childComplexity), true

	case "MTG_Deck_CardFrontImage.versionID":
		if e.complexity.MTG_Deck_CardFrontImage.VersionID == nil {
			break
		}

		return e.complexity.MTG_Deck_CardFrontImage.VersionID(childComplexity), true

	case "MTG_Filter_CardTypes.cardType":
		if e.complexity.MTG_Filter_CardTypes.CardType == nil {
			break
		}

		return e.complexity.MTG_Filter_CardTypes.CardType(childComplexity), true

	case "MTG_Filter_CardTypes.subtypes":
		if e.complexity.MTG_Filter_CardTypes.Subtypes == nil {
			break
		}

		return e.complexity.MTG_Filter_CardTypes.Subtypes(childComplexity), true

	case "MTG_Filter_Entries.expansions":
		if e.complexity.MTG_Filter_Entries.Expansions == nil {
			break
		}

		return e.complexity.MTG_Filter_Entries.Expansions(childComplexity), true

	case "MTG_Filter_Entries.layouts":
		if e.complexity.MTG_Filter_Entries.Layouts == nil {
			break
		}

		return e.complexity.MTG_Filter_Entries.Layouts(childComplexity), true

	case "MTG_Filter_Entries.legality":
		if e.complexity.MTG_Filter_Entries.Legality == nil {
			break
		}

		return e.complexity.MTG_Filter_Entries.Legality(childComplexity), true

	case "MTG_Filter_Entries.types":
		if e.complexity.MTG_Filter_Entries.Types == nil {
			break
		}

		return e.complexity.MTG_Filter_Entries.Types(childComplexity), true

	case "MTG_Filter_Expansion.games":
		if e.complexity.MTG_Filter_Expansion.Games == nil {
			break
		}

		return e.complexity.MTG_Filter_Expansion.Games(childComplexity), true

	case "MTG_Filter_Expansion.imageURL":
		if e.complexity.MTG_Filter_Expansion.ImageURL == nil {
			break
		}

		return e.complexity.MTG_Filter_Expansion.ImageURL(childComplexity), true

	case "MTG_Filter_Expansion.releasedAt":
		if e.complexity.MTG_Filter_Expansion.ReleasedAt == nil {
			break
		}

		return e.complexity.MTG_Filter_Expansion.ReleasedAt(childComplexity), true

	case "MTG_Filter_Expansion.set":
		if e.complexity.MTG_Filter_Expansion.Set == nil {
			break
		}

		return e.complexity.MTG_Filter_Expansion.Set(childComplexity), true

	case "MTG_Filter_Expansion.setName":
		if e.complexity.MTG_Filter_Expansion.SetName == nil {
			break
		}

		return e.complexity.MTG_Filter_Expansion.SetName(childComplexity), true

	case "MTG_Filter_Expansion.setType":
		if e.complexity.MTG_Filter_Expansion.SetType == nil {
			break
		}

		return e.complexity.MTG_Filter_Expansion.SetType(childComplexity), true

	case "MTG_Filter_Legality.formats":
		if e.complexity.MTG_Filter_Legality.Formats == nil {
			break
		}

		return e.complexity.MTG_Filter_Legality.Formats(childComplexity), true

	case "MTG_Filter_Legality.legalityValues":
		if e.complexity.MTG_Filter_Legality.LegalityValues == nil {
			break
		}

		return e.complexity.MTG_Filter_Legality.LegalityValues(childComplexity), true

	case "MTG_Filter_Search.pagedCards":
		if e.complexity.MTG_Filter_Search.PagedCards == nil {
			break
		}

		return e.complexity.MTG_Filter_Search.PagedCards(childComplexity), true

	case "MTG_Filter_Search.totalCount":
		if e.complexity.MTG_Filter_Search.TotalCount == nil {
			break
		}

		return e.complexity.MTG_Filter_Search.TotalCount(childComplexity), true

	case "MTG_Image.artCrop":
		if e.complexity.MTG_Image.ArtCrop == nil {
			break
		}

		return e.complexity.MTG_Image.ArtCrop(childComplexity), true

	case "MTG_Image.borderCrop":
		if e.complexity.MTG_Image.BorderCrop == nil {
			break
		}

		return e.complexity.MTG_Image.BorderCrop(childComplexity), true

	case "MTG_Image.large":
		if e.complexity.MTG_Image.Large == nil {
			break
		}

		return e.complexity.MTG_Image.Large(childComplexity), true

	case "MTG_Image.normal":
		if e.complexity.MTG_Image.Normal == nil {
			break
		}

		return e.complexity.MTG_Image.Normal(childComplexity), true

	case "MTG_Image.PNG":
		if e.complexity.MTG_Image.Png == nil {
			break
		}

		return e.complexity.MTG_Image.Png(childComplexity), true

	case "MTG_Image.small":
		if e.complexity.MTG_Image.Small == nil {
			break
		}

		return e.complexity.MTG_Image.Small(childComplexity), true

	case "Mutation.addIgnoredCard":
		if e.complexity.Mutation.AddIgnoredCard == nil {
			break
		}

		args, err := ec.field_Mutation_addIgnoredCard_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddIgnoredCard(childComplexity, args["input"].(model.AddIgnoredCardInput)), true

	case "Mutation.addMTGCardToCardPackage":
		if e.complexity.Mutation.AddMTGCardToCardPackage == nil {
			break
		}

		args, err := ec.field_Mutation_addMTGCardToCardPackage_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddMTGCardToCardPackage(childComplexity, args["input"].(model.MtgAddCardToCardPackageInput)), true

	case "Mutation.adminBackfillImport":
		if e.complexity.Mutation.AdminBackfillImport == nil {
			break
		}

		args, err := ec.field_Mutation_adminBackfillImport_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AdminBackfillImport(childComplexity, args["input"].(model.AdminImportActionInput)), true

	case "Mutation.adminRetryImport":
		if e.complexity.Mutation.AdminRetryImport == nil {
			break
		}

		args, err := ec.field_Mutation_adminRetryImport_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AdminRetryImport(childComplexity, args["input"].(model.AdminImportActionInput)), true

	case "Mutation.assignTag":
		if e.complexity.Mutation.AssignTag == nil {
			break
		}

		args, err := ec.field_Mutation_assignTag_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AssignTag(childComplexity, args["input"].(model.AssignTagInput)), true

	case "Mutation.createMTGCardPackage":
		if e.complexity.Mutation.CreateMTGCardPackage == nil {
			break
		}

		args, err := ec.field_Mutation_createMTGCardPackage_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateMTGCardPackage(childComplexity, args["input"].(model.MtgCreateCardPackageInput)), true

	case "Mutation.createMTGDeck":
		if e.complexity.Mutation.CreateMTGDeck == nil {
			break
		}

		args, err := ec.field_Mutation_createMTGDeck_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateMTGDeck(childComplexity, args["input"].(model.MtgCreateDeckInput)), true

	case "Mutation.createTag":
		if e.complexity.Mutation.CreateTag == nil {
			break
		}

		args, err := ec.field_Mutation_createTag_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateTag(childComplexity, args["input"].(model.CreateTagInput)), true

	case "Mutation.deleteMTGCardPackage":
		if e.complexity.Mutation.DeleteMTGCardPackage == nil {
			break
		}

		args, err := ec.field_Mutation_deleteMTGCardPackage_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteMTGCardPackage(childComplexity, args["input"].(model.MtgDeleteCardPackageInput)), true

	case "Mutation.deleteMTGDeck":
		if e.complexity.Mutation.DeleteMTGDeck == nil {
			break
		}

		args, err := ec.field_Mutation_deleteMTGDeck_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteMTGDeck(childComplexity, args["input"].(model.MtgDeleteDeckInput)), true

	case "Mutation.deleteTag":
		if e.complexity.Mutation.DeleteTag == nil {
			break
		}

		args, err := ec.field_Mutation_deleteTag_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteTag(childComplexity, args["tagID"].(string)), true

	case "Mutation.editMTGCardPackageName":
		if e.complexity.Mutation.EditMTGCardPackageName == nil {
			break
		}

		args, err := ec.field_Mutation_editMTGCardPackageName_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.EditMTGCardPackageName(childComplexity, args["input"].(model.MtgEditCardPackageNameInput)), true

	case "Mutation.editMTGCardPackageVisibility":
		if e.complexity.Mutation.EditMTGCardPackageVisibility == nil {
			break
		}

		args, err := ec.field_Mutation_editMTGCardPackageVisibility_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.EditMTGCardPackageVisibility(childComplexity, args["input"].(model.MtgEditCardPackageVisibilityInput)), true

	case "Mutation.rate":
		if e.complexity.Mutation.Rate == nil {
			break
		}

		args, err := ec.field_Mutation_rate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.Rate(childComplexity, args["input"].(model.RateInput)), true

	case "Mutation.removeIgnoredCard":
		if e.complexity.Mutation.RemoveIgnoredCard == nil {
			break
		}

		args, err := ec.field_Mutation_removeIgnoredCard_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RemoveIgnoredCard(childComplexity, args["input"].(model.RemoveIgnoredCardInput)), true

	case "Mutation.removeMTGCardFromCardPackage":
		if e.complexity.Mutation.RemoveMTGCardFromCardPackage == nil {
			break
		}

		args, err := ec.field_Mutation_removeMTGCardFromCardPackage_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RemoveMTGCardFromCardPackage(childComplexity, args["input"].(model.MtgRemoveCardFromCardPackageInput)), true

	case "Mutation.saveMTGDeckAsCopy":
		if e.complexity.Mutation.SaveMTGDeckAsCopy == nil {
			break
		}

		args, err := ec.field_Mutation_saveMTGDeckAsCopy_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SaveMTGDeckAsCopy(childComplexity, args["input"].(model.MtgUpdateDeckInput)), true

	case "Mutation.unassignTag":
		if e.complexity.Mutation.UnassignTag == nil {
			break
		}

		args, err := ec.field_Mutation_unassignTag_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UnassignTag(childComplexity, args["input"].(model.UnassignTagInput)), true

	case "Mutation.updateMTGDeck":
		if e.complexity.Mutation.UpdateMTGDeck == nil {
			break
		}

		args, err := ec.field_Mutation_updateMTGDeck_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateMTGDeck(childComplexity, args["input"].(model.MtgUpdateDeckInput)), true

	case "Mutation.updateTag":
		if e.complexity.Mutation.UpdateTag == nil {
			break
		}

		args, err := ec.field_Mutation_updateTag_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateTag(childComplexity, args["input"].(model.UpdateTagInput)), true

	case "Phantom.ID":
		if e.complexity.Phantom.ID == nil {
			break
		}

		return e.complexity.Phantom.ID(childComplexity), true

	case "Phantom.position":
		if e.complexity.Phantom.Position == nil {
			break
		}

		return e.complexity.Phantom.Position(childComplexity), true

	case "Position.x":
		if e.complexity.Position.X == nil {
			break
		}

		return e.complexity.Position.X(childComplexity), true

	case "Position.y":
		if e.complexity.Position.Y == nil {
			break
		}

		return e.complexity.Position.Y(childComplexity), true

	case "Query.adminDashboard":
		if e.complexity.Query.AdminDashboard == nil {
			break
		}

		return e.complexity.Query.AdminDashboard(childComplexity), true

	case "Query.adminImportReports":
		if e.complexity.Query.AdminImportReports == nil {
			break
		}

		args, err := ec.field_Query_adminImportReports_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AdminImportReports(childComplexity, args["job"].(model.AdminJob), args["limit"].(*int)), true

	case "Query.adminLegalitiesDiff":
		if e.complexity.Query.AdminLegalitiesDiff == nil {
			break
		}

		args, err := ec.field_Query_adminLegalitiesDiff_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AdminLegalitiesDiff(childComplexity, args["importId"].(string)), true

	case "Query.cardTags":
		if e.complexity.Query.CardTags == nil {
			break
		}

		return e.complexity.Query.CardTags(childComplexity), true

	case "Query.deckTags":
		if e.complexity.Query.DeckTags == nil {
			break
		}

		return e.complexity.Query.DeckTags(childComplexity), true

	case "Query.getMTGCardPackages":
		if e.complexity.Query.GetMTGCardPackages == nil {
			break
		}

		args, err := ec.field_Query_getMTGCardPackages_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetMTGCardPackages(childComplexity, args["cardPackageID"].(*string), args["includePublic"].(*bool)), true

	case "Query.getMTGCards":
		if e.complexity.Query.GetMTGCards == nil {
			break
		}

		return e.complexity.Query.GetMTGCards(childComplexity), true

	case "Query.getMTGCardsFiltered":
		if e.complexity.Query.GetMTGCardsFiltered == nil {
			break
		}

		args, err := ec.field_Query_getMTGCardsFiltered_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetMTGCardsFiltered(childComplexity, args["filter"].(model.MtgFilterSearchInput), args["pagination"].(model.MtgFilterPaginationInput), args["sort"].([]*model.MtgFilterSortInput)), true

	case "Query.getMTGDeck":
		if e.complexity.Query.GetMTGDeck == nil {
			break
		}

		args, err := ec.field_Query_getMTGDeck_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetMTGDeck(childComplexity, args["deckID"].(string)), true

	case "Query.getMTGDecks":
		if e.complexity.Query.GetMTGDecks == nil {
			break
		}

		return e.complexity.Query.GetMTGDecks(childComplexity), true

	case "Query.getMTGFilters":
		if e.complexity.Query.GetMTGFilters == nil {
			break
		}

		return e.complexity.Query.GetMTGFilters(childComplexity), true

	case "Query.tag":
		if e.complexity.Query.Tag == nil {
			break
		}

		args, err := ec.field_Query_tag_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Tag(childComplexity, args["id"].(string)), true

	case "Query.tags":
		if e.complexity.Query.Tags == nil {
			break
		}

		return e.complexity.Query.Tags(childComplexity), true

	case "Response.message":
		if e.complexity.Response.Message == nil {
			break
		}

		return e.complexity.Response.Message(childComplexity), true

	case "Response.status":
		if e.complexity.Response.Status == nil {
			break
		}

		return e.complexity.Response.Status(childComplexity), true

	case "User.ID":
		if e.complexity.User.ID == nil {
			break
		}

		return e.complexity.User.ID(childComplexity), true

	case "User.roles":
		if e.complexity.User.Roles == nil {
			break
		}

		return e.complexity.User.Roles(childComplexity), true

	case "UserRating.user":
		if e.complexity.UserRating.User == nil {
			break
		}

		return e.complexity.UserRating.User(childComplexity), true

	case "UserRating.value":
		if e.complexity.UserRating.Value == nil {
			break
		}

		return e.complexity.UserRating.Value(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	opCtx := graphql.GetOperationContext(ctx)
	ec := executionContext{opCtx, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputAddIgnoredCardInput,
		ec.unmarshalInputAdminImportActionInput,
		ec.unmarshalInputAssignTagInput,
		ec.unmarshalInputCreateTagInput,
		ec.unmarshalInputFlowZoneInput,
		ec.unmarshalInputMTG_AddCardToCardPackageInput,
		ec.unmarshalInputMTG_CardPackageCardInput,
		ec.unmarshalInputMTG_CreateCardPackageInput,
		ec.unmarshalInputMTG_CreateDeckInput,
		ec.unmarshalInputMTG_DeckCardFrontImageInput,
		ec.unmarshalInputMTG_DeckCardInput,
		ec.unmarshalInputMTG_DeleteCardPackageInput,
		ec.unmarshalInputMTG_DeleteDeckInput,
		ec.unmarshalInputMTG_EditCardPackageNameInput,
		ec.unmarshalInputMTG_EditCardPackageVisibilityInput,
		ec.unmarshalInputMTG_Filter_CardTypeInput,
		ec.unmarshalInputMTG_Filter_ColorInput,
		ec.unmarshalInputMTG_Filter_GameInput,
		ec.unmarshalInputMTG_Filter_LayoutInput,
		ec.unmarshalInputMTG_Filter_LegalityEntryInput,
		ec.unmarshalInputMTG_Filter_LegalityInput,
		ec.unmarshalInputMTG_Filter_ManaCostInput,
		ec.unmarshalInputMTG_Filter_PaginationInput,
		ec.unmarshalInputMTG_Filter_RarityInput,
		ec.unmarshalInputMTG_Filter_RatingInput,
		ec.unmarshalInputMTG_Filter_SearchInput,
		ec.unmarshalInputMTG_Filter_SetInput,
		ec.unmarshalInputMTG_Filter_SortInput,
		ec.unmarshalInputMTG_Filter_SubtypeInput,
		ec.unmarshalInputMTG_Filter_TagInput,
		ec.unmarshalInputMTG_RemoveCardFromCardPackageInput,
		ec.unmarshalInputMTG_UpdateDeckInput,
		ec.unmarshalInputPhantomInput,
		ec.unmarshalInputPositionInput,
		ec.unmarshalInputRateInput,
		ec.unmarshalInputRemoveIgnoredCardInput,
		ec.unmarshalInputUnassignTagInput,
		ec.unmarshalInputUpdateTagInput,
	)
	first := true

	switch opCtx.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, opCtx.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, opCtx.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../../../graphql/Admin/enum.graphqls", Input: `"""
Roles that can be assigned to a user.
"""
enum UserRole {
    ADMIN
    USER
}

"""
Background jobs supported by the importer.
"""
enum AdminJob {
    MTG_CARDS
    MTG_SETS
}

"""
Execution status values for an import run.
"""
enum AdminImportStatus {
    RUNNING
    SUCCESS
    FAILED
    SKIPPED
}
`, BuiltIn: false},
	{Name: "../../../graphql/Admin/input.graphqls", Input: `"""
Parameters to trigger or backfill import jobs.
"""
input AdminImportActionInput {
    job: AdminJob!
    force: Boolean = false
}
`, BuiltIn: false},
	{Name: "../../../graphql/Admin/type.graphqls", Input: `"""
Aggregate admin dashboard information.
"""
type AdminDashboard {
    imports: [AdminImportSummary!]!
    latestLegalitiesDiff: AdminLegalitiesDiff
}

"""
Summary for an import job with recent runs and metrics.
"""
type AdminImportSummary {
    jobName: AdminJob!
    lastRun: AdminImportReport
    previousRun: AdminImportReport
    latency: AdminLatencyMetrics!
}

"""
Detailed import report data exposed to admins.
"""
type AdminImportReport {
    id: ID!
    jobName: AdminJob!
    status: AdminImportStatus!
    startedAt: Int!
    completedAt: Int
    durationMs: Int
    recordsProcessed: Int
    errorMessage: String
    metadata: Map
}

"""
Latency metrics derived from recent import runs.
"""
type AdminLatencyMetrics {
    lastDurationMs: Int
    avgDurationMs: Int
    p50DurationMs: Int
    p90DurationMs: Int
    totalRuns: Int!
    lastStartedAt: Int
}

"""
Single legality change entry between consecutive imports.
"""
type AdminLegalitiesDiffEntry {
    cardID: ID!
    cardName: String!
    format: String!
    previousStatus: String
    currentStatus: String
    setCode: String
    setName: String
    changedAt: Int!
}

"""
Collection of legality changes tied to an import run.
"""
type AdminLegalitiesDiff {
    importId: ID!
    jobName: AdminJob!
    entries: [AdminLegalitiesDiffEntry!]!
}
`, BuiltIn: false},
	{Name: "../../../graphql/Flow/input.graphqls", Input: `"""
Used to save the deck builder zones and their children.
"""
input FlowZoneInput {
    ID: ID!
    name: String!
    position: PositionInput!
    width: Float!
    height: Float!
    cardChildren: [ID!]!
    zoneChildren: [ID!]!
}

"""
Used to save the position of an entity in the deck builder.
"""
input PositionInput {
    x: Float!
    y: Float!
}
`, BuiltIn: false},
	{Name: "../../../graphql/Flow/type.graphqls", Input: `"""
Represents a zone in the deck builder.
"""
type FlowZone {
    ID: ID!
    name: String!
    position: Position!
    width: Float!
    height: Float!
    cardChildren: [ID!]!
    zoneChildren: [ID!]!
}

"""
Represents the position of an entity in the deck builder.
"""
type Position {
    x: Float!
    y: Float!
}
`, BuiltIn: false},
	{Name: "../../../graphql/MTG/Card/enum.graphqls", Input: `"""
Magic color identity abbreviations.
"""
enum MTG_Color {
    C
    W
    U
    B
    R
    G
}

"""
Rarity tiers for a printing.
"""
enum MTG_Rarity {
    common
    uncommon
    rare
    mythic
}

"""
Card layouts as defined by Scryfall.
"""
enum MTG_Layout {
    normal
    split
    flip
    transform
    modal_dfc
    meld
    leveler
    class
    case
    saga
    adventure
    mutate
    prototype
    battle
    planar
    scheme
    vanguard
    token
    double_faced_token
    emblem
    augment
    host
    art_series
    reversible_card
}

"""
Game platforms where a print is available.
"""
enum MTG_Game {
    paper
    mtgo
    arena
}
`, BuiltIn: false},
	{Name: "../../../graphql/MTG/Card/type.graphqls", Input: `"""
Aggregated MTG card entity with curated versions and user context.
"""
type MTG_Card {
    ID: ID! @goTag(key: "json", value: "_key")
    layout: MTG_Layout!
    CMC: Float!
    colorIdentity: [MTG_Color!]!
    colorIndicator: [String!]
    colors: [MTG_Color!]
    EDHRecRank: Int
    keywords: [String!]!
    loyalty: String
    manaCost: String
    name: String!
    oracleText: String
    power: String
    producedMana: [MTG_Color!]
    toughness: String
    typeLine: String!
    versions: [MTG_CardVersion!]!
    myRating: UserRating
    cardTags: [CardTag!]!
    deckTags: [DeckTag!]!
}

"""
A specific printing/version of a card used by the app.
"""
type MTG_CardVersion {
    ID: ID!
    isDefault: Boolean!
    isAlchemy: Boolean!
    artist: String
    lang: String!
    flavorName: String
    flavorText: String
    cardFaces: [MTG_CardFace!]
    legalities: Map!
    games: [MTG_Game!]!
    imageUris: MTG_Image
    printedName: String!
    rarity: MTG_Rarity!
    releasedAt: String!
    reprint: Boolean!
    setName: String!
    setType: String!
    set: String!
    setID: String!
    variation: Boolean!
    variationOf: String
}

"""
One face of a multi-faced card version.
"""
type MTG_CardFace {
    artist: String
    CMC: Float
    colorIndicator: [String!]
    colors: [MTG_Color!]
    flavorText: String
    imageUris: MTG_Image
    layout: MTG_Layout
    loyalty: String
    manaCost: String!
    name: String!
    oracleText: String
    power: String
    toughness: String
    typeLine: String
}

"""
Image URLs in multiple sizes from Scryfall.
"""
type MTG_Image {
    artCrop: String!
    borderCrop: String!
    large: String!
    normal: String!
    PNG: String!
    small: String!
}

"""
Minimal card representation for dashboard listings.
"""
type MTG_Card_Dashboard {
    ID: ID! @goTag(key: "json", value: "_key")
    versions: [MTG_CardVersion_Dashboard!]!
}

"""
Minimal card version data for dashboard UI.
"""
type MTG_CardVersion_Dashboard {
    ID: ID!
    isDefault: Boolean!
    isAlchemy: Boolean!
    cardFaces: [MTG_CardFace_Dashboard!]!
    imageUris: MTG_Image
}

"""
Minimal face data for dashboard UI.
"""
type MTG_CardFace_Dashboard {
    imageUris: MTG_Image
}
`, BuiltIn: false},
	{Name: "../../../graphql/MTG/CardPackage/input.graphqls", Input: `"""
Create a new card package.
"""
input MTG_CreateCardPackageInput {
    name: String!
    isPublic: Boolean = false
}

"""
Delete a card package by ID.
"""
input MTG_DeleteCardPackageInput {
    cardPackageID: ID!
}

"""
Edit a card package name.
"""
input MTG_EditCardPackageNameInput {
    cardPackageID: ID!
    name: String!
}
"""
Toggle card package visibility.
"""
input MTG_EditCardPackageVisibilityInput {
    cardPackageID: ID!
    isPublic: Boolean!
}



"""
Add a card to a package with count.
"""
input MTG_AddCardToCardPackageInput {
    cardPackageID: ID!
    card: ID!
    count: Int!
}

"""
Remove a card from a package.
"""
input MTG_RemoveCardFromCardPackageInput {
    cardPackageID: ID!
    card: ID!
}

"""
Card entry details for a package.
"""
input MTG_CardPackageCardInput {
    card: ID!
    selectedVersionID: String
    count: Int!
    mainOrSide: MainOrSide!
}
`, BuiltIn: false},
	{Name: "../../../graphql/MTG/CardPackage/type.graphqls", Input: `"""
A package grouping cards outside of a deck context.
"""
type MTG_CardPackage {
    ID: ID! @goTag(key: "json", value: "_key")
    name: String!
    isPublic: Boolean!
    ownerID: ID
    cards: [MTG_CardPackageCard!]!
    zones: [FlowZone!]!
}

"""
A card entry inside a card package.
"""
type MTG_CardPackageCard {
    card: MTG_Card!
    selectedVersionID: String
    count: Int!
    mainOrSide: MainOrSide!
    position: Position!
    phantoms: [Phantom!]!
}
`, BuiltIn: false},
	{Name: "../../../graphql/MTG/Deck/enum.graphqls", Input: `"""
Supported deck archetypes.
"""
enum DeckType {
    # STANDARD
    BRAWL_60
    BRAWL_100
}

"""
Indicates whether a card is in main or sideboard.
"""
enum MainOrSide {
    MAIN
    SIDEBOARD
}

"""
Card role in deck (normal or commander).
"""
enum MTG_DeckCardType {
    NORMAL
    COMMANDER
}
`, BuiltIn: false},
	{Name: "../../../graphql/MTG/Deck/input.graphqls", Input: `"""
Input to create a new deck.
"""
input MTG_CreateDeckInput {
    name: String!
}

"""
Input to delete a deck by ID.
"""
input MTG_DeleteDeckInput {
    deckID: ID!
}

"""
Input to update deck fields, cards, zones and front image.
"""
input MTG_UpdateDeckInput {
    deckID: ID!
    name: String!
    cardFrontImage: MTG_DeckCardFrontImageInput
    cards: [MTG_DeckCardInput!]!
    zones: [FlowZoneInput!]!
}

"""
Front image selection referencing a card version.
"""
input MTG_DeckCardFrontImageInput {
    cardID: ID!
    versionID: ID!
}

"""
Deck card entry with position and selection metadata.
"""
input MTG_DeckCardInput {
    ID: ID!
    card: ID!
    selectedVersionID: String
    count: Int!
    position: PositionInput!
    mainOrSide: MainOrSide!
    deckCardType: MTG_DeckCardType!
    phantoms: [PhantomInput!]!
}

"""
Phantom placeholder to aid UI grouping.
"""
input PhantomInput {
    ID: ID!
    position: PositionInput!
}
`, BuiltIn: false},
	{Name: "../../../graphql/MTG/Deck/type.graphqls", Input: `"""
A user deck with cards, positions, zones and optional front image.
"""
type MTG_Deck {
    ID: ID! @goTag(key: "json", value: "_key")
    name: String!
    cardFrontImage: MTG_Deck_CardFrontImage
    cards: [MTG_DeckCard!]!
    zones: [FlowZone!]!
    ignoredCards: [String!]!
}

"""
A card entry in a deck with selection and positioning metadata.
"""
type MTG_DeckCard {
    card: MTG_Card!
    selectedVersionID: String
    count: Int!
    position: Position!
    mainOrSide: MainOrSide!
    deckCardType: MTG_DeckCardType!
    phantoms: [Phantom!]!
}

"""
A phantom placeholder used for visual grouping on the board.
"""
type Phantom {
    position: Position!
    ID: ID!
}

"""
Deck summary for dashboard listings.
"""
type MTG_DeckDashboard {
    ID: ID! @goTag(key: "json", value: "_key")
    name: String!
    cardFrontImage: MTG_Deck_CardFrontImage
    cards: [MTG_DeckCard_Dashboard!]!
}

"""
Selected front image for a deck, referencing a card version.
"""
type MTG_Deck_CardFrontImage {
    cardID: ID!
    versionID: ID!
    image: String!
}

"""
Minimal deck card data for dashboard UI.
"""
type MTG_DeckCard_Dashboard {
    card: MTG_Card_Dashboard!
    selectedVersionID: String
}
`, BuiltIn: false},
	{Name: "../../../graphql/MTG/Filter/enum.graphqls", Input: `"""
Three-state boolean used for filter entries.
"""
enum TernaryBoolean {
    TRUE
    FALSE
    UNSET
}

"""
Sortable fields for card lists.
"""
enum MTG_Filter_SortBy {
    NAME
    CMC
    RARITY
    COLOR
    TYPE
    SET
    RELEASED_AT
}

"""
Sort direction.
"""
enum MTG_Filter_SortDirection {
    ASC
    DESC
}
`, BuiltIn: false},
	{Name: "../../../graphql/MTG/Filter/input.graphqls", Input: `"""
Combined filter input used to filter cards.
"""
input MTG_Filter_SearchInput {
    searchString: String
    rarity: [MTG_Filter_RarityInput!]!
    color: [MTG_Filter_ColorInput!]!
    multiColor: TernaryBoolean!
    manaCosts: [MTG_Filter_ManaCostInput!]!
    cardTypes: [MTG_Filter_CardTypeInput!]!
    subtypes: [MTG_Filter_SubtypeInput!]!
    sets: [MTG_Filter_SetInput!]!
    legalities: [MTG_Filter_LegalityInput!]!
    layouts: [MTG_Filter_LayoutInput!]!
    games: [MTG_Filter_GameInput!]!
    hideIgnored: Boolean!
    tags: [MTG_Filter_TagInput!]!
    rating: MTG_Filter_RatingInput!
    commander: ID
    deckID: ID
    isSelectingCommander: Boolean!
}

"""
Rarity filter entry with ternary state.
"""
input MTG_Filter_RarityInput {
    rarity: MTG_Rarity!
    value: TernaryBoolean!
}

"""
Color filter entry with ternary state.
"""
input MTG_Filter_ColorInput {
    color: MTG_Color!
    value: TernaryBoolean!
}

"""
Mana cost filter entry with ternary state or special values.
"""
input MTG_Filter_ManaCostInput {
    manaCost: String!
    value: TernaryBoolean!
}

"""
Card type filter entry with ternary state.
"""
input MTG_Filter_CardTypeInput {
    cardType: String!
    value: TernaryBoolean!
}

"""
Subtype filter entry with ternary state.
"""
input MTG_Filter_SubtypeInput {
    subtype: String!
    value: TernaryBoolean!
}

"""
Set filter entry with ternary state.
"""
input MTG_Filter_SetInput {
    set: String!
    value: TernaryBoolean!
}

"""
Single legality value with ternary state.
"""
input MTG_Filter_LegalityEntryInput {
    legalityValue: String!
    value: TernaryBoolean!
}

"""
Legality format and associated statuses.
"""
input MTG_Filter_LegalityInput {
    format: String!
    legalityEntries: [MTG_Filter_LegalityEntryInput!]!
}

"""
Layout filter entry with ternary state.
"""
input MTG_Filter_LayoutInput {
    layout: MTG_Layout!
    value: TernaryBoolean!
}

"""
Game platform filter entry with ternary state.
"""
input MTG_Filter_GameInput {
    game: MTG_Game!
    value: TernaryBoolean!
}

"""
Tag filter entry by name or id with ternary state.
"""
input MTG_Filter_TagInput {
    tag: String!
    value: TernaryBoolean!
}

"""
Min/max rating bounds for filtering.
"""
input MTG_Filter_RatingInput {
    min: Int
    max: Int
}

"""
Page and page size for cursorless pagination.
"""
input MTG_Filter_PaginationInput {
    page: Int!
    pageSize: Int!
}

"""
Sort directive with field, direction, and enabled flag.
"""
input MTG_Filter_SortInput {
    sortBy: MTG_Filter_SortBy!
    sortDirection: MTG_Filter_SortDirection!
    enabled: Boolean!
}
`, BuiltIn: false},
	{Name: "../../../graphql/MTG/Filter/type.graphqls", Input: `"""
Aggregated entries used to render filter UI.
"""
type MTG_Filter_Entries {
    types: [MTG_Filter_CardTypes!]!
    expansions: [MTG_Filter_Expansion!]!
    legality: MTG_Filter_Legality!
    layouts: [MTG_Layout!]!
}

"""
A card type and its associated subtypes.
"""
type MTG_Filter_CardTypes {
    cardType: String!
    subtypes: [String!]!
}

"""
Distinct legality formats and statuses collected from cards.
"""
type MTG_Filter_Legality {
    formats: [String!]!
    legalityValues: [String!]!
}

"""
Expansion metadata used by filters and sorting.
"""
type MTG_Filter_Expansion {
    set: String!
    setName: String!
    releasedAt: Int!
    imageURL: String!
    setType: String!
    games: [MTG_Game!]!
}

"""
Search results and total count for pagination.
"""
type MTG_Filter_Search {
    pagedCards: [MTG_Card!]!
    totalCount: Int!
}
`, BuiltIn: false},
	{Name: "../../../graphql/MTG/IgnoredCard/input.graphqls", Input: `"""
Mark a card as ignored for the specified deck.
"""
input AddIgnoredCardInput {
    cardID: ID!
    deckID: ID!
}

"""
Remove an ignored mark for a deck/card pair.
"""
input RemoveIgnoredCardInput {
    cardID: ID!
    deckID: ID!
}
`, BuiltIn: false},
	{Name: "../../../graphql/MTG/Tag/type.graphqls", Input: `type DeckTag implements Tag {
    ID: ID! @goTag(key: "json", value: "_key")
    name: String!
    description: String
    # aggregatedRating: AggregatedRating!
    # ratings: [UserRating!]!
    myRating: UserRating
    colors: [MTG_Color!]!
}
`, BuiltIn: false},
	{Name: "../../../graphql/mutation.graphqls", Input: `"""
Root-level write operations.
"""
type Mutation {
    # Decks
    """
    Create a new deck and return its ID in Response.message.
    """
    createMTGDeck(input: MTG_CreateDeckInput!): Response!
    """
    Delete a deck by ID.
    """
    deleteMTGDeck(input: MTG_DeleteDeckInput!): Response!
    """
    Replace deck fields and card edges.
    """
    updateMTGDeck(input: MTG_UpdateDeckInput!): Response!
    """
    Create a new deck by copying another deck's data.
    """
    saveMTGDeckAsCopy(input: MTG_UpdateDeckInput!): Response!
    # Card Packages
    """
    Create a card package container.
    """
    createMTGCardPackage(input: MTG_CreateCardPackageInput!): Response!
    """
    Delete a card package and its edges.
    """
    deleteMTGCardPackage(input: MTG_DeleteCardPackageInput!): Response!
    """
    Edit a card package name.
    """
    editMTGCardPackageName(input: MTG_EditCardPackageNameInput!): Response!
    """
    Update a card package visibility flag.
    """
    editMTGCardPackageVisibility(input: MTG_EditCardPackageVisibilityInput!): Response!
    """
    Add a card to a package (edge insert).
    """
    addMTGCardToCardPackage(input: MTG_AddCardToCardPackageInput!): Response!
    """
    Remove a card from a package (edge delete).
    """
    removeMTGCardFromCardPackage(input: MTG_RemoveCardFromCardPackageInput!): Response!
    # Tags
    """
    Create a tag and optionally link to a card.
    """
    createTag(input: CreateTagInput!): Response!
    """
    Update tag name/description/colors.
    """
    updateTag(input: UpdateTagInput!): Response!
    """
    Delete a tag and its edges.
    """
    deleteTag(tagID: ID!): Response!
    """
    Link a tag to a card.
    """
    assignTag(input: AssignTagInput!): Response!
    """
    Unlink a tag from a card.
    """
    unassignTag(input: UnassignTagInput!): Response!
    # Ratings
    """
    Rate a card or tag.
    """
    rate(input: RateInput!): Response!
    # Ignored Cards
    """
    Mark a card as ignored for a deck.
    """
    addIgnoredCard(input: AddIgnoredCardInput!): Response!
    """
    Remove ignored mark from a deck/card pair.
    """
    removeIgnoredCard(input: RemoveIgnoredCardInput!): Response!
    """
    Trigger a retry of an import job.
    """
    adminRetryImport(input: AdminImportActionInput!): Response!
    """
    Force a backfill import run ignoring scheduling safeguards.
    """
    adminBackfillImport(input: AdminImportActionInput!): Response!
}

`, BuiltIn: false},
	{Name: "../../../graphql/query.graphqls", Input: `"""
Root-level read operations.
"""
type Query {
    # Cards
    """
    Return all curated MTG cards with ratings and tags.
    """
    getMTGCards: [MTG_Card!]!
    getMTGCardsFiltered(
        filter: MTG_Filter_SearchInput!
        pagination: MTG_Filter_PaginationInput!
        sort: [MTG_Filter_SortInput!]!
    ): MTG_Filter_Search!
    """
    Return available filter options (types, layouts, expansions, legalities).
    """
    getMTGFilters: MTG_Filter_Entries!
    # Decks
    """
    List all decks for dashboard view.
    """
    getMTGDecks: [MTG_DeckDashboard!]!
    """
    Return a single deck by ID with cards and metadata.
    """
    getMTGDeck(deckID: ID!): MTG_Deck!
    # Card Packages
    """
    List card packages or fetch one by ID.
    """
    getMTGCardPackages(cardPackageID: ID, includePublic: Boolean = false): [MTG_CardPackage!]!
    # Tags
    """
    Return all tags (card and deck).
    """
    tags: [Tag!]!
    """
    Return only CardTag items.
    """
    cardTags: [CardTag!]!
    """
    Return only DeckTag items.
    """
    deckTags: [DeckTag!]!
    """
    Fetch a tag by ID (CardTag or DeckTag).
    """
    tag(id: ID!): Tag
    """
    Admin dashboard data with import status, metrics, and legality diffs.
    """
    adminDashboard: AdminDashboard!
    """
    Fetch a specific legality diff by import ID.
    """
    adminLegalitiesDiff(importId: ID!): AdminLegalitiesDiff
    """
    List recent import reports for the given job.
    """
    adminImportReports(job: AdminJob!, limit: Int = 25): [AdminImportReport!]!
}

`, BuiltIn: false},
	{Name: "../../../graphql/Rating/enum.graphqls", Input: `"""
Entities that can be rated by users.
"""
enum RatableEntityType {
    CARD
    TAG
}
`, BuiltIn: false},
	{Name: "../../../graphql/Rating/input.graphqls", Input: `"""
Rate a card or tag by ID.
"""
input RateInput {
    entityID: ID!
    entityType: RatableEntityType!
    value: Int!
}
`, BuiltIn: false},
	{Name: "../../../graphql/Rating/type.graphqls", Input: `"""
A user's rating for an entity (card or tag).
"""
type UserRating {
    user: User!
    value: Int!
}
`, BuiltIn: false},
	{Name: "../../../graphql/Tag/enum.graphqls", Input: `"""
Union discriminator for tag concrete types.
"""
enum TagType {
    CardTag
    DeckTag
}
`, BuiltIn: false},
	{Name: "../../../graphql/Tag/input.graphqls", Input: `"""
Create a new tag, optionally linked to a card.
"""
input CreateTagInput {
    type: TagType!
    name: String!
    description: String
    colors: [MTG_Color!]
    cardID: ID
}

"""
Update tag fields.
"""
input UpdateTagInput {
    ID: ID!
    name: String
    description: String
    colors: [MTG_Color!]
}

"""
Assign a tag to a card.
"""
input AssignTagInput {
    tagID: ID!
    cardID: ID!
}

"""
Remove a tag from a card.
"""
input UnassignTagInput {
    tagID: ID!
    cardID: ID!
}
`, BuiltIn: false},
	{Name: "../../../graphql/Tag/type.graphqls", Input: `"""
A tag that can annotate cards or decks.
"""
interface Tag {
    ID: ID! @goTag(key: "json", value: "_key")
    name: String!
    description: String
    myRating: UserRating
}

"""
A tag intended for annotating cards.
"""
type CardTag implements Tag {
    ID: ID! @goTag(key: "json", value: "_key")
    name: String!
    description: String
    myRating: UserRating
}
`, BuiltIn: false},
	{Name: "../../../graphql/type.base.graphqls", Input: `"""
Attach a struct tag to a Go field generated by gqlgen.
"""
directive @goTag(key: String!, value: String) on INPUT_FIELD_DEFINITION | FIELD_DEFINITION
scalar Map

"""
Generic response wrapper with status and optional message.
"""
type Response {
    status: Boolean!
    message: String
}
`, BuiltIn: false},
	{Name: "../../../graphql/User/type.graphqls", Input: `"""
A user entity used for ratings and ownership.
"""
type User {
    ID: ID! @goTag(key: "json", value: "_key")
    roles: [UserRole!]!
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) field_Mutation_addIgnoredCard_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_addIgnoredCard_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_addIgnoredCard_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.AddIgnoredCardInput, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal model.AddIgnoredCardInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNAddIgnoredCardInput2magicᚑhelperᚋgraphᚋmodelᚐAddIgnoredCardInput(ctx, tmp)
	}

	var zeroVal model.AddIgnoredCardInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_addMTGCardToCardPackage_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_addMTGCardToCardPackage_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_addMTGCardToCardPackage_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.MtgAddCardToCardPackageInput, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal model.MtgAddCardToCardPackageInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNMTG_AddCardToCardPackageInput2magicᚑhelperᚋgraphᚋmodelᚐMtgAddCardToCardPackageInput(ctx, tmp)
	}

	var zeroVal model.MtgAddCardToCardPackageInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_adminBackfillImport_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_adminBackfillImport_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_adminBackfillImport_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.AdminImportActionInput, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal model.AdminImportActionInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNAdminImportActionInput2magicᚑhelperᚋgraphᚋmodelᚐAdminImportActionInput(ctx, tmp)
	}

	var zeroVal model.AdminImportActionInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_adminRetryImport_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_adminRetryImport_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_adminRetryImport_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.AdminImportActionInput, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal model.AdminImportActionInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNAdminImportActionInput2magicᚑhelperᚋgraphᚋmodelᚐAdminImportActionInput(ctx, tmp)
	}

	var zeroVal model.AdminImportActionInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_assignTag_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_assignTag_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_assignTag_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.AssignTagInput, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal model.AssignTagInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNAssignTagInput2magicᚑhelperᚋgraphᚋmodelᚐAssignTagInput(ctx, tmp)
	}

	var zeroVal model.AssignTagInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_createMTGCardPackage_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_createMTGCardPackage_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_createMTGCardPackage_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.MtgCreateCardPackageInput, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal model.MtgCreateCardPackageInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNMTG_CreateCardPackageInput2magicᚑhelperᚋgraphᚋmodelᚐMtgCreateCardPackageInput(ctx, tmp)
	}

	var zeroVal model.MtgCreateCardPackageInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_createMTGDeck_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_createMTGDeck_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_createMTGDeck_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.MtgCreateDeckInput, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal model.MtgCreateDeckInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNMTG_CreateDeckInput2magicᚑhelperᚋgraphᚋmodelᚐMtgCreateDeckInput(ctx, tmp)
	}

	var zeroVal model.MtgCreateDeckInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_createTag_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_createTag_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_createTag_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.CreateTagInput, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal model.CreateTagInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNCreateTagInput2magicᚑhelperᚋgraphᚋmodelᚐCreateTagInput(ctx, tmp)
	}

	var zeroVal model.CreateTagInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_deleteMTGCardPackage_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_deleteMTGCardPackage_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_deleteMTGCardPackage_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.MtgDeleteCardPackageInput, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal model.MtgDeleteCardPackageInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNMTG_DeleteCardPackageInput2magicᚑhelperᚋgraphᚋmodelᚐMtgDeleteCardPackageInput(ctx, tmp)
	}

	var zeroVal model.MtgDeleteCardPackageInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_deleteMTGDeck_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_deleteMTGDeck_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_deleteMTGDeck_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.MtgDeleteDeckInput, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal model.MtgDeleteDeckInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNMTG_DeleteDeckInput2magicᚑhelperᚋgraphᚋmodelᚐMtgDeleteDeckInput(ctx, tmp)
	}

	var zeroVal model.MtgDeleteDeckInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_deleteTag_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_deleteTag_argsTagID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["tagID"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_deleteTag_argsTagID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["tagID"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("tagID"))
	if tmp, ok := rawArgs["tagID"]; ok {
		return ec.unmarshalNID2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_editMTGCardPackageName_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_editMTGCardPackageName_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_editMTGCardPackageName_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.MtgEditCardPackageNameInput, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal model.MtgEditCardPackageNameInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNMTG_EditCardPackageNameInput2magicᚑhelperᚋgraphᚋmodelᚐMtgEditCardPackageNameInput(ctx, tmp)
	}

	var zeroVal model.MtgEditCardPackageNameInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_editMTGCardPackageVisibility_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_editMTGCardPackageVisibility_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_editMTGCardPackageVisibility_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.MtgEditCardPackageVisibilityInput, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal model.MtgEditCardPackageVisibilityInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNMTG_EditCardPackageVisibilityInput2magicᚑhelperᚋgraphᚋmodelᚐMtgEditCardPackageVisibilityInput(ctx, tmp)
	}

	var zeroVal model.MtgEditCardPackageVisibilityInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_rate_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_rate_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_rate_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.RateInput, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal model.RateInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNRateInput2magicᚑhelperᚋgraphᚋmodelᚐRateInput(ctx, tmp)
	}

	var zeroVal model.RateInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_removeIgnoredCard_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_removeIgnoredCard_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_removeIgnoredCard_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.RemoveIgnoredCardInput, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal model.RemoveIgnoredCardInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNRemoveIgnoredCardInput2magicᚑhelperᚋgraphᚋmodelᚐRemoveIgnoredCardInput(ctx, tmp)
	}

	var zeroVal model.RemoveIgnoredCardInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_removeMTGCardFromCardPackage_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_removeMTGCardFromCardPackage_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_removeMTGCardFromCardPackage_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.MtgRemoveCardFromCardPackageInput, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal model.MtgRemoveCardFromCardPackageInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNMTG_RemoveCardFromCardPackageInput2magicᚑhelperᚋgraphᚋmodelᚐMtgRemoveCardFromCardPackageInput(ctx, tmp)
	}

	var zeroVal model.MtgRemoveCardFromCardPackageInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_saveMTGDeckAsCopy_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_saveMTGDeckAsCopy_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_saveMTGDeckAsCopy_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.MtgUpdateDeckInput, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal model.MtgUpdateDeckInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNMTG_UpdateDeckInput2magicᚑhelperᚋgraphᚋmodelᚐMtgUpdateDeckInput(ctx, tmp)
	}

	var zeroVal model.MtgUpdateDeckInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_unassignTag_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_unassignTag_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_unassignTag_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.UnassignTagInput, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal model.UnassignTagInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNUnassignTagInput2magicᚑhelperᚋgraphᚋmodelᚐUnassignTagInput(ctx, tmp)
	}

	var zeroVal model.UnassignTagInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_updateMTGDeck_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_updateMTGDeck_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_updateMTGDeck_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.MtgUpdateDeckInput, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal model.MtgUpdateDeckInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNMTG_UpdateDeckInput2magicᚑhelperᚋgraphᚋmodelᚐMtgUpdateDeckInput(ctx, tmp)
	}

	var zeroVal model.MtgUpdateDeckInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_updateTag_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_updateTag_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_updateTag_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.UpdateTagInput, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal model.UpdateTagInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNUpdateTagInput2magicᚑhelperᚋgraphᚋmodelᚐUpdateTagInput(ctx, tmp)
	}

	var zeroVal model.UpdateTagInput
	return zeroVal, nil
}

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query___type_argsName(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["name"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query___type_argsName(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["name"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
	if tmp, ok := rawArgs["name"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Query_adminImportReports_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_adminImportReports_argsJob(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["job"] = arg0
	arg1, err := ec.field_Query_adminImportReports_argsLimit(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg1
	return args, nil
}
func (ec *executionContext) field_Query_adminImportReports_argsJob(
	ctx context.Context,
	rawArgs map[string]any,
) (model.AdminJob, error) {
	if _, ok := rawArgs["job"]; !ok {
		var zeroVal model.AdminJob
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("job"))
	if tmp, ok := rawArgs["job"]; ok {
		return ec.unmarshalNAdminJob2magicᚑhelperᚋgraphᚋmodelᚐAdminJob(ctx, tmp)
	}

	var zeroVal model.AdminJob
	return zeroVal, nil
}

func (ec *executionContext) field_Query_adminImportReports_argsLimit(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["limit"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
	if tmp, ok := rawArgs["limit"]; ok {
		return ec.unmarshalOInt2ᚖint(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Query_adminLegalitiesDiff_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_adminLegalitiesDiff_argsImportID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["importId"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_adminLegalitiesDiff_argsImportID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["importId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("importId"))
	if tmp, ok := rawArgs["importId"]; ok {
		return ec.unmarshalNID2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getMTGCardPackages_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_getMTGCardPackages_argsCardPackageID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["cardPackageID"] = arg0
	arg1, err := ec.field_Query_getMTGCardPackages_argsIncludePublic(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["includePublic"] = arg1
	return args, nil
}
func (ec *executionContext) field_Query_getMTGCardPackages_argsCardPackageID(
	ctx context.Context,
	rawArgs map[string]any,
) (*string, error) {
	if _, ok := rawArgs["cardPackageID"]; !ok {
		var zeroVal *string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("cardPackageID"))
	if tmp, ok := rawArgs["cardPackageID"]; ok {
		return ec.unmarshalOID2ᚖstring(ctx, tmp)
	}

	var zeroVal *string
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getMTGCardPackages_argsIncludePublic(
	ctx context.Context,
	rawArgs map[string]any,
) (*bool, error) {
	if _, ok := rawArgs["includePublic"]; !ok {
		var zeroVal *bool
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("includePublic"))
	if tmp, ok := rawArgs["includePublic"]; ok {
		return ec.unmarshalOBoolean2ᚖbool(ctx, tmp)
	}

	var zeroVal *bool
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getMTGCardsFiltered_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_getMTGCardsFiltered_argsFilter(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["filter"] = arg0
	arg1, err := ec.field_Query_getMTGCardsFiltered_argsPagination(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["pagination"] = arg1
	arg2, err := ec.field_Query_getMTGCardsFiltered_argsSort(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["sort"] = arg2
	return args, nil
}
func (ec *executionContext) field_Query_getMTGCardsFiltered_argsFilter(
	ctx context.Context,
	rawArgs map[string]any,
) (model.MtgFilterSearchInput, error) {
	if _, ok := rawArgs["filter"]; !ok {
		var zeroVal model.MtgFilterSearchInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
	if tmp, ok := rawArgs["filter"]; ok {
		return ec.unmarshalNMTG_Filter_SearchInput2magicᚑhelperᚋgraphᚋmodelᚐMtgFilterSearchInput(ctx, tmp)
	}

	var zeroVal model.MtgFilterSearchInput
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getMTGCardsFiltered_argsPagination(
	ctx context.Context,
	rawArgs map[string]any,
) (model.MtgFilterPaginationInput, error) {
	if _, ok := rawArgs["pagination"]; !ok {
		var zeroVal model.MtgFilterPaginationInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
	if tmp, ok := rawArgs["pagination"]; ok {
		return ec.unmarshalNMTG_Filter_PaginationInput2magicᚑhelperᚋgraphᚋmodelᚐMtgFilterPaginationInput(ctx, tmp)
	}

	var zeroVal model.MtgFilterPaginationInput
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getMTGCardsFiltered_argsSort(
	ctx context.Context,
	rawArgs map[string]any,
) ([]*model.MtgFilterSortInput, error) {
	if _, ok := rawArgs["sort"]; !ok {
		var zeroVal []*model.MtgFilterSortInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("sort"))
	if tmp, ok := rawArgs["sort"]; ok {
		return ec.unmarshalNMTG_Filter_SortInput2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterSortInputᚄ(ctx, tmp)
	}

	var zeroVal []*model.MtgFilterSortInput
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getMTGDeck_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_getMTGDeck_argsDeckID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["deckID"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_getMTGDeck_argsDeckID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["deckID"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("deckID"))
	if tmp, ok := rawArgs["deckID"]; ok {
		return ec.unmarshalNID2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Query_tag_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_tag_argsID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_tag_argsID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["id"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
	if tmp, ok := rawArgs["id"]; ok {
		return ec.unmarshalNID2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field___Directive_args_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field___Directive_args_argsIncludeDeprecated(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}
func (ec *executionContext) field___Directive_args_argsIncludeDeprecated(
	ctx context.Context,
	rawArgs map[string]any,
) (*bool, error) {
	if _, ok := rawArgs["includeDeprecated"]; !ok {
		var zeroVal *bool
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		return ec.unmarshalOBoolean2ᚖbool(ctx, tmp)
	}

	var zeroVal *bool
	return zeroVal, nil
}

func (ec *executionContext) field___Field_args_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field___Field_args_argsIncludeDeprecated(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}
func (ec *executionContext) field___Field_args_argsIncludeDeprecated(
	ctx context.Context,
	rawArgs map[string]any,
) (*bool, error) {
	if _, ok := rawArgs["includeDeprecated"]; !ok {
		var zeroVal *bool
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		return ec.unmarshalOBoolean2ᚖbool(ctx, tmp)
	}

	var zeroVal *bool
	return zeroVal, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field___Type_enumValues_argsIncludeDeprecated(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}
func (ec *executionContext) field___Type_enumValues_argsIncludeDeprecated(
	ctx context.Context,
	rawArgs map[string]any,
) (bool, error) {
	if _, ok := rawArgs["includeDeprecated"]; !ok {
		var zeroVal bool
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		return ec.unmarshalOBoolean2bool(ctx, tmp)
	}

	var zeroVal bool
	return zeroVal, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field___Type_fields_argsIncludeDeprecated(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}
func (ec *executionContext) field___Type_fields_argsIncludeDeprecated(
	ctx context.Context,
	rawArgs map[string]any,
) (bool, error) {
	if _, ok := rawArgs["includeDeprecated"]; !ok {
		var zeroVal bool
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		return ec.unmarshalOBoolean2bool(ctx, tmp)
	}

	var zeroVal bool
	return zeroVal, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _AdminDashboard_imports(ctx context.Context, field graphql.CollectedField, obj *model.AdminDashboard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminDashboard_imports(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Imports, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.AdminImportSummary)
	fc.Result = res
	return ec.marshalNAdminImportSummary2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐAdminImportSummaryᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminDashboard_imports(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminDashboard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "jobName":
				return ec.fieldContext_AdminImportSummary_jobName(ctx, field)
			case "lastRun":
				return ec.fieldContext_AdminImportSummary_lastRun(ctx, field)
			case "previousRun":
				return ec.fieldContext_AdminImportSummary_previousRun(ctx, field)
			case "latency":
				return ec.fieldContext_AdminImportSummary_latency(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AdminImportSummary", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminDashboard_latestLegalitiesDiff(ctx context.Context, field graphql.CollectedField, obj *model.AdminDashboard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminDashboard_latestLegalitiesDiff(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LatestLegalitiesDiff, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.AdminLegalitiesDiff)
	fc.Result = res
	return ec.marshalOAdminLegalitiesDiff2ᚖmagicᚑhelperᚋgraphᚋmodelᚐAdminLegalitiesDiff(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminDashboard_latestLegalitiesDiff(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminDashboard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "importId":
				return ec.fieldContext_AdminLegalitiesDiff_importId(ctx, field)
			case "jobName":
				return ec.fieldContext_AdminLegalitiesDiff_jobName(ctx, field)
			case "entries":
				return ec.fieldContext_AdminLegalitiesDiff_entries(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AdminLegalitiesDiff", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminImportReport_id(ctx context.Context, field graphql.CollectedField, obj *model.AdminImportReport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminImportReport_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminImportReport_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminImportReport",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminImportReport_jobName(ctx context.Context, field graphql.CollectedField, obj *model.AdminImportReport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminImportReport_jobName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.JobName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.AdminJob)
	fc.Result = res
	return ec.marshalNAdminJob2magicᚑhelperᚋgraphᚋmodelᚐAdminJob(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminImportReport_jobName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminImportReport",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type AdminJob does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminImportReport_status(ctx context.Context, field graphql.CollectedField, obj *model.AdminImportReport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminImportReport_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.AdminImportStatus)
	fc.Result = res
	return ec.marshalNAdminImportStatus2magicᚑhelperᚋgraphᚋmodelᚐAdminImportStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminImportReport_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminImportReport",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type AdminImportStatus does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminImportReport_startedAt(ctx context.Context, field graphql.CollectedField, obj *model.AdminImportReport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminImportReport_startedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminImportReport_startedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminImportReport",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminImportReport_completedAt(ctx context.Context, field graphql.CollectedField, obj *model.AdminImportReport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminImportReport_completedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CompletedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminImportReport_completedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminImportReport",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminImportReport_durationMs(ctx context.Context, field graphql.CollectedField, obj *model.AdminImportReport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminImportReport_durationMs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DurationMs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminImportReport_durationMs(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminImportReport",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminImportReport_recordsProcessed(ctx context.Context, field graphql.CollectedField, obj *model.AdminImportReport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminImportReport_recordsProcessed(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RecordsProcessed, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminImportReport_recordsProcessed(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminImportReport",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminImportReport_errorMessage(ctx context.Context, field graphql.CollectedField, obj *model.AdminImportReport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminImportReport_errorMessage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ErrorMessage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminImportReport_errorMessage(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminImportReport",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminImportReport_metadata(ctx context.Context, field graphql.CollectedField, obj *model.AdminImportReport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminImportReport_metadata(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Metadata, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]any)
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminImportReport_metadata(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminImportReport",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminImportSummary_jobName(ctx context.Context, field graphql.CollectedField, obj *model.AdminImportSummary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminImportSummary_jobName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.JobName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.AdminJob)
	fc.Result = res
	return ec.marshalNAdminJob2magicᚑhelperᚋgraphᚋmodelᚐAdminJob(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminImportSummary_jobName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminImportSummary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type AdminJob does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminImportSummary_lastRun(ctx context.Context, field graphql.CollectedField, obj *model.AdminImportSummary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminImportSummary_lastRun(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastRun, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.AdminImportReport)
	fc.Result = res
	return ec.marshalOAdminImportReport2ᚖmagicᚑhelperᚋgraphᚋmodelᚐAdminImportReport(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminImportSummary_lastRun(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminImportSummary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_AdminImportReport_id(ctx, field)
			case "jobName":
				return ec.fieldContext_AdminImportReport_jobName(ctx, field)
			case "status":
				return ec.fieldContext_AdminImportReport_status(ctx, field)
			case "startedAt":
				return ec.fieldContext_AdminImportReport_startedAt(ctx, field)
			case "completedAt":
				return ec.fieldContext_AdminImportReport_completedAt(ctx, field)
			case "durationMs":
				return ec.fieldContext_AdminImportReport_durationMs(ctx, field)
			case "recordsProcessed":
				return ec.fieldContext_AdminImportReport_recordsProcessed(ctx, field)
			case "errorMessage":
				return ec.fieldContext_AdminImportReport_errorMessage(ctx, field)
			case "metadata":
				return ec.fieldContext_AdminImportReport_metadata(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AdminImportReport", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminImportSummary_previousRun(ctx context.Context, field graphql.CollectedField, obj *model.AdminImportSummary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminImportSummary_previousRun(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PreviousRun, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.AdminImportReport)
	fc.Result = res
	return ec.marshalOAdminImportReport2ᚖmagicᚑhelperᚋgraphᚋmodelᚐAdminImportReport(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminImportSummary_previousRun(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminImportSummary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_AdminImportReport_id(ctx, field)
			case "jobName":
				return ec.fieldContext_AdminImportReport_jobName(ctx, field)
			case "status":
				return ec.fieldContext_AdminImportReport_status(ctx, field)
			case "startedAt":
				return ec.fieldContext_AdminImportReport_startedAt(ctx, field)
			case "completedAt":
				return ec.fieldContext_AdminImportReport_completedAt(ctx, field)
			case "durationMs":
				return ec.fieldContext_AdminImportReport_durationMs(ctx, field)
			case "recordsProcessed":
				return ec.fieldContext_AdminImportReport_recordsProcessed(ctx, field)
			case "errorMessage":
				return ec.fieldContext_AdminImportReport_errorMessage(ctx, field)
			case "metadata":
				return ec.fieldContext_AdminImportReport_metadata(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AdminImportReport", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminImportSummary_latency(ctx context.Context, field graphql.CollectedField, obj *model.AdminImportSummary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminImportSummary_latency(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Latency, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.AdminLatencyMetrics)
	fc.Result = res
	return ec.marshalNAdminLatencyMetrics2ᚖmagicᚑhelperᚋgraphᚋmodelᚐAdminLatencyMetrics(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminImportSummary_latency(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminImportSummary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "lastDurationMs":
				return ec.fieldContext_AdminLatencyMetrics_lastDurationMs(ctx, field)
			case "avgDurationMs":
				return ec.fieldContext_AdminLatencyMetrics_avgDurationMs(ctx, field)
			case "p50DurationMs":
				return ec.fieldContext_AdminLatencyMetrics_p50DurationMs(ctx, field)
			case "p90DurationMs":
				return ec.fieldContext_AdminLatencyMetrics_p90DurationMs(ctx, field)
			case "totalRuns":
				return ec.fieldContext_AdminLatencyMetrics_totalRuns(ctx, field)
			case "lastStartedAt":
				return ec.fieldContext_AdminLatencyMetrics_lastStartedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AdminLatencyMetrics", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminLatencyMetrics_lastDurationMs(ctx context.Context, field graphql.CollectedField, obj *model.AdminLatencyMetrics) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminLatencyMetrics_lastDurationMs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastDurationMs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminLatencyMetrics_lastDurationMs(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminLatencyMetrics",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminLatencyMetrics_avgDurationMs(ctx context.Context, field graphql.CollectedField, obj *model.AdminLatencyMetrics) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminLatencyMetrics_avgDurationMs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AvgDurationMs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminLatencyMetrics_avgDurationMs(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminLatencyMetrics",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminLatencyMetrics_p50DurationMs(ctx context.Context, field graphql.CollectedField, obj *model.AdminLatencyMetrics) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminLatencyMetrics_p50DurationMs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.P50DurationMs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminLatencyMetrics_p50DurationMs(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminLatencyMetrics",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminLatencyMetrics_p90DurationMs(ctx context.Context, field graphql.CollectedField, obj *model.AdminLatencyMetrics) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminLatencyMetrics_p90DurationMs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.P90DurationMs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminLatencyMetrics_p90DurationMs(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminLatencyMetrics",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminLatencyMetrics_totalRuns(ctx context.Context, field graphql.CollectedField, obj *model.AdminLatencyMetrics) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminLatencyMetrics_totalRuns(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalRuns, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminLatencyMetrics_totalRuns(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminLatencyMetrics",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminLatencyMetrics_lastStartedAt(ctx context.Context, field graphql.CollectedField, obj *model.AdminLatencyMetrics) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminLatencyMetrics_lastStartedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastStartedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminLatencyMetrics_lastStartedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminLatencyMetrics",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminLegalitiesDiff_importId(ctx context.Context, field graphql.CollectedField, obj *model.AdminLegalitiesDiff) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminLegalitiesDiff_importId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ImportID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminLegalitiesDiff_importId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminLegalitiesDiff",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminLegalitiesDiff_jobName(ctx context.Context, field graphql.CollectedField, obj *model.AdminLegalitiesDiff) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminLegalitiesDiff_jobName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.JobName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.AdminJob)
	fc.Result = res
	return ec.marshalNAdminJob2magicᚑhelperᚋgraphᚋmodelᚐAdminJob(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminLegalitiesDiff_jobName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminLegalitiesDiff",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type AdminJob does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminLegalitiesDiff_entries(ctx context.Context, field graphql.CollectedField, obj *model.AdminLegalitiesDiff) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminLegalitiesDiff_entries(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Entries, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.AdminLegalitiesDiffEntry)
	fc.Result = res
	return ec.marshalNAdminLegalitiesDiffEntry2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐAdminLegalitiesDiffEntryᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminLegalitiesDiff_entries(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminLegalitiesDiff",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cardID":
				return ec.fieldContext_AdminLegalitiesDiffEntry_cardID(ctx, field)
			case "cardName":
				return ec.fieldContext_AdminLegalitiesDiffEntry_cardName(ctx, field)
			case "format":
				return ec.fieldContext_AdminLegalitiesDiffEntry_format(ctx, field)
			case "previousStatus":
				return ec.fieldContext_AdminLegalitiesDiffEntry_previousStatus(ctx, field)
			case "currentStatus":
				return ec.fieldContext_AdminLegalitiesDiffEntry_currentStatus(ctx, field)
			case "setCode":
				return ec.fieldContext_AdminLegalitiesDiffEntry_setCode(ctx, field)
			case "setName":
				return ec.fieldContext_AdminLegalitiesDiffEntry_setName(ctx, field)
			case "changedAt":
				return ec.fieldContext_AdminLegalitiesDiffEntry_changedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AdminLegalitiesDiffEntry", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminLegalitiesDiffEntry_cardID(ctx context.Context, field graphql.CollectedField, obj *model.AdminLegalitiesDiffEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminLegalitiesDiffEntry_cardID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CardID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminLegalitiesDiffEntry_cardID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminLegalitiesDiffEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminLegalitiesDiffEntry_cardName(ctx context.Context, field graphql.CollectedField, obj *model.AdminLegalitiesDiffEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminLegalitiesDiffEntry_cardName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CardName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminLegalitiesDiffEntry_cardName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminLegalitiesDiffEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminLegalitiesDiffEntry_format(ctx context.Context, field graphql.CollectedField, obj *model.AdminLegalitiesDiffEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminLegalitiesDiffEntry_format(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Format, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminLegalitiesDiffEntry_format(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminLegalitiesDiffEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminLegalitiesDiffEntry_previousStatus(ctx context.Context, field graphql.CollectedField, obj *model.AdminLegalitiesDiffEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminLegalitiesDiffEntry_previousStatus(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PreviousStatus, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminLegalitiesDiffEntry_previousStatus(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminLegalitiesDiffEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminLegalitiesDiffEntry_currentStatus(ctx context.Context, field graphql.CollectedField, obj *model.AdminLegalitiesDiffEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminLegalitiesDiffEntry_currentStatus(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CurrentStatus, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminLegalitiesDiffEntry_currentStatus(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminLegalitiesDiffEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminLegalitiesDiffEntry_setCode(ctx context.Context, field graphql.CollectedField, obj *model.AdminLegalitiesDiffEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminLegalitiesDiffEntry_setCode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SetCode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminLegalitiesDiffEntry_setCode(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminLegalitiesDiffEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminLegalitiesDiffEntry_setName(ctx context.Context, field graphql.CollectedField, obj *model.AdminLegalitiesDiffEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminLegalitiesDiffEntry_setName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SetName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminLegalitiesDiffEntry_setName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminLegalitiesDiffEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminLegalitiesDiffEntry_changedAt(ctx context.Context, field graphql.CollectedField, obj *model.AdminLegalitiesDiffEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminLegalitiesDiffEntry_changedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ChangedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminLegalitiesDiffEntry_changedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminLegalitiesDiffEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CardTag_ID(ctx context.Context, field graphql.CollectedField, obj *model.CardTag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CardTag_ID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CardTag_ID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CardTag",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CardTag_name(ctx context.Context, field graphql.CollectedField, obj *model.CardTag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CardTag_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CardTag_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CardTag",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CardTag_description(ctx context.Context, field graphql.CollectedField, obj *model.CardTag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CardTag_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CardTag_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CardTag",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CardTag_myRating(ctx context.Context, field graphql.CollectedField, obj *model.CardTag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CardTag_myRating(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MyRating, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.UserRating)
	fc.Result = res
	return ec.marshalOUserRating2ᚖmagicᚑhelperᚋgraphᚋmodelᚐUserRating(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CardTag_myRating(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CardTag",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "user":
				return ec.fieldContext_UserRating_user(ctx, field)
			case "value":
				return ec.fieldContext_UserRating_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserRating", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeckTag_ID(ctx context.Context, field graphql.CollectedField, obj *model.DeckTag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeckTag_ID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeckTag_ID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeckTag",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeckTag_name(ctx context.Context, field graphql.CollectedField, obj *model.DeckTag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeckTag_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeckTag_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeckTag",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeckTag_description(ctx context.Context, field graphql.CollectedField, obj *model.DeckTag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeckTag_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeckTag_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeckTag",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeckTag_myRating(ctx context.Context, field graphql.CollectedField, obj *model.DeckTag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeckTag_myRating(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MyRating, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.UserRating)
	fc.Result = res
	return ec.marshalOUserRating2ᚖmagicᚑhelperᚋgraphᚋmodelᚐUserRating(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeckTag_myRating(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeckTag",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "user":
				return ec.fieldContext_UserRating_user(ctx, field)
			case "value":
				return ec.fieldContext_UserRating_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserRating", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeckTag_colors(ctx context.Context, field graphql.CollectedField, obj *model.DeckTag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeckTag_colors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Colors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.MtgColor)
	fc.Result = res
	return ec.marshalNMTG_Color2ᚕmagicᚑhelperᚋgraphᚋmodelᚐMtgColorᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeckTag_colors(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeckTag",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type MTG_Color does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FlowZone_ID(ctx context.Context, field graphql.CollectedField, obj *model.FlowZone) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FlowZone_ID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FlowZone_ID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FlowZone",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FlowZone_name(ctx context.Context, field graphql.CollectedField, obj *model.FlowZone) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FlowZone_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FlowZone_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FlowZone",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FlowZone_position(ctx context.Context, field graphql.CollectedField, obj *model.FlowZone) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FlowZone_position(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Position, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Position)
	fc.Result = res
	return ec.marshalNPosition2ᚖmagicᚑhelperᚋgraphᚋmodelᚐPosition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FlowZone_position(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FlowZone",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "x":
				return ec.fieldContext_Position_x(ctx, field)
			case "y":
				return ec.fieldContext_Position_y(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Position", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FlowZone_width(ctx context.Context, field graphql.CollectedField, obj *model.FlowZone) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FlowZone_width(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Width, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FlowZone_width(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FlowZone",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FlowZone_height(ctx context.Context, field graphql.CollectedField, obj *model.FlowZone) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FlowZone_height(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Height, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FlowZone_height(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FlowZone",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FlowZone_cardChildren(ctx context.Context, field graphql.CollectedField, obj *model.FlowZone) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FlowZone_cardChildren(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CardChildren, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNID2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FlowZone_cardChildren(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FlowZone",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FlowZone_zoneChildren(ctx context.Context, field graphql.CollectedField, obj *model.FlowZone) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FlowZone_zoneChildren(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ZoneChildren, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNID2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FlowZone_zoneChildren(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FlowZone",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Card_ID(ctx context.Context, field graphql.CollectedField, obj *model.MtgCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Card_ID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Card_ID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Card",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Card_layout(ctx context.Context, field graphql.CollectedField, obj *model.MtgCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Card_layout(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Layout, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.MtgLayout)
	fc.Result = res
	return ec.marshalNMTG_Layout2magicᚑhelperᚋgraphᚋmodelᚐMtgLayout(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Card_layout(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Card",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type MTG_Layout does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Card_CMC(ctx context.Context, field graphql.CollectedField, obj *model.MtgCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Card_CMC(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cmc, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Card_CMC(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Card",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Card_colorIdentity(ctx context.Context, field graphql.CollectedField, obj *model.MtgCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Card_colorIdentity(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ColorIdentity, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.MtgColor)
	fc.Result = res
	return ec.marshalNMTG_Color2ᚕmagicᚑhelperᚋgraphᚋmodelᚐMtgColorᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Card_colorIdentity(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Card",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type MTG_Color does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Card_colorIndicator(ctx context.Context, field graphql.CollectedField, obj *model.MtgCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Card_colorIndicator(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ColorIndicator, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Card_colorIndicator(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Card",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Card_colors(ctx context.Context, field graphql.CollectedField, obj *model.MtgCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Card_colors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Colors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.MtgColor)
	fc.Result = res
	return ec.marshalOMTG_Color2ᚕmagicᚑhelperᚋgraphᚋmodelᚐMtgColorᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Card_colors(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Card",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type MTG_Color does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Card_EDHRecRank(ctx context.Context, field graphql.CollectedField, obj *model.MtgCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Card_EDHRecRank(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EDHRecRank, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Card_EDHRecRank(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Card",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Card_keywords(ctx context.Context, field graphql.CollectedField, obj *model.MtgCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Card_keywords(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Keywords, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Card_keywords(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Card",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Card_loyalty(ctx context.Context, field graphql.CollectedField, obj *model.MtgCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Card_loyalty(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Loyalty, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Card_loyalty(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Card",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Card_manaCost(ctx context.Context, field graphql.CollectedField, obj *model.MtgCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Card_manaCost(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ManaCost, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Card_manaCost(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Card",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Card_name(ctx context.Context, field graphql.CollectedField, obj *model.MtgCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Card_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Card_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Card",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Card_oracleText(ctx context.Context, field graphql.CollectedField, obj *model.MtgCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Card_oracleText(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OracleText, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Card_oracleText(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Card",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Card_power(ctx context.Context, field graphql.CollectedField, obj *model.MtgCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Card_power(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Power, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Card_power(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Card",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Card_producedMana(ctx context.Context, field graphql.CollectedField, obj *model.MtgCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Card_producedMana(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProducedMana, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.MtgColor)
	fc.Result = res
	return ec.marshalOMTG_Color2ᚕmagicᚑhelperᚋgraphᚋmodelᚐMtgColorᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Card_producedMana(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Card",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type MTG_Color does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Card_toughness(ctx context.Context, field graphql.CollectedField, obj *model.MtgCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Card_toughness(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Toughness, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Card_toughness(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Card",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Card_typeLine(ctx context.Context, field graphql.CollectedField, obj *model.MtgCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Card_typeLine(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TypeLine, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Card_typeLine(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Card",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Card_versions(ctx context.Context, field graphql.CollectedField, obj *model.MtgCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Card_versions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Versions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.MtgCardVersion)
	fc.Result = res
	return ec.marshalNMTG_CardVersion2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgCardVersionᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Card_versions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Card",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ID":
				return ec.fieldContext_MTG_CardVersion_ID(ctx, field)
			case "isDefault":
				return ec.fieldContext_MTG_CardVersion_isDefault(ctx, field)
			case "isAlchemy":
				return ec.fieldContext_MTG_CardVersion_isAlchemy(ctx, field)
			case "artist":
				return ec.fieldContext_MTG_CardVersion_artist(ctx, field)
			case "lang":
				return ec.fieldContext_MTG_CardVersion_lang(ctx, field)
			case "flavorName":
				return ec.fieldContext_MTG_CardVersion_flavorName(ctx, field)
			case "flavorText":
				return ec.fieldContext_MTG_CardVersion_flavorText(ctx, field)
			case "cardFaces":
				return ec.fieldContext_MTG_CardVersion_cardFaces(ctx, field)
			case "legalities":
				return ec.fieldContext_MTG_CardVersion_legalities(ctx, field)
			case "games":
				return ec.fieldContext_MTG_CardVersion_games(ctx, field)
			case "imageUris":
				return ec.fieldContext_MTG_CardVersion_imageUris(ctx, field)
			case "printedName":
				return ec.fieldContext_MTG_CardVersion_printedName(ctx, field)
			case "rarity":
				return ec.fieldContext_MTG_CardVersion_rarity(ctx, field)
			case "releasedAt":
				return ec.fieldContext_MTG_CardVersion_releasedAt(ctx, field)
			case "reprint":
				return ec.fieldContext_MTG_CardVersion_reprint(ctx, field)
			case "setName":
				return ec.fieldContext_MTG_CardVersion_setName(ctx, field)
			case "setType":
				return ec.fieldContext_MTG_CardVersion_setType(ctx, field)
			case "set":
				return ec.fieldContext_MTG_CardVersion_set(ctx, field)
			case "setID":
				return ec.fieldContext_MTG_CardVersion_setID(ctx, field)
			case "variation":
				return ec.fieldContext_MTG_CardVersion_variation(ctx, field)
			case "variationOf":
				return ec.fieldContext_MTG_CardVersion_variationOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MTG_CardVersion", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Card_myRating(ctx context.Context, field graphql.CollectedField, obj *model.MtgCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Card_myRating(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MyRating, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.UserRating)
	fc.Result = res
	return ec.marshalOUserRating2ᚖmagicᚑhelperᚋgraphᚋmodelᚐUserRating(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Card_myRating(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Card",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "user":
				return ec.fieldContext_UserRating_user(ctx, field)
			case "value":
				return ec.fieldContext_UserRating_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserRating", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Card_cardTags(ctx context.Context, field graphql.CollectedField, obj *model.MtgCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Card_cardTags(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CardTags, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.CardTag)
	fc.Result = res
	return ec.marshalNCardTag2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐCardTagᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Card_cardTags(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Card",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ID":
				return ec.fieldContext_CardTag_ID(ctx, field)
			case "name":
				return ec.fieldContext_CardTag_name(ctx, field)
			case "description":
				return ec.fieldContext_CardTag_description(ctx, field)
			case "myRating":
				return ec.fieldContext_CardTag_myRating(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CardTag", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Card_deckTags(ctx context.Context, field graphql.CollectedField, obj *model.MtgCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Card_deckTags(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeckTags, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.DeckTag)
	fc.Result = res
	return ec.marshalNDeckTag2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐDeckTagᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Card_deckTags(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Card",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ID":
				return ec.fieldContext_DeckTag_ID(ctx, field)
			case "name":
				return ec.fieldContext_DeckTag_name(ctx, field)
			case "description":
				return ec.fieldContext_DeckTag_description(ctx, field)
			case "myRating":
				return ec.fieldContext_DeckTag_myRating(ctx, field)
			case "colors":
				return ec.fieldContext_DeckTag_colors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DeckTag", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardFace_artist(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardFace) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardFace_artist(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Artist, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardFace_artist(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardFace",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardFace_CMC(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardFace) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardFace_CMC(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cmc, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*float64)
	fc.Result = res
	return ec.marshalOFloat2ᚖfloat64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardFace_CMC(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardFace",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardFace_colorIndicator(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardFace) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardFace_colorIndicator(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ColorIndicator, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardFace_colorIndicator(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardFace",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardFace_colors(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardFace) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardFace_colors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Colors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.MtgColor)
	fc.Result = res
	return ec.marshalOMTG_Color2ᚕmagicᚑhelperᚋgraphᚋmodelᚐMtgColorᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardFace_colors(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardFace",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type MTG_Color does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardFace_flavorText(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardFace) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardFace_flavorText(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FlavorText, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardFace_flavorText(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardFace",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardFace_imageUris(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardFace) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardFace_imageUris(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ImageUris, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.MtgImage)
	fc.Result = res
	return ec.marshalOMTG_Image2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgImage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardFace_imageUris(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardFace",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "artCrop":
				return ec.fieldContext_MTG_Image_artCrop(ctx, field)
			case "borderCrop":
				return ec.fieldContext_MTG_Image_borderCrop(ctx, field)
			case "large":
				return ec.fieldContext_MTG_Image_large(ctx, field)
			case "normal":
				return ec.fieldContext_MTG_Image_normal(ctx, field)
			case "PNG":
				return ec.fieldContext_MTG_Image_PNG(ctx, field)
			case "small":
				return ec.fieldContext_MTG_Image_small(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MTG_Image", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardFace_layout(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardFace) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardFace_layout(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Layout, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.MtgLayout)
	fc.Result = res
	return ec.marshalOMTG_Layout2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgLayout(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardFace_layout(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardFace",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type MTG_Layout does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardFace_loyalty(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardFace) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardFace_loyalty(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Loyalty, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardFace_loyalty(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardFace",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardFace_manaCost(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardFace) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardFace_manaCost(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ManaCost, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardFace_manaCost(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardFace",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardFace_name(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardFace) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardFace_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardFace_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardFace",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardFace_oracleText(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardFace) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardFace_oracleText(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OracleText, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardFace_oracleText(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardFace",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardFace_power(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardFace) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardFace_power(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Power, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardFace_power(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardFace",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardFace_toughness(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardFace) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardFace_toughness(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Toughness, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardFace_toughness(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardFace",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardFace_typeLine(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardFace) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardFace_typeLine(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TypeLine, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardFace_typeLine(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardFace",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardFace_Dashboard_imageUris(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardFaceDashboard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardFace_Dashboard_imageUris(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ImageUris, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.MtgImage)
	fc.Result = res
	return ec.marshalOMTG_Image2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgImage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardFace_Dashboard_imageUris(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardFace_Dashboard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "artCrop":
				return ec.fieldContext_MTG_Image_artCrop(ctx, field)
			case "borderCrop":
				return ec.fieldContext_MTG_Image_borderCrop(ctx, field)
			case "large":
				return ec.fieldContext_MTG_Image_large(ctx, field)
			case "normal":
				return ec.fieldContext_MTG_Image_normal(ctx, field)
			case "PNG":
				return ec.fieldContext_MTG_Image_PNG(ctx, field)
			case "small":
				return ec.fieldContext_MTG_Image_small(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MTG_Image", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardPackage_ID(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardPackage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardPackage_ID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardPackage_ID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardPackage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardPackage_name(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardPackage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardPackage_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardPackage_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardPackage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardPackage_isPublic(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardPackage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardPackage_isPublic(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsPublic, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardPackage_isPublic(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardPackage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardPackage_ownerID(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardPackage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardPackage_ownerID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OwnerID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOID2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardPackage_ownerID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardPackage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardPackage_cards(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardPackage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardPackage_cards(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cards, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.MtgCardPackageCard)
	fc.Result = res
	return ec.marshalNMTG_CardPackageCard2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgCardPackageCardᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardPackage_cards(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardPackage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "card":
				return ec.fieldContext_MTG_CardPackageCard_card(ctx, field)
			case "selectedVersionID":
				return ec.fieldContext_MTG_CardPackageCard_selectedVersionID(ctx, field)
			case "count":
				return ec.fieldContext_MTG_CardPackageCard_count(ctx, field)
			case "mainOrSide":
				return ec.fieldContext_MTG_CardPackageCard_mainOrSide(ctx, field)
			case "position":
				return ec.fieldContext_MTG_CardPackageCard_position(ctx, field)
			case "phantoms":
				return ec.fieldContext_MTG_CardPackageCard_phantoms(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MTG_CardPackageCard", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardPackage_zones(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardPackage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardPackage_zones(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Zones, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.FlowZone)
	fc.Result = res
	return ec.marshalNFlowZone2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐFlowZoneᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardPackage_zones(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardPackage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ID":
				return ec.fieldContext_FlowZone_ID(ctx, field)
			case "name":
				return ec.fieldContext_FlowZone_name(ctx, field)
			case "position":
				return ec.fieldContext_FlowZone_position(ctx, field)
			case "width":
				return ec.fieldContext_FlowZone_width(ctx, field)
			case "height":
				return ec.fieldContext_FlowZone_height(ctx, field)
			case "cardChildren":
				return ec.fieldContext_FlowZone_cardChildren(ctx, field)
			case "zoneChildren":
				return ec.fieldContext_FlowZone_zoneChildren(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FlowZone", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardPackageCard_card(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardPackageCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardPackageCard_card(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Card, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.MtgCard)
	fc.Result = res
	return ec.marshalNMTG_Card2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgCard(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardPackageCard_card(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardPackageCard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ID":
				return ec.fieldContext_MTG_Card_ID(ctx, field)
			case "layout":
				return ec.fieldContext_MTG_Card_layout(ctx, field)
			case "CMC":
				return ec.fieldContext_MTG_Card_CMC(ctx, field)
			case "colorIdentity":
				return ec.fieldContext_MTG_Card_colorIdentity(ctx, field)
			case "colorIndicator":
				return ec.fieldContext_MTG_Card_colorIndicator(ctx, field)
			case "colors":
				return ec.fieldContext_MTG_Card_colors(ctx, field)
			case "EDHRecRank":
				return ec.fieldContext_MTG_Card_EDHRecRank(ctx, field)
			case "keywords":
				return ec.fieldContext_MTG_Card_keywords(ctx, field)
			case "loyalty":
				return ec.fieldContext_MTG_Card_loyalty(ctx, field)
			case "manaCost":
				return ec.fieldContext_MTG_Card_manaCost(ctx, field)
			case "name":
				return ec.fieldContext_MTG_Card_name(ctx, field)
			case "oracleText":
				return ec.fieldContext_MTG_Card_oracleText(ctx, field)
			case "power":
				return ec.fieldContext_MTG_Card_power(ctx, field)
			case "producedMana":
				return ec.fieldContext_MTG_Card_producedMana(ctx, field)
			case "toughness":
				return ec.fieldContext_MTG_Card_toughness(ctx, field)
			case "typeLine":
				return ec.fieldContext_MTG_Card_typeLine(ctx, field)
			case "versions":
				return ec.fieldContext_MTG_Card_versions(ctx, field)
			case "myRating":
				return ec.fieldContext_MTG_Card_myRating(ctx, field)
			case "cardTags":
				return ec.fieldContext_MTG_Card_cardTags(ctx, field)
			case "deckTags":
				return ec.fieldContext_MTG_Card_deckTags(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MTG_Card", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardPackageCard_selectedVersionID(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardPackageCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardPackageCard_selectedVersionID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SelectedVersionID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardPackageCard_selectedVersionID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardPackageCard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardPackageCard_count(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardPackageCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardPackageCard_count(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardPackageCard_count(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardPackageCard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardPackageCard_mainOrSide(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardPackageCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardPackageCard_mainOrSide(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MainOrSide, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.MainOrSide)
	fc.Result = res
	return ec.marshalNMainOrSide2magicᚑhelperᚋgraphᚋmodelᚐMainOrSide(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardPackageCard_mainOrSide(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardPackageCard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type MainOrSide does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardPackageCard_position(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardPackageCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardPackageCard_position(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Position, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Position)
	fc.Result = res
	return ec.marshalNPosition2ᚖmagicᚑhelperᚋgraphᚋmodelᚐPosition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardPackageCard_position(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardPackageCard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "x":
				return ec.fieldContext_Position_x(ctx, field)
			case "y":
				return ec.fieldContext_Position_y(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Position", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardPackageCard_phantoms(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardPackageCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardPackageCard_phantoms(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Phantoms, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Phantom)
	fc.Result = res
	return ec.marshalNPhantom2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐPhantomᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardPackageCard_phantoms(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardPackageCard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "position":
				return ec.fieldContext_Phantom_position(ctx, field)
			case "ID":
				return ec.fieldContext_Phantom_ID(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Phantom", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardVersion_ID(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardVersion_ID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardVersion_ID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardVersion_isDefault(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardVersion_isDefault(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDefault, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardVersion_isDefault(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardVersion_isAlchemy(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardVersion_isAlchemy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsAlchemy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardVersion_isAlchemy(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardVersion_artist(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardVersion_artist(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Artist, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardVersion_artist(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardVersion_lang(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardVersion_lang(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Lang, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardVersion_lang(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardVersion_flavorName(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardVersion_flavorName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FlavorName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardVersion_flavorName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardVersion_flavorText(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardVersion_flavorText(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FlavorText, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardVersion_flavorText(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardVersion_cardFaces(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardVersion_cardFaces(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CardFaces, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.MtgCardFace)
	fc.Result = res
	return ec.marshalOMTG_CardFace2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgCardFaceᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardVersion_cardFaces(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "artist":
				return ec.fieldContext_MTG_CardFace_artist(ctx, field)
			case "CMC":
				return ec.fieldContext_MTG_CardFace_CMC(ctx, field)
			case "colorIndicator":
				return ec.fieldContext_MTG_CardFace_colorIndicator(ctx, field)
			case "colors":
				return ec.fieldContext_MTG_CardFace_colors(ctx, field)
			case "flavorText":
				return ec.fieldContext_MTG_CardFace_flavorText(ctx, field)
			case "imageUris":
				return ec.fieldContext_MTG_CardFace_imageUris(ctx, field)
			case "layout":
				return ec.fieldContext_MTG_CardFace_layout(ctx, field)
			case "loyalty":
				return ec.fieldContext_MTG_CardFace_loyalty(ctx, field)
			case "manaCost":
				return ec.fieldContext_MTG_CardFace_manaCost(ctx, field)
			case "name":
				return ec.fieldContext_MTG_CardFace_name(ctx, field)
			case "oracleText":
				return ec.fieldContext_MTG_CardFace_oracleText(ctx, field)
			case "power":
				return ec.fieldContext_MTG_CardFace_power(ctx, field)
			case "toughness":
				return ec.fieldContext_MTG_CardFace_toughness(ctx, field)
			case "typeLine":
				return ec.fieldContext_MTG_CardFace_typeLine(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MTG_CardFace", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardVersion_legalities(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardVersion_legalities(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Legalities, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(map[string]any)
	fc.Result = res
	return ec.marshalNMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardVersion_legalities(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardVersion_games(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardVersion_games(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Games, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.MtgGame)
	fc.Result = res
	return ec.marshalNMTG_Game2ᚕmagicᚑhelperᚋgraphᚋmodelᚐMtgGameᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardVersion_games(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type MTG_Game does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardVersion_imageUris(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardVersion_imageUris(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ImageUris, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.MtgImage)
	fc.Result = res
	return ec.marshalOMTG_Image2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgImage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardVersion_imageUris(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "artCrop":
				return ec.fieldContext_MTG_Image_artCrop(ctx, field)
			case "borderCrop":
				return ec.fieldContext_MTG_Image_borderCrop(ctx, field)
			case "large":
				return ec.fieldContext_MTG_Image_large(ctx, field)
			case "normal":
				return ec.fieldContext_MTG_Image_normal(ctx, field)
			case "PNG":
				return ec.fieldContext_MTG_Image_PNG(ctx, field)
			case "small":
				return ec.fieldContext_MTG_Image_small(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MTG_Image", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardVersion_printedName(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardVersion_printedName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PrintedName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardVersion_printedName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardVersion_rarity(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardVersion_rarity(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Rarity, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.MtgRarity)
	fc.Result = res
	return ec.marshalNMTG_Rarity2magicᚑhelperᚋgraphᚋmodelᚐMtgRarity(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardVersion_rarity(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type MTG_Rarity does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardVersion_releasedAt(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardVersion_releasedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ReleasedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardVersion_releasedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardVersion_reprint(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardVersion_reprint(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Reprint, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardVersion_reprint(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardVersion_setName(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardVersion_setName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SetName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardVersion_setName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardVersion_setType(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardVersion_setType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SetType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardVersion_setType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardVersion_set(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardVersion_set(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Set, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardVersion_set(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardVersion_setID(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardVersion_setID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SetID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardVersion_setID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardVersion_variation(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardVersion_variation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Variation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardVersion_variation(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardVersion_variationOf(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardVersion_variationOf(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.VariationOf, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardVersion_variationOf(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardVersion_Dashboard_ID(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardVersionDashboard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardVersion_Dashboard_ID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardVersion_Dashboard_ID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardVersion_Dashboard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardVersion_Dashboard_isDefault(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardVersionDashboard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardVersion_Dashboard_isDefault(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDefault, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardVersion_Dashboard_isDefault(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardVersion_Dashboard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardVersion_Dashboard_isAlchemy(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardVersionDashboard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardVersion_Dashboard_isAlchemy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsAlchemy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardVersion_Dashboard_isAlchemy(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardVersion_Dashboard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardVersion_Dashboard_cardFaces(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardVersionDashboard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardVersion_Dashboard_cardFaces(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CardFaces, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.MtgCardFaceDashboard)
	fc.Result = res
	return ec.marshalNMTG_CardFace_Dashboard2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgCardFaceDashboardᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardVersion_Dashboard_cardFaces(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardVersion_Dashboard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "imageUris":
				return ec.fieldContext_MTG_CardFace_Dashboard_imageUris(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MTG_CardFace_Dashboard", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardVersion_Dashboard_imageUris(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardVersionDashboard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardVersion_Dashboard_imageUris(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ImageUris, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.MtgImage)
	fc.Result = res
	return ec.marshalOMTG_Image2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgImage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardVersion_Dashboard_imageUris(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardVersion_Dashboard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "artCrop":
				return ec.fieldContext_MTG_Image_artCrop(ctx, field)
			case "borderCrop":
				return ec.fieldContext_MTG_Image_borderCrop(ctx, field)
			case "large":
				return ec.fieldContext_MTG_Image_large(ctx, field)
			case "normal":
				return ec.fieldContext_MTG_Image_normal(ctx, field)
			case "PNG":
				return ec.fieldContext_MTG_Image_PNG(ctx, field)
			case "small":
				return ec.fieldContext_MTG_Image_small(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MTG_Image", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Card_Dashboard_ID(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardDashboard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Card_Dashboard_ID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Card_Dashboard_ID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Card_Dashboard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Card_Dashboard_versions(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardDashboard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Card_Dashboard_versions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Versions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.MtgCardVersionDashboard)
	fc.Result = res
	return ec.marshalNMTG_CardVersion_Dashboard2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgCardVersionDashboardᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Card_Dashboard_versions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Card_Dashboard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ID":
				return ec.fieldContext_MTG_CardVersion_Dashboard_ID(ctx, field)
			case "isDefault":
				return ec.fieldContext_MTG_CardVersion_Dashboard_isDefault(ctx, field)
			case "isAlchemy":
				return ec.fieldContext_MTG_CardVersion_Dashboard_isAlchemy(ctx, field)
			case "cardFaces":
				return ec.fieldContext_MTG_CardVersion_Dashboard_cardFaces(ctx, field)
			case "imageUris":
				return ec.fieldContext_MTG_CardVersion_Dashboard_imageUris(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MTG_CardVersion_Dashboard", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Deck_ID(ctx context.Context, field graphql.CollectedField, obj *model.MtgDeck) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Deck_ID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Deck_ID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Deck",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Deck_name(ctx context.Context, field graphql.CollectedField, obj *model.MtgDeck) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Deck_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Deck_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Deck",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Deck_cardFrontImage(ctx context.Context, field graphql.CollectedField, obj *model.MtgDeck) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Deck_cardFrontImage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CardFrontImage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.MtgDeckCardFrontImage)
	fc.Result = res
	return ec.marshalOMTG_Deck_CardFrontImage2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgDeckCardFrontImage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Deck_cardFrontImage(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Deck",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cardID":
				return ec.fieldContext_MTG_Deck_CardFrontImage_cardID(ctx, field)
			case "versionID":
				return ec.fieldContext_MTG_Deck_CardFrontImage_versionID(ctx, field)
			case "image":
				return ec.fieldContext_MTG_Deck_CardFrontImage_image(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MTG_Deck_CardFrontImage", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Deck_cards(ctx context.Context, field graphql.CollectedField, obj *model.MtgDeck) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Deck_cards(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cards, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.MtgDeckCard)
	fc.Result = res
	return ec.marshalNMTG_DeckCard2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgDeckCardᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Deck_cards(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Deck",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "card":
				return ec.fieldContext_MTG_DeckCard_card(ctx, field)
			case "selectedVersionID":
				return ec.fieldContext_MTG_DeckCard_selectedVersionID(ctx, field)
			case "count":
				return ec.fieldContext_MTG_DeckCard_count(ctx, field)
			case "position":
				return ec.fieldContext_MTG_DeckCard_position(ctx, field)
			case "mainOrSide":
				return ec.fieldContext_MTG_DeckCard_mainOrSide(ctx, field)
			case "deckCardType":
				return ec.fieldContext_MTG_DeckCard_deckCardType(ctx, field)
			case "phantoms":
				return ec.fieldContext_MTG_DeckCard_phantoms(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MTG_DeckCard", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Deck_zones(ctx context.Context, field graphql.CollectedField, obj *model.MtgDeck) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Deck_zones(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Zones, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.FlowZone)
	fc.Result = res
	return ec.marshalNFlowZone2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐFlowZoneᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Deck_zones(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Deck",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ID":
				return ec.fieldContext_FlowZone_ID(ctx, field)
			case "name":
				return ec.fieldContext_FlowZone_name(ctx, field)
			case "position":
				return ec.fieldContext_FlowZone_position(ctx, field)
			case "width":
				return ec.fieldContext_FlowZone_width(ctx, field)
			case "height":
				return ec.fieldContext_FlowZone_height(ctx, field)
			case "cardChildren":
				return ec.fieldContext_FlowZone_cardChildren(ctx, field)
			case "zoneChildren":
				return ec.fieldContext_FlowZone_zoneChildren(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FlowZone", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Deck_ignoredCards(ctx context.Context, field graphql.CollectedField, obj *model.MtgDeck) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Deck_ignoredCards(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IgnoredCards, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Deck_ignoredCards(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Deck",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_DeckCard_card(ctx context.Context, field graphql.CollectedField, obj *model.MtgDeckCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_DeckCard_card(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Card, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.MtgCard)
	fc.Result = res
	return ec.marshalNMTG_Card2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgCard(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_DeckCard_card(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_DeckCard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ID":
				return ec.fieldContext_MTG_Card_ID(ctx, field)
			case "layout":
				return ec.fieldContext_MTG_Card_layout(ctx, field)
			case "CMC":
				return ec.fieldContext_MTG_Card_CMC(ctx, field)
			case "colorIdentity":
				return ec.fieldContext_MTG_Card_colorIdentity(ctx, field)
			case "colorIndicator":
				return ec.fieldContext_MTG_Card_colorIndicator(ctx, field)
			case "colors":
				return ec.fieldContext_MTG_Card_colors(ctx, field)
			case "EDHRecRank":
				return ec.fieldContext_MTG_Card_EDHRecRank(ctx, field)
			case "keywords":
				return ec.fieldContext_MTG_Card_keywords(ctx, field)
			case "loyalty":
				return ec.fieldContext_MTG_Card_loyalty(ctx, field)
			case "manaCost":
				return ec.fieldContext_MTG_Card_manaCost(ctx, field)
			case "name":
				return ec.fieldContext_MTG_Card_name(ctx, field)
			case "oracleText":
				return ec.fieldContext_MTG_Card_oracleText(ctx, field)
			case "power":
				return ec.fieldContext_MTG_Card_power(ctx, field)
			case "producedMana":
				return ec.fieldContext_MTG_Card_producedMana(ctx, field)
			case "toughness":
				return ec.fieldContext_MTG_Card_toughness(ctx, field)
			case "typeLine":
				return ec.fieldContext_MTG_Card_typeLine(ctx, field)
			case "versions":
				return ec.fieldContext_MTG_Card_versions(ctx, field)
			case "myRating":
				return ec.fieldContext_MTG_Card_myRating(ctx, field)
			case "cardTags":
				return ec.fieldContext_MTG_Card_cardTags(ctx, field)
			case "deckTags":
				return ec.fieldContext_MTG_Card_deckTags(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MTG_Card", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_DeckCard_selectedVersionID(ctx context.Context, field graphql.CollectedField, obj *model.MtgDeckCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_DeckCard_selectedVersionID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SelectedVersionID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_DeckCard_selectedVersionID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_DeckCard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_DeckCard_count(ctx context.Context, field graphql.CollectedField, obj *model.MtgDeckCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_DeckCard_count(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_DeckCard_count(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_DeckCard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_DeckCard_position(ctx context.Context, field graphql.CollectedField, obj *model.MtgDeckCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_DeckCard_position(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Position, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Position)
	fc.Result = res
	return ec.marshalNPosition2ᚖmagicᚑhelperᚋgraphᚋmodelᚐPosition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_DeckCard_position(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_DeckCard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "x":
				return ec.fieldContext_Position_x(ctx, field)
			case "y":
				return ec.fieldContext_Position_y(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Position", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_DeckCard_mainOrSide(ctx context.Context, field graphql.CollectedField, obj *model.MtgDeckCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_DeckCard_mainOrSide(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MainOrSide, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.MainOrSide)
	fc.Result = res
	return ec.marshalNMainOrSide2magicᚑhelperᚋgraphᚋmodelᚐMainOrSide(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_DeckCard_mainOrSide(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_DeckCard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type MainOrSide does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_DeckCard_deckCardType(ctx context.Context, field graphql.CollectedField, obj *model.MtgDeckCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_DeckCard_deckCardType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeckCardType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.MtgDeckCardType)
	fc.Result = res
	return ec.marshalNMTG_DeckCardType2magicᚑhelperᚋgraphᚋmodelᚐMtgDeckCardType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_DeckCard_deckCardType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_DeckCard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type MTG_DeckCardType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_DeckCard_phantoms(ctx context.Context, field graphql.CollectedField, obj *model.MtgDeckCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_DeckCard_phantoms(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Phantoms, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Phantom)
	fc.Result = res
	return ec.marshalNPhantom2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐPhantomᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_DeckCard_phantoms(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_DeckCard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "position":
				return ec.fieldContext_Phantom_position(ctx, field)
			case "ID":
				return ec.fieldContext_Phantom_ID(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Phantom", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_DeckCard_Dashboard_card(ctx context.Context, field graphql.CollectedField, obj *model.MtgDeckCardDashboard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_DeckCard_Dashboard_card(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Card, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.MtgCardDashboard)
	fc.Result = res
	return ec.marshalNMTG_Card_Dashboard2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgCardDashboard(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_DeckCard_Dashboard_card(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_DeckCard_Dashboard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ID":
				return ec.fieldContext_MTG_Card_Dashboard_ID(ctx, field)
			case "versions":
				return ec.fieldContext_MTG_Card_Dashboard_versions(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MTG_Card_Dashboard", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_DeckCard_Dashboard_selectedVersionID(ctx context.Context, field graphql.CollectedField, obj *model.MtgDeckCardDashboard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_DeckCard_Dashboard_selectedVersionID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SelectedVersionID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_DeckCard_Dashboard_selectedVersionID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_DeckCard_Dashboard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_DeckDashboard_ID(ctx context.Context, field graphql.CollectedField, obj *model.MtgDeckDashboard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_DeckDashboard_ID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_DeckDashboard_ID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_DeckDashboard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_DeckDashboard_name(ctx context.Context, field graphql.CollectedField, obj *model.MtgDeckDashboard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_DeckDashboard_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_DeckDashboard_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_DeckDashboard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_DeckDashboard_cardFrontImage(ctx context.Context, field graphql.CollectedField, obj *model.MtgDeckDashboard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_DeckDashboard_cardFrontImage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CardFrontImage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.MtgDeckCardFrontImage)
	fc.Result = res
	return ec.marshalOMTG_Deck_CardFrontImage2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgDeckCardFrontImage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_DeckDashboard_cardFrontImage(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_DeckDashboard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cardID":
				return ec.fieldContext_MTG_Deck_CardFrontImage_cardID(ctx, field)
			case "versionID":
				return ec.fieldContext_MTG_Deck_CardFrontImage_versionID(ctx, field)
			case "image":
				return ec.fieldContext_MTG_Deck_CardFrontImage_image(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MTG_Deck_CardFrontImage", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_DeckDashboard_cards(ctx context.Context, field graphql.CollectedField, obj *model.MtgDeckDashboard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_DeckDashboard_cards(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cards, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.MtgDeckCardDashboard)
	fc.Result = res
	return ec.marshalNMTG_DeckCard_Dashboard2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgDeckCardDashboardᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_DeckDashboard_cards(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_DeckDashboard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "card":
				return ec.fieldContext_MTG_DeckCard_Dashboard_card(ctx, field)
			case "selectedVersionID":
				return ec.fieldContext_MTG_DeckCard_Dashboard_selectedVersionID(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MTG_DeckCard_Dashboard", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Deck_CardFrontImage_cardID(ctx context.Context, field graphql.CollectedField, obj *model.MtgDeckCardFrontImage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Deck_CardFrontImage_cardID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CardID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Deck_CardFrontImage_cardID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Deck_CardFrontImage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Deck_CardFrontImage_versionID(ctx context.Context, field graphql.CollectedField, obj *model.MtgDeckCardFrontImage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Deck_CardFrontImage_versionID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.VersionID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Deck_CardFrontImage_versionID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Deck_CardFrontImage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Deck_CardFrontImage_image(ctx context.Context, field graphql.CollectedField, obj *model.MtgDeckCardFrontImage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Deck_CardFrontImage_image(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Image, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Deck_CardFrontImage_image(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Deck_CardFrontImage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Filter_CardTypes_cardType(ctx context.Context, field graphql.CollectedField, obj *model.MtgFilterCardTypes) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Filter_CardTypes_cardType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CardType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Filter_CardTypes_cardType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Filter_CardTypes",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Filter_CardTypes_subtypes(ctx context.Context, field graphql.CollectedField, obj *model.MtgFilterCardTypes) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Filter_CardTypes_subtypes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Subtypes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Filter_CardTypes_subtypes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Filter_CardTypes",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Filter_Entries_types(ctx context.Context, field graphql.CollectedField, obj *model.MtgFilterEntries) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Filter_Entries_types(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.MtgFilterCardTypes)
	fc.Result = res
	return ec.marshalNMTG_Filter_CardTypes2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterCardTypesᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Filter_Entries_types(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Filter_Entries",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cardType":
				return ec.fieldContext_MTG_Filter_CardTypes_cardType(ctx, field)
			case "subtypes":
				return ec.fieldContext_MTG_Filter_CardTypes_subtypes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MTG_Filter_CardTypes", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Filter_Entries_expansions(ctx context.Context, field graphql.CollectedField, obj *model.MtgFilterEntries) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Filter_Entries_expansions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Expansions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.MtgFilterExpansion)
	fc.Result = res
	return ec.marshalNMTG_Filter_Expansion2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterExpansionᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Filter_Entries_expansions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Filter_Entries",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "set":
				return ec.fieldContext_MTG_Filter_Expansion_set(ctx, field)
			case "setName":
				return ec.fieldContext_MTG_Filter_Expansion_setName(ctx, field)
			case "releasedAt":
				return ec.fieldContext_MTG_Filter_Expansion_releasedAt(ctx, field)
			case "imageURL":
				return ec.fieldContext_MTG_Filter_Expansion_imageURL(ctx, field)
			case "setType":
				return ec.fieldContext_MTG_Filter_Expansion_setType(ctx, field)
			case "games":
				return ec.fieldContext_MTG_Filter_Expansion_games(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MTG_Filter_Expansion", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Filter_Entries_legality(ctx context.Context, field graphql.CollectedField, obj *model.MtgFilterEntries) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Filter_Entries_legality(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Legality, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.MtgFilterLegality)
	fc.Result = res
	return ec.marshalNMTG_Filter_Legality2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterLegality(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Filter_Entries_legality(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Filter_Entries",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "formats":
				return ec.fieldContext_MTG_Filter_Legality_formats(ctx, field)
			case "legalityValues":
				return ec.fieldContext_MTG_Filter_Legality_legalityValues(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MTG_Filter_Legality", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Filter_Entries_layouts(ctx context.Context, field graphql.CollectedField, obj *model.MtgFilterEntries) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Filter_Entries_layouts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Layouts, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.MtgLayout)
	fc.Result = res
	return ec.marshalNMTG_Layout2ᚕmagicᚑhelperᚋgraphᚋmodelᚐMtgLayoutᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Filter_Entries_layouts(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Filter_Entries",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type MTG_Layout does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Filter_Expansion_set(ctx context.Context, field graphql.CollectedField, obj *model.MtgFilterExpansion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Filter_Expansion_set(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Set, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Filter_Expansion_set(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Filter_Expansion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Filter_Expansion_setName(ctx context.Context, field graphql.CollectedField, obj *model.MtgFilterExpansion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Filter_Expansion_setName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SetName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Filter_Expansion_setName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Filter_Expansion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Filter_Expansion_releasedAt(ctx context.Context, field graphql.CollectedField, obj *model.MtgFilterExpansion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Filter_Expansion_releasedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ReleasedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Filter_Expansion_releasedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Filter_Expansion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Filter_Expansion_imageURL(ctx context.Context, field graphql.CollectedField, obj *model.MtgFilterExpansion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Filter_Expansion_imageURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ImageURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Filter_Expansion_imageURL(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Filter_Expansion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Filter_Expansion_setType(ctx context.Context, field graphql.CollectedField, obj *model.MtgFilterExpansion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Filter_Expansion_setType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SetType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Filter_Expansion_setType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Filter_Expansion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Filter_Expansion_games(ctx context.Context, field graphql.CollectedField, obj *model.MtgFilterExpansion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Filter_Expansion_games(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Games, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.MtgGame)
	fc.Result = res
	return ec.marshalNMTG_Game2ᚕmagicᚑhelperᚋgraphᚋmodelᚐMtgGameᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Filter_Expansion_games(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Filter_Expansion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type MTG_Game does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Filter_Legality_formats(ctx context.Context, field graphql.CollectedField, obj *model.MtgFilterLegality) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Filter_Legality_formats(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Formats, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Filter_Legality_formats(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Filter_Legality",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Filter_Legality_legalityValues(ctx context.Context, field graphql.CollectedField, obj *model.MtgFilterLegality) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Filter_Legality_legalityValues(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LegalityValues, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Filter_Legality_legalityValues(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Filter_Legality",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Filter_Search_pagedCards(ctx context.Context, field graphql.CollectedField, obj *model.MtgFilterSearch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Filter_Search_pagedCards(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PagedCards, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.MtgCard)
	fc.Result = res
	return ec.marshalNMTG_Card2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgCardᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Filter_Search_pagedCards(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Filter_Search",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ID":
				return ec.fieldContext_MTG_Card_ID(ctx, field)
			case "layout":
				return ec.fieldContext_MTG_Card_layout(ctx, field)
			case "CMC":
				return ec.fieldContext_MTG_Card_CMC(ctx, field)
			case "colorIdentity":
				return ec.fieldContext_MTG_Card_colorIdentity(ctx, field)
			case "colorIndicator":
				return ec.fieldContext_MTG_Card_colorIndicator(ctx, field)
			case "colors":
				return ec.fieldContext_MTG_Card_colors(ctx, field)
			case "EDHRecRank":
				return ec.fieldContext_MTG_Card_EDHRecRank(ctx, field)
			case "keywords":
				return ec.fieldContext_MTG_Card_keywords(ctx, field)
			case "loyalty":
				return ec.fieldContext_MTG_Card_loyalty(ctx, field)
			case "manaCost":
				return ec.fieldContext_MTG_Card_manaCost(ctx, field)
			case "name":
				return ec.fieldContext_MTG_Card_name(ctx, field)
			case "oracleText":
				return ec.fieldContext_MTG_Card_oracleText(ctx, field)
			case "power":
				return ec.fieldContext_MTG_Card_power(ctx, field)
			case "producedMana":
				return ec.fieldContext_MTG_Card_producedMana(ctx, field)
			case "toughness":
				return ec.fieldContext_MTG_Card_toughness(ctx, field)
			case "typeLine":
				return ec.fieldContext_MTG_Card_typeLine(ctx, field)
			case "versions":
				return ec.fieldContext_MTG_Card_versions(ctx, field)
			case "myRating":
				return ec.fieldContext_MTG_Card_myRating(ctx, field)
			case "cardTags":
				return ec.fieldContext_MTG_Card_cardTags(ctx, field)
			case "deckTags":
				return ec.fieldContext_MTG_Card_deckTags(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MTG_Card", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Filter_Search_totalCount(ctx context.Context, field graphql.CollectedField, obj *model.MtgFilterSearch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Filter_Search_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Filter_Search_totalCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Filter_Search",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Image_artCrop(ctx context.Context, field graphql.CollectedField, obj *model.MtgImage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Image_artCrop(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ArtCrop, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Image_artCrop(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Image",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Image_borderCrop(ctx context.Context, field graphql.CollectedField, obj *model.MtgImage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Image_borderCrop(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BorderCrop, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Image_borderCrop(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Image",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Image_large(ctx context.Context, field graphql.CollectedField, obj *model.MtgImage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Image_large(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Large, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Image_large(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Image",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Image_normal(ctx context.Context, field graphql.CollectedField, obj *model.MtgImage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Image_normal(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Normal, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Image_normal(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Image",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Image_PNG(ctx context.Context, field graphql.CollectedField, obj *model.MtgImage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Image_PNG(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Png, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Image_PNG(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Image",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Image_small(ctx context.Context, field graphql.CollectedField, obj *model.MtgImage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Image_small(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Small, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Image_small(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Image",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createMTGDeck(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createMTGDeck(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateMTGDeck(rctx, fc.Args["input"].(model.MtgCreateDeckInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Response)
	fc.Result = res
	return ec.marshalNResponse2ᚖmagicᚑhelperᚋgraphᚋmodelᚐResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createMTGDeck(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "status":
				return ec.fieldContext_Response_status(ctx, field)
			case "message":
				return ec.fieldContext_Response_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Response", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createMTGDeck_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteMTGDeck(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteMTGDeck(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteMTGDeck(rctx, fc.Args["input"].(model.MtgDeleteDeckInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Response)
	fc.Result = res
	return ec.marshalNResponse2ᚖmagicᚑhelperᚋgraphᚋmodelᚐResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteMTGDeck(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "status":
				return ec.fieldContext_Response_status(ctx, field)
			case "message":
				return ec.fieldContext_Response_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Response", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteMTGDeck_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateMTGDeck(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateMTGDeck(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateMTGDeck(rctx, fc.Args["input"].(model.MtgUpdateDeckInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Response)
	fc.Result = res
	return ec.marshalNResponse2ᚖmagicᚑhelperᚋgraphᚋmodelᚐResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateMTGDeck(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "status":
				return ec.fieldContext_Response_status(ctx, field)
			case "message":
				return ec.fieldContext_Response_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Response", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateMTGDeck_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_saveMTGDeckAsCopy(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_saveMTGDeckAsCopy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().SaveMTGDeckAsCopy(rctx, fc.Args["input"].(model.MtgUpdateDeckInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Response)
	fc.Result = res
	return ec.marshalNResponse2ᚖmagicᚑhelperᚋgraphᚋmodelᚐResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_saveMTGDeckAsCopy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "status":
				return ec.fieldContext_Response_status(ctx, field)
			case "message":
				return ec.fieldContext_Response_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Response", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_saveMTGDeckAsCopy_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createMTGCardPackage(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createMTGCardPackage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateMTGCardPackage(rctx, fc.Args["input"].(model.MtgCreateCardPackageInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Response)
	fc.Result = res
	return ec.marshalNResponse2ᚖmagicᚑhelperᚋgraphᚋmodelᚐResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createMTGCardPackage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "status":
				return ec.fieldContext_Response_status(ctx, field)
			case "message":
				return ec.fieldContext_Response_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Response", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createMTGCardPackage_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteMTGCardPackage(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteMTGCardPackage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteMTGCardPackage(rctx, fc.Args["input"].(model.MtgDeleteCardPackageInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Response)
	fc.Result = res
	return ec.marshalNResponse2ᚖmagicᚑhelperᚋgraphᚋmodelᚐResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteMTGCardPackage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "status":
				return ec.fieldContext_Response_status(ctx, field)
			case "message":
				return ec.fieldContext_Response_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Response", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteMTGCardPackage_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_editMTGCardPackageName(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_editMTGCardPackageName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().EditMTGCardPackageName(rctx, fc.Args["input"].(model.MtgEditCardPackageNameInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Response)
	fc.Result = res
	return ec.marshalNResponse2ᚖmagicᚑhelperᚋgraphᚋmodelᚐResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_editMTGCardPackageName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "status":
				return ec.fieldContext_Response_status(ctx, field)
			case "message":
				return ec.fieldContext_Response_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Response", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_editMTGCardPackageName_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_editMTGCardPackageVisibility(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_editMTGCardPackageVisibility(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().EditMTGCardPackageVisibility(rctx, fc.Args["input"].(model.MtgEditCardPackageVisibilityInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Response)
	fc.Result = res
	return ec.marshalNResponse2ᚖmagicᚑhelperᚋgraphᚋmodelᚐResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_editMTGCardPackageVisibility(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "status":
				return ec.fieldContext_Response_status(ctx, field)
			case "message":
				return ec.fieldContext_Response_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Response", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_editMTGCardPackageVisibility_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_addMTGCardToCardPackage(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_addMTGCardToCardPackage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().AddMTGCardToCardPackage(rctx, fc.Args["input"].(model.MtgAddCardToCardPackageInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Response)
	fc.Result = res
	return ec.marshalNResponse2ᚖmagicᚑhelperᚋgraphᚋmodelᚐResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_addMTGCardToCardPackage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "status":
				return ec.fieldContext_Response_status(ctx, field)
			case "message":
				return ec.fieldContext_Response_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Response", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_addMTGCardToCardPackage_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_removeMTGCardFromCardPackage(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_removeMTGCardFromCardPackage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().RemoveMTGCardFromCardPackage(rctx, fc.Args["input"].(model.MtgRemoveCardFromCardPackageInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Response)
	fc.Result = res
	return ec.marshalNResponse2ᚖmagicᚑhelperᚋgraphᚋmodelᚐResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_removeMTGCardFromCardPackage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "status":
				return ec.fieldContext_Response_status(ctx, field)
			case "message":
				return ec.fieldContext_Response_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Response", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_removeMTGCardFromCardPackage_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createTag(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createTag(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateTag(rctx, fc.Args["input"].(model.CreateTagInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Response)
	fc.Result = res
	return ec.marshalNResponse2ᚖmagicᚑhelperᚋgraphᚋmodelᚐResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createTag(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "status":
				return ec.fieldContext_Response_status(ctx, field)
			case "message":
				return ec.fieldContext_Response_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Response", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createTag_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateTag(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateTag(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateTag(rctx, fc.Args["input"].(model.UpdateTagInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Response)
	fc.Result = res
	return ec.marshalNResponse2ᚖmagicᚑhelperᚋgraphᚋmodelᚐResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateTag(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "status":
				return ec.fieldContext_Response_status(ctx, field)
			case "message":
				return ec.fieldContext_Response_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Response", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateTag_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteTag(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteTag(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteTag(rctx, fc.Args["tagID"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Response)
	fc.Result = res
	return ec.marshalNResponse2ᚖmagicᚑhelperᚋgraphᚋmodelᚐResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteTag(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "status":
				return ec.fieldContext_Response_status(ctx, field)
			case "message":
				return ec.fieldContext_Response_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Response", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteTag_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_assignTag(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_assignTag(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().AssignTag(rctx, fc.Args["input"].(model.AssignTagInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Response)
	fc.Result = res
	return ec.marshalNResponse2ᚖmagicᚑhelperᚋgraphᚋmodelᚐResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_assignTag(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "status":
				return ec.fieldContext_Response_status(ctx, field)
			case "message":
				return ec.fieldContext_Response_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Response", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_assignTag_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_unassignTag(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_unassignTag(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UnassignTag(rctx, fc.Args["input"].(model.UnassignTagInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Response)
	fc.Result = res
	return ec.marshalNResponse2ᚖmagicᚑhelperᚋgraphᚋmodelᚐResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_unassignTag(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "status":
				return ec.fieldContext_Response_status(ctx, field)
			case "message":
				return ec.fieldContext_Response_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Response", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_unassignTag_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_rate(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_rate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().Rate(rctx, fc.Args["input"].(model.RateInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Response)
	fc.Result = res
	return ec.marshalNResponse2ᚖmagicᚑhelperᚋgraphᚋmodelᚐResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_rate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "status":
				return ec.fieldContext_Response_status(ctx, field)
			case "message":
				return ec.fieldContext_Response_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Response", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_rate_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_addIgnoredCard(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_addIgnoredCard(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().AddIgnoredCard(rctx, fc.Args["input"].(model.AddIgnoredCardInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Response)
	fc.Result = res
	return ec.marshalNResponse2ᚖmagicᚑhelperᚋgraphᚋmodelᚐResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_addIgnoredCard(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "status":
				return ec.fieldContext_Response_status(ctx, field)
			case "message":
				return ec.fieldContext_Response_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Response", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_addIgnoredCard_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_removeIgnoredCard(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_removeIgnoredCard(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().RemoveIgnoredCard(rctx, fc.Args["input"].(model.RemoveIgnoredCardInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Response)
	fc.Result = res
	return ec.marshalNResponse2ᚖmagicᚑhelperᚋgraphᚋmodelᚐResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_removeIgnoredCard(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "status":
				return ec.fieldContext_Response_status(ctx, field)
			case "message":
				return ec.fieldContext_Response_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Response", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_removeIgnoredCard_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_adminRetryImport(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_adminRetryImport(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().AdminRetryImport(rctx, fc.Args["input"].(model.AdminImportActionInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Response)
	fc.Result = res
	return ec.marshalNResponse2ᚖmagicᚑhelperᚋgraphᚋmodelᚐResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_adminRetryImport(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "status":
				return ec.fieldContext_Response_status(ctx, field)
			case "message":
				return ec.fieldContext_Response_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Response", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_adminRetryImport_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_adminBackfillImport(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_adminBackfillImport(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().AdminBackfillImport(rctx, fc.Args["input"].(model.AdminImportActionInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Response)
	fc.Result = res
	return ec.marshalNResponse2ᚖmagicᚑhelperᚋgraphᚋmodelᚐResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_adminBackfillImport(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "status":
				return ec.fieldContext_Response_status(ctx, field)
			case "message":
				return ec.fieldContext_Response_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Response", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_adminBackfillImport_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Phantom_position(ctx context.Context, field graphql.CollectedField, obj *model.Phantom) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Phantom_position(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Position, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Position)
	fc.Result = res
	return ec.marshalNPosition2ᚖmagicᚑhelperᚋgraphᚋmodelᚐPosition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Phantom_position(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Phantom",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "x":
				return ec.fieldContext_Position_x(ctx, field)
			case "y":
				return ec.fieldContext_Position_y(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Position", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Phantom_ID(ctx context.Context, field graphql.CollectedField, obj *model.Phantom) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Phantom_ID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Phantom_ID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Phantom",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Position_x(ctx context.Context, field graphql.CollectedField, obj *model.Position) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Position_x(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.X, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Position_x(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Position",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Position_y(ctx context.Context, field graphql.CollectedField, obj *model.Position) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Position_y(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Y, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Position_y(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Position",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_getMTGCards(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getMTGCards(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GetMTGCards(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.MtgCard)
	fc.Result = res
	return ec.marshalNMTG_Card2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgCardᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getMTGCards(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ID":
				return ec.fieldContext_MTG_Card_ID(ctx, field)
			case "layout":
				return ec.fieldContext_MTG_Card_layout(ctx, field)
			case "CMC":
				return ec.fieldContext_MTG_Card_CMC(ctx, field)
			case "colorIdentity":
				return ec.fieldContext_MTG_Card_colorIdentity(ctx, field)
			case "colorIndicator":
				return ec.fieldContext_MTG_Card_colorIndicator(ctx, field)
			case "colors":
				return ec.fieldContext_MTG_Card_colors(ctx, field)
			case "EDHRecRank":
				return ec.fieldContext_MTG_Card_EDHRecRank(ctx, field)
			case "keywords":
				return ec.fieldContext_MTG_Card_keywords(ctx, field)
			case "loyalty":
				return ec.fieldContext_MTG_Card_loyalty(ctx, field)
			case "manaCost":
				return ec.fieldContext_MTG_Card_manaCost(ctx, field)
			case "name":
				return ec.fieldContext_MTG_Card_name(ctx, field)
			case "oracleText":
				return ec.fieldContext_MTG_Card_oracleText(ctx, field)
			case "power":
				return ec.fieldContext_MTG_Card_power(ctx, field)
			case "producedMana":
				return ec.fieldContext_MTG_Card_producedMana(ctx, field)
			case "toughness":
				return ec.fieldContext_MTG_Card_toughness(ctx, field)
			case "typeLine":
				return ec.fieldContext_MTG_Card_typeLine(ctx, field)
			case "versions":
				return ec.fieldContext_MTG_Card_versions(ctx, field)
			case "myRating":
				return ec.fieldContext_MTG_Card_myRating(ctx, field)
			case "cardTags":
				return ec.fieldContext_MTG_Card_cardTags(ctx, field)
			case "deckTags":
				return ec.fieldContext_MTG_Card_deckTags(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MTG_Card", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_getMTGCardsFiltered(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getMTGCardsFiltered(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GetMTGCardsFiltered(rctx, fc.Args["filter"].(model.MtgFilterSearchInput), fc.Args["pagination"].(model.MtgFilterPaginationInput), fc.Args["sort"].([]*model.MtgFilterSortInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.MtgFilterSearch)
	fc.Result = res
	return ec.marshalNMTG_Filter_Search2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterSearch(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getMTGCardsFiltered(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pagedCards":
				return ec.fieldContext_MTG_Filter_Search_pagedCards(ctx, field)
			case "totalCount":
				return ec.fieldContext_MTG_Filter_Search_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MTG_Filter_Search", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getMTGCardsFiltered_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_getMTGFilters(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getMTGFilters(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GetMTGFilters(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.MtgFilterEntries)
	fc.Result = res
	return ec.marshalNMTG_Filter_Entries2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterEntries(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getMTGFilters(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "types":
				return ec.fieldContext_MTG_Filter_Entries_types(ctx, field)
			case "expansions":
				return ec.fieldContext_MTG_Filter_Entries_expansions(ctx, field)
			case "legality":
				return ec.fieldContext_MTG_Filter_Entries_legality(ctx, field)
			case "layouts":
				return ec.fieldContext_MTG_Filter_Entries_layouts(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MTG_Filter_Entries", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_getMTGDecks(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getMTGDecks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GetMTGDecks(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.MtgDeckDashboard)
	fc.Result = res
	return ec.marshalNMTG_DeckDashboard2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgDeckDashboardᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getMTGDecks(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ID":
				return ec.fieldContext_MTG_DeckDashboard_ID(ctx, field)
			case "name":
				return ec.fieldContext_MTG_DeckDashboard_name(ctx, field)
			case "cardFrontImage":
				return ec.fieldContext_MTG_DeckDashboard_cardFrontImage(ctx, field)
			case "cards":
				return ec.fieldContext_MTG_DeckDashboard_cards(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MTG_DeckDashboard", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_getMTGDeck(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getMTGDeck(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GetMTGDeck(rctx, fc.Args["deckID"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.MtgDeck)
	fc.Result = res
	return ec.marshalNMTG_Deck2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgDeck(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getMTGDeck(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ID":
				return ec.fieldContext_MTG_Deck_ID(ctx, field)
			case "name":
				return ec.fieldContext_MTG_Deck_name(ctx, field)
			case "cardFrontImage":
				return ec.fieldContext_MTG_Deck_cardFrontImage(ctx, field)
			case "cards":
				return ec.fieldContext_MTG_Deck_cards(ctx, field)
			case "zones":
				return ec.fieldContext_MTG_Deck_zones(ctx, field)
			case "ignoredCards":
				return ec.fieldContext_MTG_Deck_ignoredCards(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MTG_Deck", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getMTGDeck_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_getMTGCardPackages(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getMTGCardPackages(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GetMTGCardPackages(rctx, fc.Args["cardPackageID"].(*string), fc.Args["includePublic"].(*bool))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.MtgCardPackage)
	fc.Result = res
	return ec.marshalNMTG_CardPackage2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgCardPackageᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getMTGCardPackages(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ID":
				return ec.fieldContext_MTG_CardPackage_ID(ctx, field)
			case "name":
				return ec.fieldContext_MTG_CardPackage_name(ctx, field)
			case "isPublic":
				return ec.fieldContext_MTG_CardPackage_isPublic(ctx, field)
			case "ownerID":
				return ec.fieldContext_MTG_CardPackage_ownerID(ctx, field)
			case "cards":
				return ec.fieldContext_MTG_CardPackage_cards(ctx, field)
			case "zones":
				return ec.fieldContext_MTG_CardPackage_zones(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MTG_CardPackage", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getMTGCardPackages_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_tags(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_tags(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Tags(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.Tag)
	fc.Result = res
	return ec.marshalNTag2ᚕmagicᚑhelperᚋgraphᚋmodelᚐTagᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_tags(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_cardTags(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_cardTags(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().CardTags(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.CardTag)
	fc.Result = res
	return ec.marshalNCardTag2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐCardTagᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_cardTags(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ID":
				return ec.fieldContext_CardTag_ID(ctx, field)
			case "name":
				return ec.fieldContext_CardTag_name(ctx, field)
			case "description":
				return ec.fieldContext_CardTag_description(ctx, field)
			case "myRating":
				return ec.fieldContext_CardTag_myRating(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CardTag", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_deckTags(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_deckTags(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().DeckTags(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.DeckTag)
	fc.Result = res
	return ec.marshalNDeckTag2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐDeckTagᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_deckTags(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ID":
				return ec.fieldContext_DeckTag_ID(ctx, field)
			case "name":
				return ec.fieldContext_DeckTag_name(ctx, field)
			case "description":
				return ec.fieldContext_DeckTag_description(ctx, field)
			case "myRating":
				return ec.fieldContext_DeckTag_myRating(ctx, field)
			case "colors":
				return ec.fieldContext_DeckTag_colors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DeckTag", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_tag(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_tag(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Tag(rctx, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.Tag)
	fc.Result = res
	return ec.marshalOTag2magicᚑhelperᚋgraphᚋmodelᚐTag(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_tag(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_tag_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_adminDashboard(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_adminDashboard(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().AdminDashboard(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.AdminDashboard)
	fc.Result = res
	return ec.marshalNAdminDashboard2ᚖmagicᚑhelperᚋgraphᚋmodelᚐAdminDashboard(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_adminDashboard(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "imports":
				return ec.fieldContext_AdminDashboard_imports(ctx, field)
			case "latestLegalitiesDiff":
				return ec.fieldContext_AdminDashboard_latestLegalitiesDiff(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AdminDashboard", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_adminLegalitiesDiff(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_adminLegalitiesDiff(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().AdminLegalitiesDiff(rctx, fc.Args["importId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.AdminLegalitiesDiff)
	fc.Result = res
	return ec.marshalOAdminLegalitiesDiff2ᚖmagicᚑhelperᚋgraphᚋmodelᚐAdminLegalitiesDiff(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_adminLegalitiesDiff(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "importId":
				return ec.fieldContext_AdminLegalitiesDiff_importId(ctx, field)
			case "jobName":
				return ec.fieldContext_AdminLegalitiesDiff_jobName(ctx, field)
			case "entries":
				return ec.fieldContext_AdminLegalitiesDiff_entries(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AdminLegalitiesDiff", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_adminLegalitiesDiff_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_adminImportReports(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_adminImportReports(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().AdminImportReports(rctx, fc.Args["job"].(model.AdminJob), fc.Args["limit"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.AdminImportReport)
	fc.Result = res
	return ec.marshalNAdminImportReport2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐAdminImportReportᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_adminImportReports(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_AdminImportReport_id(ctx, field)
			case "jobName":
				return ec.fieldContext_AdminImportReport_jobName(ctx, field)
			case "status":
				return ec.fieldContext_AdminImportReport_status(ctx, field)
			case "startedAt":
				return ec.fieldContext_AdminImportReport_startedAt(ctx, field)
			case "completedAt":
				return ec.fieldContext_AdminImportReport_completedAt(ctx, field)
			case "durationMs":
				return ec.fieldContext_AdminImportReport_durationMs(ctx, field)
			case "recordsProcessed":
				return ec.fieldContext_AdminImportReport_recordsProcessed(ctx, field)
			case "errorMessage":
				return ec.fieldContext_AdminImportReport_errorMessage(ctx, field)
			case "metadata":
				return ec.fieldContext_AdminImportReport_metadata(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AdminImportReport", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_adminImportReports_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(fc.Args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query___type_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___schema(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	fc.Result = res
	return ec.marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___schema(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "description":
				return ec.fieldContext___Schema_description(ctx, field)
			case "types":
				return ec.fieldContext___Schema_types(ctx, field)
			case "queryType":
				return ec.fieldContext___Schema_queryType(ctx, field)
			case "mutationType":
				return ec.fieldContext___Schema_mutationType(ctx, field)
			case "subscriptionType":
				return ec.fieldContext___Schema_subscriptionType(ctx, field)
			case "directives":
				return ec.fieldContext___Schema_directives(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Schema", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Response_status(ctx context.Context, field graphql.CollectedField, obj *model.Response) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Response_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Response_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Response",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Response_message(ctx context.Context, field graphql.CollectedField, obj *model.Response) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Response_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Response_message(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Response",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_ID(ctx context.Context, field graphql.CollectedField, obj *model.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_ID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_ID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_roles(ctx context.Context, field graphql.CollectedField, obj *model.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_roles(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Roles, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.UserRole)
	fc.Result = res
	return ec.marshalNUserRole2ᚕmagicᚑhelperᚋgraphᚋmodelᚐUserRoleᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_roles(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UserRole does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserRating_user(ctx context.Context, field graphql.CollectedField, obj *model.UserRating) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserRating_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.User, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.User)
	fc.Result = res
	return ec.marshalNUser2ᚖmagicᚑhelperᚋgraphᚋmodelᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserRating_user(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserRating",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ID":
				return ec.fieldContext_User_ID(ctx, field)
			case "roles":
				return ec.fieldContext_User_roles(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserRating_value(ctx context.Context, field graphql.CollectedField, obj *model.UserRating) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserRating_value(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Value, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserRating_value(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserRating",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_locations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalN__DirectiveLocation2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_locations(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __DirectiveLocation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___InputValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___InputValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Directive_args_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_isRepeatable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRepeatable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_isRepeatable(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_isDeprecated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_deprecationReason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___InputValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___InputValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Field_args_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_isDeprecated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_deprecationReason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_defaultValue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_defaultValue(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_isDeprecated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_deprecationReason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_types(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_types(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_queryType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_queryType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_mutationType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_mutationType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_subscriptionType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_subscriptionType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_directives(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	fc.Result = res
	return ec.marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirectiveᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_directives(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Directive_name(ctx, field)
			case "description":
				return ec.fieldContext___Directive_description(ctx, field)
			case "locations":
				return ec.fieldContext___Directive_locations(ctx, field)
			case "args":
				return ec.fieldContext___Directive_args(ctx, field)
			case "isRepeatable":
				return ec.fieldContext___Directive_isRepeatable(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Directive", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_kind(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalN__TypeKind2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_kind(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __TypeKind does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_fields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	fc.Result = res
	return ec.marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐFieldᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_fields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Field_name(ctx, field)
			case "description":
				return ec.fieldContext___Field_description(ctx, field)
			case "args":
				return ec.fieldContext___Field_args(ctx, field)
			case "type":
				return ec.fieldContext___Field_type(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___Field_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___Field_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Field", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_fields_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_interfaces(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_interfaces(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_possibleTypes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_possibleTypes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_enumValues(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	fc.Result = res
	return ec.marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_enumValues(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___EnumValue_name(ctx, field)
			case "description":
				return ec.fieldContext___EnumValue_description(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___EnumValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___EnumValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __EnumValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_enumValues_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_inputFields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_inputFields(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___InputValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___InputValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_ofType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_ofType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_specifiedByURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpecifiedByURL(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_specifiedByURL(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_isOneOf(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_isOneOf(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsOneOf(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_isOneOf(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputAddIgnoredCardInput(ctx context.Context, obj any) (model.AddIgnoredCardInput, error) {
	var it model.AddIgnoredCardInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"cardID", "deckID"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "cardID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cardID"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CardID = data
		case "deckID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deckID"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeckID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputAdminImportActionInput(ctx context.Context, obj any) (model.AdminImportActionInput, error) {
	var it model.AdminImportActionInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	if _, present := asMap["force"]; !present {
		asMap["force"] = false
	}

	fieldsInOrder := [...]string{"job", "force"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "job":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("job"))
			data, err := ec.unmarshalNAdminJob2magicᚑhelperᚋgraphᚋmodelᚐAdminJob(ctx, v)
			if err != nil {
				return it, err
			}
			it.Job = data
		case "force":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("force"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Force = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputAssignTagInput(ctx context.Context, obj any) (model.AssignTagInput, error) {
	var it model.AssignTagInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"tagID", "cardID"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "tagID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tagID"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TagID = data
		case "cardID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cardID"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CardID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateTagInput(ctx context.Context, obj any) (model.CreateTagInput, error) {
	var it model.CreateTagInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"type", "name", "description", "colors", "cardID"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalNTagType2magicᚑhelperᚋgraphᚋmodelᚐTagType(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "colors":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("colors"))
			data, err := ec.unmarshalOMTG_Color2ᚕmagicᚑhelperᚋgraphᚋmodelᚐMtgColorᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Colors = data
		case "cardID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cardID"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.CardID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputFlowZoneInput(ctx context.Context, obj any) (model.FlowZoneInput, error) {
	var it model.FlowZoneInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"ID", "name", "position", "width", "height", "cardChildren", "zoneChildren"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "ID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ID"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "position":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("position"))
			data, err := ec.unmarshalNPositionInput2ᚖmagicᚑhelperᚋgraphᚋmodelᚐPositionInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Position = data
		case "width":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("width"))
			data, err := ec.unmarshalNFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Width = data
		case "height":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("height"))
			data, err := ec.unmarshalNFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Height = data
		case "cardChildren":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cardChildren"))
			data, err := ec.unmarshalNID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.CardChildren = data
		case "zoneChildren":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("zoneChildren"))
			data, err := ec.unmarshalNID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.ZoneChildren = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMTG_AddCardToCardPackageInput(ctx context.Context, obj any) (model.MtgAddCardToCardPackageInput, error) {
	var it model.MtgAddCardToCardPackageInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"cardPackageID", "card", "count"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "cardPackageID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cardPackageID"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CardPackageID = data
		case "card":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("card"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Card = data
		case "count":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("count"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Count = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMTG_CardPackageCardInput(ctx context.Context, obj any) (model.MtgCardPackageCardInput, error) {
	var it model.MtgCardPackageCardInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"card", "selectedVersionID", "count", "mainOrSide"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "card":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("card"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Card = data
		case "selectedVersionID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("selectedVersionID"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.SelectedVersionID = data
		case "count":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("count"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Count = data
		case "mainOrSide":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("mainOrSide"))
			data, err := ec.unmarshalNMainOrSide2magicᚑhelperᚋgraphᚋmodelᚐMainOrSide(ctx, v)
			if err != nil {
				return it, err
			}
			it.MainOrSide = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMTG_CreateCardPackageInput(ctx context.Context, obj any) (model.MtgCreateCardPackageInput, error) {
	var it model.MtgCreateCardPackageInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	if _, present := asMap["isPublic"]; !present {
		asMap["isPublic"] = false
	}

	fieldsInOrder := [...]string{"name", "isPublic"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "isPublic":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isPublic"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsPublic = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMTG_CreateDeckInput(ctx context.Context, obj any) (model.MtgCreateDeckInput, error) {
	var it model.MtgCreateDeckInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMTG_DeckCardFrontImageInput(ctx context.Context, obj any) (model.MtgDeckCardFrontImageInput, error) {
	var it model.MtgDeckCardFrontImageInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"cardID", "versionID"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "cardID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cardID"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CardID = data
		case "versionID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("versionID"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.VersionID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMTG_DeckCardInput(ctx context.Context, obj any) (model.MtgDeckCardInput, error) {
	var it model.MtgDeckCardInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"ID", "card", "selectedVersionID", "count", "position", "mainOrSide", "deckCardType", "phantoms"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "ID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ID"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "card":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("card"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Card = data
		case "selectedVersionID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("selectedVersionID"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.SelectedVersionID = data
		case "count":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("count"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Count = data
		case "position":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("position"))
			data, err := ec.unmarshalNPositionInput2ᚖmagicᚑhelperᚋgraphᚋmodelᚐPositionInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Position = data
		case "mainOrSide":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("mainOrSide"))
			data, err := ec.unmarshalNMainOrSide2magicᚑhelperᚋgraphᚋmodelᚐMainOrSide(ctx, v)
			if err != nil {
				return it, err
			}
			it.MainOrSide = data
		case "deckCardType":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deckCardType"))
			data, err := ec.unmarshalNMTG_DeckCardType2magicᚑhelperᚋgraphᚋmodelᚐMtgDeckCardType(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeckCardType = data
		case "phantoms":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("phantoms"))
			data, err := ec.unmarshalNPhantomInput2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐPhantomInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Phantoms = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMTG_DeleteCardPackageInput(ctx context.Context, obj any) (model.MtgDeleteCardPackageInput, error) {
	var it model.MtgDeleteCardPackageInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"cardPackageID"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "cardPackageID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cardPackageID"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CardPackageID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMTG_DeleteDeckInput(ctx context.Context, obj any) (model.MtgDeleteDeckInput, error) {
	var it model.MtgDeleteDeckInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"deckID"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "deckID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deckID"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeckID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMTG_EditCardPackageNameInput(ctx context.Context, obj any) (model.MtgEditCardPackageNameInput, error) {
	var it model.MtgEditCardPackageNameInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"cardPackageID", "name"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "cardPackageID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cardPackageID"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CardPackageID = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMTG_EditCardPackageVisibilityInput(ctx context.Context, obj any) (model.MtgEditCardPackageVisibilityInput, error) {
	var it model.MtgEditCardPackageVisibilityInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"cardPackageID", "isPublic"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "cardPackageID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cardPackageID"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CardPackageID = data
		case "isPublic":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isPublic"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsPublic = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMTG_Filter_CardTypeInput(ctx context.Context, obj any) (model.MtgFilterCardTypeInput, error) {
	var it model.MtgFilterCardTypeInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"cardType", "value"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "cardType":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cardType"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CardType = data
		case "value":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalNTernaryBoolean2magicᚑhelperᚋgraphᚋmodelᚐTernaryBoolean(ctx, v)
			if err != nil {
				return it, err
			}
			it.Value = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMTG_Filter_ColorInput(ctx context.Context, obj any) (model.MtgFilterColorInput, error) {
	var it model.MtgFilterColorInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"color", "value"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "color":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("color"))
			data, err := ec.unmarshalNMTG_Color2magicᚑhelperᚋgraphᚋmodelᚐMtgColor(ctx, v)
			if err != nil {
				return it, err
			}
			it.Color = data
		case "value":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalNTernaryBoolean2magicᚑhelperᚋgraphᚋmodelᚐTernaryBoolean(ctx, v)
			if err != nil {
				return it, err
			}
			it.Value = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMTG_Filter_GameInput(ctx context.Context, obj any) (model.MtgFilterGameInput, error) {
	var it model.MtgFilterGameInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"game", "value"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "game":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("game"))
			data, err := ec.unmarshalNMTG_Game2magicᚑhelperᚋgraphᚋmodelᚐMtgGame(ctx, v)
			if err != nil {
				return it, err
			}
			it.Game = data
		case "value":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalNTernaryBoolean2magicᚑhelperᚋgraphᚋmodelᚐTernaryBoolean(ctx, v)
			if err != nil {
				return it, err
			}
			it.Value = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMTG_Filter_LayoutInput(ctx context.Context, obj any) (model.MtgFilterLayoutInput, error) {
	var it model.MtgFilterLayoutInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"layout", "value"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "layout":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("layout"))
			data, err := ec.unmarshalNMTG_Layout2magicᚑhelperᚋgraphᚋmodelᚐMtgLayout(ctx, v)
			if err != nil {
				return it, err
			}
			it.Layout = data
		case "value":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalNTernaryBoolean2magicᚑhelperᚋgraphᚋmodelᚐTernaryBoolean(ctx, v)
			if err != nil {
				return it, err
			}
			it.Value = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMTG_Filter_LegalityEntryInput(ctx context.Context, obj any) (model.MtgFilterLegalityEntryInput, error) {
	var it model.MtgFilterLegalityEntryInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"legalityValue", "value"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "legalityValue":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("legalityValue"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LegalityValue = data
		case "value":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalNTernaryBoolean2magicᚑhelperᚋgraphᚋmodelᚐTernaryBoolean(ctx, v)
			if err != nil {
				return it, err
			}
			it.Value = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMTG_Filter_LegalityInput(ctx context.Context, obj any) (model.MtgFilterLegalityInput, error) {
	var it model.MtgFilterLegalityInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"format", "legalityEntries"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "format":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("format"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Format = data
		case "legalityEntries":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("legalityEntries"))
			data, err := ec.unmarshalNMTG_Filter_LegalityEntryInput2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterLegalityEntryInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.LegalityEntries = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMTG_Filter_ManaCostInput(ctx context.Context, obj any) (model.MtgFilterManaCostInput, error) {
	var it model.MtgFilterManaCostInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"manaCost", "value"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "manaCost":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("manaCost"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ManaCost = data
		case "value":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalNTernaryBoolean2magicᚑhelperᚋgraphᚋmodelᚐTernaryBoolean(ctx, v)
			if err != nil {
				return it, err
			}
			it.Value = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMTG_Filter_PaginationInput(ctx context.Context, obj any) (model.MtgFilterPaginationInput, error) {
	var it model.MtgFilterPaginationInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"page", "pageSize"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "page":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("page"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Page = data
		case "pageSize":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pageSize"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.PageSize = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMTG_Filter_RarityInput(ctx context.Context, obj any) (model.MtgFilterRarityInput, error) {
	var it model.MtgFilterRarityInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"rarity", "value"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "rarity":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rarity"))
			data, err := ec.unmarshalNMTG_Rarity2magicᚑhelperᚋgraphᚋmodelᚐMtgRarity(ctx, v)
			if err != nil {
				return it, err
			}
			it.Rarity = data
		case "value":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalNTernaryBoolean2magicᚑhelperᚋgraphᚋmodelᚐTernaryBoolean(ctx, v)
			if err != nil {
				return it, err
			}
			it.Value = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMTG_Filter_RatingInput(ctx context.Context, obj any) (model.MtgFilterRatingInput, error) {
	var it model.MtgFilterRatingInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"min", "max"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "min":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("min"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Min = data
		case "max":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("max"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Max = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMTG_Filter_SearchInput(ctx context.Context, obj any) (model.MtgFilterSearchInput, error) {
	var it model.MtgFilterSearchInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"searchString", "rarity", "color", "multiColor", "manaCosts", "cardTypes", "subtypes", "sets", "legalities", "layouts", "games", "hideIgnored", "tags", "rating", "commander", "deckID", "isSelectingCommander"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "searchString":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("searchString"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.SearchString = data
		case "rarity":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rarity"))
			data, err := ec.unmarshalNMTG_Filter_RarityInput2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterRarityInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Rarity = data
		case "color":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("color"))
			data, err := ec.unmarshalNMTG_Filter_ColorInput2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterColorInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Color = data
		case "multiColor":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("multiColor"))
			data, err := ec.unmarshalNTernaryBoolean2magicᚑhelperᚋgraphᚋmodelᚐTernaryBoolean(ctx, v)
			if err != nil {
				return it, err
			}
			it.MultiColor = data
		case "manaCosts":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("manaCosts"))
			data, err := ec.unmarshalNMTG_Filter_ManaCostInput2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterManaCostInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.ManaCosts = data
		case "cardTypes":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cardTypes"))
			data, err := ec.unmarshalNMTG_Filter_CardTypeInput2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterCardTypeInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.CardTypes = data
		case "subtypes":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subtypes"))
			data, err := ec.unmarshalNMTG_Filter_SubtypeInput2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterSubtypeInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Subtypes = data
		case "sets":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sets"))
			data, err := ec.unmarshalNMTG_Filter_SetInput2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterSetInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Sets = data
		case "legalities":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("legalities"))
			data, err := ec.unmarshalNMTG_Filter_LegalityInput2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterLegalityInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Legalities = data
		case "layouts":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("layouts"))
			data, err := ec.unmarshalNMTG_Filter_LayoutInput2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterLayoutInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Layouts = data
		case "games":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("games"))
			data, err := ec.unmarshalNMTG_Filter_GameInput2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterGameInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Games = data
		case "hideIgnored":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hideIgnored"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HideIgnored = data
		case "tags":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tags"))
			data, err := ec.unmarshalNMTG_Filter_TagInput2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterTagInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Tags = data
		case "rating":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rating"))
			data, err := ec.unmarshalNMTG_Filter_RatingInput2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterRatingInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Rating = data
		case "commander":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("commander"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Commander = data
		case "deckID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deckID"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeckID = data
		case "isSelectingCommander":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isSelectingCommander"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsSelectingCommander = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMTG_Filter_SetInput(ctx context.Context, obj any) (model.MtgFilterSetInput, error) {
	var it model.MtgFilterSetInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"set", "value"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "set":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("set"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Set = data
		case "value":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalNTernaryBoolean2magicᚑhelperᚋgraphᚋmodelᚐTernaryBoolean(ctx, v)
			if err != nil {
				return it, err
			}
			it.Value = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMTG_Filter_SortInput(ctx context.Context, obj any) (model.MtgFilterSortInput, error) {
	var it model.MtgFilterSortInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"sortBy", "sortDirection", "enabled"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "sortBy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sortBy"))
			data, err := ec.unmarshalNMTG_Filter_SortBy2magicᚑhelperᚋgraphᚋmodelᚐMtgFilterSortBy(ctx, v)
			if err != nil {
				return it, err
			}
			it.SortBy = data
		case "sortDirection":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sortDirection"))
			data, err := ec.unmarshalNMTG_Filter_SortDirection2magicᚑhelperᚋgraphᚋmodelᚐMtgFilterSortDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.SortDirection = data
		case "enabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("enabled"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Enabled = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMTG_Filter_SubtypeInput(ctx context.Context, obj any) (model.MtgFilterSubtypeInput, error) {
	var it model.MtgFilterSubtypeInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"subtype", "value"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "subtype":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subtype"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Subtype = data
		case "value":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalNTernaryBoolean2magicᚑhelperᚋgraphᚋmodelᚐTernaryBoolean(ctx, v)
			if err != nil {
				return it, err
			}
			it.Value = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMTG_Filter_TagInput(ctx context.Context, obj any) (model.MtgFilterTagInput, error) {
	var it model.MtgFilterTagInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"tag", "value"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "tag":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tag"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Tag = data
		case "value":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalNTernaryBoolean2magicᚑhelperᚋgraphᚋmodelᚐTernaryBoolean(ctx, v)
			if err != nil {
				return it, err
			}
			it.Value = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMTG_RemoveCardFromCardPackageInput(ctx context.Context, obj any) (model.MtgRemoveCardFromCardPackageInput, error) {
	var it model.MtgRemoveCardFromCardPackageInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"cardPackageID", "card"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "cardPackageID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cardPackageID"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CardPackageID = data
		case "card":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("card"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Card = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMTG_UpdateDeckInput(ctx context.Context, obj any) (model.MtgUpdateDeckInput, error) {
	var it model.MtgUpdateDeckInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"deckID", "name", "cardFrontImage", "cards", "zones"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "deckID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deckID"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeckID = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "cardFrontImage":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cardFrontImage"))
			data, err := ec.unmarshalOMTG_DeckCardFrontImageInput2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgDeckCardFrontImageInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.CardFrontImage = data
		case "cards":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cards"))
			data, err := ec.unmarshalNMTG_DeckCardInput2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgDeckCardInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Cards = data
		case "zones":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("zones"))
			data, err := ec.unmarshalNFlowZoneInput2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐFlowZoneInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Zones = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPhantomInput(ctx context.Context, obj any) (model.PhantomInput, error) {
	var it model.PhantomInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"ID", "position"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "ID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ID"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "position":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("position"))
			data, err := ec.unmarshalNPositionInput2ᚖmagicᚑhelperᚋgraphᚋmodelᚐPositionInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Position = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPositionInput(ctx context.Context, obj any) (model.PositionInput, error) {
	var it model.PositionInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"x", "y"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "x":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("x"))
			data, err := ec.unmarshalNFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.X = data
		case "y":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("y"))
			data, err := ec.unmarshalNFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Y = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRateInput(ctx context.Context, obj any) (model.RateInput, error) {
	var it model.RateInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"entityID", "entityType", "value"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "entityID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("entityID"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.EntityID = data
		case "entityType":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("entityType"))
			data, err := ec.unmarshalNRatableEntityType2magicᚑhelperᚋgraphᚋmodelᚐRatableEntityType(ctx, v)
			if err != nil {
				return it, err
			}
			it.EntityType = data
		case "value":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Value = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRemoveIgnoredCardInput(ctx context.Context, obj any) (model.RemoveIgnoredCardInput, error) {
	var it model.RemoveIgnoredCardInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"cardID", "deckID"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "cardID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cardID"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CardID = data
		case "deckID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deckID"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeckID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUnassignTagInput(ctx context.Context, obj any) (model.UnassignTagInput, error) {
	var it model.UnassignTagInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"tagID", "cardID"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "tagID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tagID"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TagID = data
		case "cardID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cardID"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CardID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateTagInput(ctx context.Context, obj any) (model.UpdateTagInput, error) {
	var it model.UpdateTagInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"ID", "name", "description", "colors"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "ID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ID"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "colors":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("colors"))
			data, err := ec.unmarshalOMTG_Color2ᚕmagicᚑhelperᚋgraphᚋmodelᚐMtgColorᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Colors = data
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

func (ec *executionContext) _Tag(ctx context.Context, sel ast.SelectionSet, obj model.Tag) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.DeckTag:
		return ec._DeckTag(ctx, sel, &obj)
	case *model.DeckTag:
		if obj == nil {
			return graphql.Null
		}
		return ec._DeckTag(ctx, sel, obj)
	case model.CardTag:
		return ec._CardTag(ctx, sel, &obj)
	case *model.CardTag:
		if obj == nil {
			return graphql.Null
		}
		return ec._CardTag(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var adminDashboardImplementors = []string{"AdminDashboard"}

func (ec *executionContext) _AdminDashboard(ctx context.Context, sel ast.SelectionSet, obj *model.AdminDashboard) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, adminDashboardImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AdminDashboard")
		case "imports":
			out.Values[i] = ec._AdminDashboard_imports(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "latestLegalitiesDiff":
			out.Values[i] = ec._AdminDashboard_latestLegalitiesDiff(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var adminImportReportImplementors = []string{"AdminImportReport"}

func (ec *executionContext) _AdminImportReport(ctx context.Context, sel ast.SelectionSet, obj *model.AdminImportReport) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, adminImportReportImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AdminImportReport")
		case "id":
			out.Values[i] = ec._AdminImportReport_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "jobName":
			out.Values[i] = ec._AdminImportReport_jobName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "status":
			out.Values[i] = ec._AdminImportReport_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "startedAt":
			out.Values[i] = ec._AdminImportReport_startedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "completedAt":
			out.Values[i] = ec._AdminImportReport_completedAt(ctx, field, obj)
		case "durationMs":
			out.Values[i] = ec._AdminImportReport_durationMs(ctx, field, obj)
		case "recordsProcessed":
			out.Values[i] = ec._AdminImportReport_recordsProcessed(ctx, field, obj)
		case "errorMessage":
			out.Values[i] = ec._AdminImportReport_errorMessage(ctx, field, obj)
		case "metadata":
			out.Values[i] = ec._AdminImportReport_metadata(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var adminImportSummaryImplementors = []string{"AdminImportSummary"}

func (ec *executionContext) _AdminImportSummary(ctx context.Context, sel ast.SelectionSet, obj *model.AdminImportSummary) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, adminImportSummaryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AdminImportSummary")
		case "jobName":
			out.Values[i] = ec._AdminImportSummary_jobName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "lastRun":
			out.Values[i] = ec._AdminImportSummary_lastRun(ctx, field, obj)
		case "previousRun":
			out.Values[i] = ec._AdminImportSummary_previousRun(ctx, field, obj)
		case "latency":
			out.Values[i] = ec._AdminImportSummary_latency(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var adminLatencyMetricsImplementors = []string{"AdminLatencyMetrics"}

func (ec *executionContext) _AdminLatencyMetrics(ctx context.Context, sel ast.SelectionSet, obj *model.AdminLatencyMetrics) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, adminLatencyMetricsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AdminLatencyMetrics")
		case "lastDurationMs":
			out.Values[i] = ec._AdminLatencyMetrics_lastDurationMs(ctx, field, obj)
		case "avgDurationMs":
			out.Values[i] = ec._AdminLatencyMetrics_avgDurationMs(ctx, field, obj)
		case "p50DurationMs":
			out.Values[i] = ec._AdminLatencyMetrics_p50DurationMs(ctx, field, obj)
		case "p90DurationMs":
			out.Values[i] = ec._AdminLatencyMetrics_p90DurationMs(ctx, field, obj)
		case "totalRuns":
			out.Values[i] = ec._AdminLatencyMetrics_totalRuns(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "lastStartedAt":
			out.Values[i] = ec._AdminLatencyMetrics_lastStartedAt(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var adminLegalitiesDiffImplementors = []string{"AdminLegalitiesDiff"}

func (ec *executionContext) _AdminLegalitiesDiff(ctx context.Context, sel ast.SelectionSet, obj *model.AdminLegalitiesDiff) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, adminLegalitiesDiffImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AdminLegalitiesDiff")
		case "importId":
			out.Values[i] = ec._AdminLegalitiesDiff_importId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "jobName":
			out.Values[i] = ec._AdminLegalitiesDiff_jobName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "entries":
			out.Values[i] = ec._AdminLegalitiesDiff_entries(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var adminLegalitiesDiffEntryImplementors = []string{"AdminLegalitiesDiffEntry"}

func (ec *executionContext) _AdminLegalitiesDiffEntry(ctx context.Context, sel ast.SelectionSet, obj *model.AdminLegalitiesDiffEntry) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, adminLegalitiesDiffEntryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AdminLegalitiesDiffEntry")
		case "cardID":
			out.Values[i] = ec._AdminLegalitiesDiffEntry_cardID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "cardName":
			out.Values[i] = ec._AdminLegalitiesDiffEntry_cardName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "format":
			out.Values[i] = ec._AdminLegalitiesDiffEntry_format(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "previousStatus":
			out.Values[i] = ec._AdminLegalitiesDiffEntry_previousStatus(ctx, field, obj)
		case "currentStatus":
			out.Values[i] = ec._AdminLegalitiesDiffEntry_currentStatus(ctx, field, obj)
		case "setCode":
			out.Values[i] = ec._AdminLegalitiesDiffEntry_setCode(ctx, field, obj)
		case "setName":
			out.Values[i] = ec._AdminLegalitiesDiffEntry_setName(ctx, field, obj)
		case "changedAt":
			out.Values[i] = ec._AdminLegalitiesDiffEntry_changedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var cardTagImplementors = []string{"CardTag", "Tag"}

func (ec *executionContext) _CardTag(ctx context.Context, sel ast.SelectionSet, obj *model.CardTag) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, cardTagImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CardTag")
		case "ID":
			out.Values[i] = ec._CardTag_ID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._CardTag_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec._CardTag_description(ctx, field, obj)
		case "myRating":
			out.Values[i] = ec._CardTag_myRating(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var deckTagImplementors = []string{"DeckTag", "Tag"}

func (ec *executionContext) _DeckTag(ctx context.Context, sel ast.SelectionSet, obj *model.DeckTag) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, deckTagImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DeckTag")
		case "ID":
			out.Values[i] = ec._DeckTag_ID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._DeckTag_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec._DeckTag_description(ctx, field, obj)
		case "myRating":
			out.Values[i] = ec._DeckTag_myRating(ctx, field, obj)
		case "colors":
			out.Values[i] = ec._DeckTag_colors(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var flowZoneImplementors = []string{"FlowZone"}

func (ec *executionContext) _FlowZone(ctx context.Context, sel ast.SelectionSet, obj *model.FlowZone) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, flowZoneImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FlowZone")
		case "ID":
			out.Values[i] = ec._FlowZone_ID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._FlowZone_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "position":
			out.Values[i] = ec._FlowZone_position(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "width":
			out.Values[i] = ec._FlowZone_width(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "height":
			out.Values[i] = ec._FlowZone_height(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "cardChildren":
			out.Values[i] = ec._FlowZone_cardChildren(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "zoneChildren":
			out.Values[i] = ec._FlowZone_zoneChildren(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mTG_CardImplementors = []string{"MTG_Card"}

func (ec *executionContext) _MTG_Card(ctx context.Context, sel ast.SelectionSet, obj *model.MtgCard) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mTG_CardImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MTG_Card")
		case "ID":
			out.Values[i] = ec._MTG_Card_ID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "layout":
			out.Values[i] = ec._MTG_Card_layout(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "CMC":
			out.Values[i] = ec._MTG_Card_CMC(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "colorIdentity":
			out.Values[i] = ec._MTG_Card_colorIdentity(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "colorIndicator":
			out.Values[i] = ec._MTG_Card_colorIndicator(ctx, field, obj)
		case "colors":
			out.Values[i] = ec._MTG_Card_colors(ctx, field, obj)
		case "EDHRecRank":
			out.Values[i] = ec._MTG_Card_EDHRecRank(ctx, field, obj)
		case "keywords":
			out.Values[i] = ec._MTG_Card_keywords(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "loyalty":
			out.Values[i] = ec._MTG_Card_loyalty(ctx, field, obj)
		case "manaCost":
			out.Values[i] = ec._MTG_Card_manaCost(ctx, field, obj)
		case "name":
			out.Values[i] = ec._MTG_Card_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "oracleText":
			out.Values[i] = ec._MTG_Card_oracleText(ctx, field, obj)
		case "power":
			out.Values[i] = ec._MTG_Card_power(ctx, field, obj)
		case "producedMana":
			out.Values[i] = ec._MTG_Card_producedMana(ctx, field, obj)
		case "toughness":
			out.Values[i] = ec._MTG_Card_toughness(ctx, field, obj)
		case "typeLine":
			out.Values[i] = ec._MTG_Card_typeLine(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "versions":
			out.Values[i] = ec._MTG_Card_versions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "myRating":
			out.Values[i] = ec._MTG_Card_myRating(ctx, field, obj)
		case "cardTags":
			out.Values[i] = ec._MTG_Card_cardTags(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deckTags":
			out.Values[i] = ec._MTG_Card_deckTags(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mTG_CardFaceImplementors = []string{"MTG_CardFace"}

func (ec *executionContext) _MTG_CardFace(ctx context.Context, sel ast.SelectionSet, obj *model.MtgCardFace) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mTG_CardFaceImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MTG_CardFace")
		case "artist":
			out.Values[i] = ec._MTG_CardFace_artist(ctx, field, obj)
		case "CMC":
			out.Values[i] = ec._MTG_CardFace_CMC(ctx, field, obj)
		case "colorIndicator":
			out.Values[i] = ec._MTG_CardFace_colorIndicator(ctx, field, obj)
		case "colors":
			out.Values[i] = ec._MTG_CardFace_colors(ctx, field, obj)
		case "flavorText":
			out.Values[i] = ec._MTG_CardFace_flavorText(ctx, field, obj)
		case "imageUris":
			out.Values[i] = ec._MTG_CardFace_imageUris(ctx, field, obj)
		case "layout":
			out.Values[i] = ec._MTG_CardFace_layout(ctx, field, obj)
		case "loyalty":
			out.Values[i] = ec._MTG_CardFace_loyalty(ctx, field, obj)
		case "manaCost":
			out.Values[i] = ec._MTG_CardFace_manaCost(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._MTG_CardFace_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "oracleText":
			out.Values[i] = ec._MTG_CardFace_oracleText(ctx, field, obj)
		case "power":
			out.Values[i] = ec._MTG_CardFace_power(ctx, field, obj)
		case "toughness":
			out.Values[i] = ec._MTG_CardFace_toughness(ctx, field, obj)
		case "typeLine":
			out.Values[i] = ec._MTG_CardFace_typeLine(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mTG_CardFace_DashboardImplementors = []string{"MTG_CardFace_Dashboard"}

func (ec *executionContext) _MTG_CardFace_Dashboard(ctx context.Context, sel ast.SelectionSet, obj *model.MtgCardFaceDashboard) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mTG_CardFace_DashboardImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MTG_CardFace_Dashboard")
		case "imageUris":
			out.Values[i] = ec._MTG_CardFace_Dashboard_imageUris(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mTG_CardPackageImplementors = []string{"MTG_CardPackage"}

func (ec *executionContext) _MTG_CardPackage(ctx context.Context, sel ast.SelectionSet, obj *model.MtgCardPackage) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mTG_CardPackageImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MTG_CardPackage")
		case "ID":
			out.Values[i] = ec._MTG_CardPackage_ID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._MTG_CardPackage_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isPublic":
			out.Values[i] = ec._MTG_CardPackage_isPublic(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "ownerID":
			out.Values[i] = ec._MTG_CardPackage_ownerID(ctx, field, obj)
		case "cards":
			out.Values[i] = ec._MTG_CardPackage_cards(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "zones":
			out.Values[i] = ec._MTG_CardPackage_zones(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mTG_CardPackageCardImplementors = []string{"MTG_CardPackageCard"}

func (ec *executionContext) _MTG_CardPackageCard(ctx context.Context, sel ast.SelectionSet, obj *model.MtgCardPackageCard) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mTG_CardPackageCardImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MTG_CardPackageCard")
		case "card":
			out.Values[i] = ec._MTG_CardPackageCard_card(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "selectedVersionID":
			out.Values[i] = ec._MTG_CardPackageCard_selectedVersionID(ctx, field, obj)
		case "count":
			out.Values[i] = ec._MTG_CardPackageCard_count(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "mainOrSide":
			out.Values[i] = ec._MTG_CardPackageCard_mainOrSide(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "position":
			out.Values[i] = ec._MTG_CardPackageCard_position(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "phantoms":
			out.Values[i] = ec._MTG_CardPackageCard_phantoms(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mTG_CardVersionImplementors = []string{"MTG_CardVersion"}

func (ec *executionContext) _MTG_CardVersion(ctx context.Context, sel ast.SelectionSet, obj *model.MtgCardVersion) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mTG_CardVersionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MTG_CardVersion")
		case "ID":
			out.Values[i] = ec._MTG_CardVersion_ID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isDefault":
			out.Values[i] = ec._MTG_CardVersion_isDefault(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isAlchemy":
			out.Values[i] = ec._MTG_CardVersion_isAlchemy(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "artist":
			out.Values[i] = ec._MTG_CardVersion_artist(ctx, field, obj)
		case "lang":
			out.Values[i] = ec._MTG_CardVersion_lang(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "flavorName":
			out.Values[i] = ec._MTG_CardVersion_flavorName(ctx, field, obj)
		case "flavorText":
			out.Values[i] = ec._MTG_CardVersion_flavorText(ctx, field, obj)
		case "cardFaces":
			out.Values[i] = ec._MTG_CardVersion_cardFaces(ctx, field, obj)
		case "legalities":
			out.Values[i] = ec._MTG_CardVersion_legalities(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "games":
			out.Values[i] = ec._MTG_CardVersion_games(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "imageUris":
			out.Values[i] = ec._MTG_CardVersion_imageUris(ctx, field, obj)
		case "printedName":
			out.Values[i] = ec._MTG_CardVersion_printedName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "rarity":
			out.Values[i] = ec._MTG_CardVersion_rarity(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "releasedAt":
			out.Values[i] = ec._MTG_CardVersion_releasedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "reprint":
			out.Values[i] = ec._MTG_CardVersion_reprint(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "setName":
			out.Values[i] = ec._MTG_CardVersion_setName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "setType":
			out.Values[i] = ec._MTG_CardVersion_setType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "set":
			out.Values[i] = ec._MTG_CardVersion_set(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "setID":
			out.Values[i] = ec._MTG_CardVersion_setID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "variation":
			out.Values[i] = ec._MTG_CardVersion_variation(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "variationOf":
			out.Values[i] = ec._MTG_CardVersion_variationOf(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mTG_CardVersion_DashboardImplementors = []string{"MTG_CardVersion_Dashboard"}

func (ec *executionContext) _MTG_CardVersion_Dashboard(ctx context.Context, sel ast.SelectionSet, obj *model.MtgCardVersionDashboard) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mTG_CardVersion_DashboardImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MTG_CardVersion_Dashboard")
		case "ID":
			out.Values[i] = ec._MTG_CardVersion_Dashboard_ID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isDefault":
			out.Values[i] = ec._MTG_CardVersion_Dashboard_isDefault(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isAlchemy":
			out.Values[i] = ec._MTG_CardVersion_Dashboard_isAlchemy(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "cardFaces":
			out.Values[i] = ec._MTG_CardVersion_Dashboard_cardFaces(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "imageUris":
			out.Values[i] = ec._MTG_CardVersion_Dashboard_imageUris(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mTG_Card_DashboardImplementors = []string{"MTG_Card_Dashboard"}

func (ec *executionContext) _MTG_Card_Dashboard(ctx context.Context, sel ast.SelectionSet, obj *model.MtgCardDashboard) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mTG_Card_DashboardImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MTG_Card_Dashboard")
		case "ID":
			out.Values[i] = ec._MTG_Card_Dashboard_ID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "versions":
			out.Values[i] = ec._MTG_Card_Dashboard_versions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mTG_DeckImplementors = []string{"MTG_Deck"}

func (ec *executionContext) _MTG_Deck(ctx context.Context, sel ast.SelectionSet, obj *model.MtgDeck) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mTG_DeckImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MTG_Deck")
		case "ID":
			out.Values[i] = ec._MTG_Deck_ID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._MTG_Deck_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "cardFrontImage":
			out.Values[i] = ec._MTG_Deck_cardFrontImage(ctx, field, obj)
		case "cards":
			out.Values[i] = ec._MTG_Deck_cards(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "zones":
			out.Values[i] = ec._MTG_Deck_zones(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "ignoredCards":
			out.Values[i] = ec._MTG_Deck_ignoredCards(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mTG_DeckCardImplementors = []string{"MTG_DeckCard"}

func (ec *executionContext) _MTG_DeckCard(ctx context.Context, sel ast.SelectionSet, obj *model.MtgDeckCard) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mTG_DeckCardImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MTG_DeckCard")
		case "card":
			out.Values[i] = ec._MTG_DeckCard_card(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "selectedVersionID":
			out.Values[i] = ec._MTG_DeckCard_selectedVersionID(ctx, field, obj)
		case "count":
			out.Values[i] = ec._MTG_DeckCard_count(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "position":
			out.Values[i] = ec._MTG_DeckCard_position(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "mainOrSide":
			out.Values[i] = ec._MTG_DeckCard_mainOrSide(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deckCardType":
			out.Values[i] = ec._MTG_DeckCard_deckCardType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "phantoms":
			out.Values[i] = ec._MTG_DeckCard_phantoms(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mTG_DeckCard_DashboardImplementors = []string{"MTG_DeckCard_Dashboard"}

func (ec *executionContext) _MTG_DeckCard_Dashboard(ctx context.Context, sel ast.SelectionSet, obj *model.MtgDeckCardDashboard) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mTG_DeckCard_DashboardImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MTG_DeckCard_Dashboard")
		case "card":
			out.Values[i] = ec._MTG_DeckCard_Dashboard_card(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "selectedVersionID":
			out.Values[i] = ec._MTG_DeckCard_Dashboard_selectedVersionID(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mTG_DeckDashboardImplementors = []string{"MTG_DeckDashboard"}

func (ec *executionContext) _MTG_DeckDashboard(ctx context.Context, sel ast.SelectionSet, obj *model.MtgDeckDashboard) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mTG_DeckDashboardImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MTG_DeckDashboard")
		case "ID":
			out.Values[i] = ec._MTG_DeckDashboard_ID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._MTG_DeckDashboard_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "cardFrontImage":
			out.Values[i] = ec._MTG_DeckDashboard_cardFrontImage(ctx, field, obj)
		case "cards":
			out.Values[i] = ec._MTG_DeckDashboard_cards(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mTG_Deck_CardFrontImageImplementors = []string{"MTG_Deck_CardFrontImage"}

func (ec *executionContext) _MTG_Deck_CardFrontImage(ctx context.Context, sel ast.SelectionSet, obj *model.MtgDeckCardFrontImage) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mTG_Deck_CardFrontImageImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MTG_Deck_CardFrontImage")
		case "cardID":
			out.Values[i] = ec._MTG_Deck_CardFrontImage_cardID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "versionID":
			out.Values[i] = ec._MTG_Deck_CardFrontImage_versionID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "image":
			out.Values[i] = ec._MTG_Deck_CardFrontImage_image(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mTG_Filter_CardTypesImplementors = []string{"MTG_Filter_CardTypes"}

func (ec *executionContext) _MTG_Filter_CardTypes(ctx context.Context, sel ast.SelectionSet, obj *model.MtgFilterCardTypes) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mTG_Filter_CardTypesImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MTG_Filter_CardTypes")
		case "cardType":
			out.Values[i] = ec._MTG_Filter_CardTypes_cardType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "subtypes":
			out.Values[i] = ec._MTG_Filter_CardTypes_subtypes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mTG_Filter_EntriesImplementors = []string{"MTG_Filter_Entries"}

func (ec *executionContext) _MTG_Filter_Entries(ctx context.Context, sel ast.SelectionSet, obj *model.MtgFilterEntries) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mTG_Filter_EntriesImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MTG_Filter_Entries")
		case "types":
			out.Values[i] = ec._MTG_Filter_Entries_types(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "expansions":
			out.Values[i] = ec._MTG_Filter_Entries_expansions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "legality":
			out.Values[i] = ec._MTG_Filter_Entries_legality(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "layouts":
			out.Values[i] = ec._MTG_Filter_Entries_layouts(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mTG_Filter_ExpansionImplementors = []string{"MTG_Filter_Expansion"}

func (ec *executionContext) _MTG_Filter_Expansion(ctx context.Context, sel ast.SelectionSet, obj *model.MtgFilterExpansion) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mTG_Filter_ExpansionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MTG_Filter_Expansion")
		case "set":
			out.Values[i] = ec._MTG_Filter_Expansion_set(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "setName":
			out.Values[i] = ec._MTG_Filter_Expansion_setName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "releasedAt":
			out.Values[i] = ec._MTG_Filter_Expansion_releasedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "imageURL":
			out.Values[i] = ec._MTG_Filter_Expansion_imageURL(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "setType":
			out.Values[i] = ec._MTG_Filter_Expansion_setType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "games":
			out.Values[i] = ec._MTG_Filter_Expansion_games(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mTG_Filter_LegalityImplementors = []string{"MTG_Filter_Legality"}

func (ec *executionContext) _MTG_Filter_Legality(ctx context.Context, sel ast.SelectionSet, obj *model.MtgFilterLegality) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mTG_Filter_LegalityImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MTG_Filter_Legality")
		case "formats":
			out.Values[i] = ec._MTG_Filter_Legality_formats(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "legalityValues":
			out.Values[i] = ec._MTG_Filter_Legality_legalityValues(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mTG_Filter_SearchImplementors = []string{"MTG_Filter_Search"}

func (ec *executionContext) _MTG_Filter_Search(ctx context.Context, sel ast.SelectionSet, obj *model.MtgFilterSearch) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mTG_Filter_SearchImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MTG_Filter_Search")
		case "pagedCards":
			out.Values[i] = ec._MTG_Filter_Search_pagedCards(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._MTG_Filter_Search_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mTG_ImageImplementors = []string{"MTG_Image"}

func (ec *executionContext) _MTG_Image(ctx context.Context, sel ast.SelectionSet, obj *model.MtgImage) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mTG_ImageImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MTG_Image")
		case "artCrop":
			out.Values[i] = ec._MTG_Image_artCrop(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "borderCrop":
			out.Values[i] = ec._MTG_Image_borderCrop(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "large":
			out.Values[i] = ec._MTG_Image_large(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "normal":
			out.Values[i] = ec._MTG_Image_normal(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "PNG":
			out.Values[i] = ec._MTG_Image_PNG(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "small":
			out.Values[i] = ec._MTG_Image_small(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mutationImplementors = []string{"Mutation"}

func (ec *executionContext) _Mutation(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mutationImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Mutation",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mutation")
		case "createMTGDeck":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createMTGDeck(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteMTGDeck":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteMTGDeck(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateMTGDeck":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateMTGDeck(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "saveMTGDeckAsCopy":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_saveMTGDeckAsCopy(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createMTGCardPackage":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createMTGCardPackage(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteMTGCardPackage":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteMTGCardPackage(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "editMTGCardPackageName":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_editMTGCardPackageName(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "editMTGCardPackageVisibility":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_editMTGCardPackageVisibility(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "addMTGCardToCardPackage":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_addMTGCardToCardPackage(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "removeMTGCardFromCardPackage":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_removeMTGCardFromCardPackage(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createTag":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createTag(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateTag":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateTag(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteTag":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteTag(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "assignTag":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_assignTag(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "unassignTag":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_unassignTag(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "rate":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_rate(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "addIgnoredCard":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_addIgnoredCard(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "removeIgnoredCard":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_removeIgnoredCard(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "adminRetryImport":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_adminRetryImport(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "adminBackfillImport":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_adminBackfillImport(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var phantomImplementors = []string{"Phantom"}

func (ec *executionContext) _Phantom(ctx context.Context, sel ast.SelectionSet, obj *model.Phantom) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, phantomImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Phantom")
		case "position":
			out.Values[i] = ec._Phantom_position(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "ID":
			out.Values[i] = ec._Phantom_ID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var positionImplementors = []string{"Position"}

func (ec *executionContext) _Position(ctx context.Context, sel ast.SelectionSet, obj *model.Position) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, positionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Position")
		case "x":
			out.Values[i] = ec._Position_x(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "y":
			out.Values[i] = ec._Position_y(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "getMTGCards":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getMTGCards(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getMTGCardsFiltered":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getMTGCardsFiltered(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getMTGFilters":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getMTGFilters(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getMTGDecks":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getMTGDecks(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getMTGDeck":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getMTGDeck(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getMTGCardPackages":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getMTGCardPackages(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "tags":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_tags(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "cardTags":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_cardTags(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "deckTags":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_deckTags(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "tag":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_tag(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "adminDashboard":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_adminDashboard(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "adminLegalitiesDiff":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_adminLegalitiesDiff(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "adminImportReports":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_adminImportReports(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "__type":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___type(ctx, field)
			})
		case "__schema":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___schema(ctx, field)
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var responseImplementors = []string{"Response"}

func (ec *executionContext) _Response(ctx context.Context, sel ast.SelectionSet, obj *model.Response) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, responseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Response")
		case "status":
			out.Values[i] = ec._Response_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._Response_message(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var userImplementors = []string{"User"}

func (ec *executionContext) _User(ctx context.Context, sel ast.SelectionSet, obj *model.User) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("User")
		case "ID":
			out.Values[i] = ec._User_ID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "roles":
			out.Values[i] = ec._User_roles(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var userRatingImplementors = []string{"UserRating"}

func (ec *executionContext) _UserRating(ctx context.Context, sel ast.SelectionSet, obj *model.UserRating) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userRatingImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UserRating")
		case "user":
			out.Values[i] = ec._UserRating_user(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "value":
			out.Values[i] = ec._UserRating_value(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __DirectiveImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Directive_description(ctx, field, obj)
		case "locations":
			out.Values[i] = ec.___Directive_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "args":
			out.Values[i] = ec.___Directive_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isRepeatable":
			out.Values[i] = ec.___Directive_isRepeatable(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __EnumValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __FieldImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Field_description(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Field_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec.___Field_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __InputValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___InputValue_description(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___InputValue_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___InputValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___InputValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __SchemaImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "description":
			out.Values[i] = ec.___Schema_description(ctx, field, obj)
		case "types":
			out.Values[i] = ec.___Schema_types(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)
		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)
		case "directives":
			out.Values[i] = ec.___Schema_directives(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __TypeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec.___Type_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Type_description(ctx, field, obj)
		case "fields":
			out.Values[i] = ec.___Type_fields(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)
		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)
		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)
		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)
		case "ofType":
			out.Values[i] = ec.___Type_ofType(ctx, field, obj)
		case "specifiedByURL":
			out.Values[i] = ec.___Type_specifiedByURL(ctx, field, obj)
		case "isOneOf":
			out.Values[i] = ec.___Type_isOneOf(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) unmarshalNAddIgnoredCardInput2magicᚑhelperᚋgraphᚋmodelᚐAddIgnoredCardInput(ctx context.Context, v any) (model.AddIgnoredCardInput, error) {
	res, err := ec.unmarshalInputAddIgnoredCardInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNAdminDashboard2magicᚑhelperᚋgraphᚋmodelᚐAdminDashboard(ctx context.Context, sel ast.SelectionSet, v model.AdminDashboard) graphql.Marshaler {
	return ec._AdminDashboard(ctx, sel, &v)
}

func (ec *executionContext) marshalNAdminDashboard2ᚖmagicᚑhelperᚋgraphᚋmodelᚐAdminDashboard(ctx context.Context, sel ast.SelectionSet, v *model.AdminDashboard) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._AdminDashboard(ctx, sel, v)
}

func (ec *executionContext) unmarshalNAdminImportActionInput2magicᚑhelperᚋgraphᚋmodelᚐAdminImportActionInput(ctx context.Context, v any) (model.AdminImportActionInput, error) {
	res, err := ec.unmarshalInputAdminImportActionInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNAdminImportReport2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐAdminImportReportᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.AdminImportReport) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAdminImportReport2ᚖmagicᚑhelperᚋgraphᚋmodelᚐAdminImportReport(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNAdminImportReport2ᚖmagicᚑhelperᚋgraphᚋmodelᚐAdminImportReport(ctx context.Context, sel ast.SelectionSet, v *model.AdminImportReport) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._AdminImportReport(ctx, sel, v)
}

func (ec *executionContext) unmarshalNAdminImportStatus2magicᚑhelperᚋgraphᚋmodelᚐAdminImportStatus(ctx context.Context, v any) (model.AdminImportStatus, error) {
	var res model.AdminImportStatus
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNAdminImportStatus2magicᚑhelperᚋgraphᚋmodelᚐAdminImportStatus(ctx context.Context, sel ast.SelectionSet, v model.AdminImportStatus) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNAdminImportSummary2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐAdminImportSummaryᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.AdminImportSummary) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAdminImportSummary2ᚖmagicᚑhelperᚋgraphᚋmodelᚐAdminImportSummary(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNAdminImportSummary2ᚖmagicᚑhelperᚋgraphᚋmodelᚐAdminImportSummary(ctx context.Context, sel ast.SelectionSet, v *model.AdminImportSummary) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._AdminImportSummary(ctx, sel, v)
}

func (ec *executionContext) unmarshalNAdminJob2magicᚑhelperᚋgraphᚋmodelᚐAdminJob(ctx context.Context, v any) (model.AdminJob, error) {
	var res model.AdminJob
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNAdminJob2magicᚑhelperᚋgraphᚋmodelᚐAdminJob(ctx context.Context, sel ast.SelectionSet, v model.AdminJob) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNAdminLatencyMetrics2ᚖmagicᚑhelperᚋgraphᚋmodelᚐAdminLatencyMetrics(ctx context.Context, sel ast.SelectionSet, v *model.AdminLatencyMetrics) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._AdminLatencyMetrics(ctx, sel, v)
}

func (ec *executionContext) marshalNAdminLegalitiesDiffEntry2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐAdminLegalitiesDiffEntryᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.AdminLegalitiesDiffEntry) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAdminLegalitiesDiffEntry2ᚖmagicᚑhelperᚋgraphᚋmodelᚐAdminLegalitiesDiffEntry(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNAdminLegalitiesDiffEntry2ᚖmagicᚑhelperᚋgraphᚋmodelᚐAdminLegalitiesDiffEntry(ctx context.Context, sel ast.SelectionSet, v *model.AdminLegalitiesDiffEntry) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._AdminLegalitiesDiffEntry(ctx, sel, v)
}

func (ec *executionContext) unmarshalNAssignTagInput2magicᚑhelperᚋgraphᚋmodelᚐAssignTagInput(ctx context.Context, v any) (model.AssignTagInput, error) {
	res, err := ec.unmarshalInputAssignTagInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v any) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNCardTag2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐCardTagᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.CardTag) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNCardTag2ᚖmagicᚑhelperᚋgraphᚋmodelᚐCardTag(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNCardTag2ᚖmagicᚑhelperᚋgraphᚋmodelᚐCardTag(ctx context.Context, sel ast.SelectionSet, v *model.CardTag) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CardTag(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCreateTagInput2magicᚑhelperᚋgraphᚋmodelᚐCreateTagInput(ctx context.Context, v any) (model.CreateTagInput, error) {
	res, err := ec.unmarshalInputCreateTagInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDeckTag2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐDeckTagᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.DeckTag) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNDeckTag2ᚖmagicᚑhelperᚋgraphᚋmodelᚐDeckTag(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNDeckTag2ᚖmagicᚑhelperᚋgraphᚋmodelᚐDeckTag(ctx context.Context, sel ast.SelectionSet, v *model.DeckTag) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._DeckTag(ctx, sel, v)
}

func (ec *executionContext) unmarshalNFloat2float64(ctx context.Context, v any) (float64, error) {
	res, err := graphql.UnmarshalFloatContext(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFloat2float64(ctx context.Context, sel ast.SelectionSet, v float64) graphql.Marshaler {
	res := graphql.MarshalFloatContext(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return graphql.WrapContextMarshaler(ctx, res)
}

func (ec *executionContext) marshalNFlowZone2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐFlowZoneᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.FlowZone) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNFlowZone2ᚖmagicᚑhelperᚋgraphᚋmodelᚐFlowZone(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNFlowZone2ᚖmagicᚑhelperᚋgraphᚋmodelᚐFlowZone(ctx context.Context, sel ast.SelectionSet, v *model.FlowZone) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._FlowZone(ctx, sel, v)
}

func (ec *executionContext) unmarshalNFlowZoneInput2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐFlowZoneInputᚄ(ctx context.Context, v any) ([]*model.FlowZoneInput, error) {
	var vSlice []any
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.FlowZoneInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNFlowZoneInput2ᚖmagicᚑhelperᚋgraphᚋmodelᚐFlowZoneInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNFlowZoneInput2ᚖmagicᚑhelperᚋgraphᚋmodelᚐFlowZoneInput(ctx context.Context, v any) (*model.FlowZoneInput, error) {
	res, err := ec.unmarshalInputFlowZoneInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNID2string(ctx context.Context, v any) (string, error) {
	res, err := graphql.UnmarshalID(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNID2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalID(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNID2ᚕstringᚄ(ctx context.Context, v any) ([]string, error) {
	var vSlice []any
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNID2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNID2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNID2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v any) (int, error) {
	res, err := graphql.UnmarshalInt(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	res := graphql.MarshalInt(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNMTG_AddCardToCardPackageInput2magicᚑhelperᚋgraphᚋmodelᚐMtgAddCardToCardPackageInput(ctx context.Context, v any) (model.MtgAddCardToCardPackageInput, error) {
	res, err := ec.unmarshalInputMTG_AddCardToCardPackageInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNMTG_Card2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgCardᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.MtgCard) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMTG_Card2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgCard(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNMTG_Card2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgCard(ctx context.Context, sel ast.SelectionSet, v *model.MtgCard) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._MTG_Card(ctx, sel, v)
}

func (ec *executionContext) marshalNMTG_CardFace2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgCardFace(ctx context.Context, sel ast.SelectionSet, v *model.MtgCardFace) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._MTG_CardFace(ctx, sel, v)
}

func (ec *executionContext) marshalNMTG_CardFace_Dashboard2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgCardFaceDashboardᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.MtgCardFaceDashboard) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMTG_CardFace_Dashboard2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgCardFaceDashboard(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNMTG_CardFace_Dashboard2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgCardFaceDashboard(ctx context.Context, sel ast.SelectionSet, v *model.MtgCardFaceDashboard) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._MTG_CardFace_Dashboard(ctx, sel, v)
}

func (ec *executionContext) marshalNMTG_CardPackage2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgCardPackageᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.MtgCardPackage) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMTG_CardPackage2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgCardPackage(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNMTG_CardPackage2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgCardPackage(ctx context.Context, sel ast.SelectionSet, v *model.MtgCardPackage) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._MTG_CardPackage(ctx, sel, v)
}

func (ec *executionContext) marshalNMTG_CardPackageCard2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgCardPackageCardᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.MtgCardPackageCard) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMTG_CardPackageCard2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgCardPackageCard(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNMTG_CardPackageCard2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgCardPackageCard(ctx context.Context, sel ast.SelectionSet, v *model.MtgCardPackageCard) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._MTG_CardPackageCard(ctx, sel, v)
}

func (ec *executionContext) marshalNMTG_CardVersion2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgCardVersionᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.MtgCardVersion) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMTG_CardVersion2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgCardVersion(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNMTG_CardVersion2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgCardVersion(ctx context.Context, sel ast.SelectionSet, v *model.MtgCardVersion) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._MTG_CardVersion(ctx, sel, v)
}

func (ec *executionContext) marshalNMTG_CardVersion_Dashboard2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgCardVersionDashboardᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.MtgCardVersionDashboard) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMTG_CardVersion_Dashboard2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgCardVersionDashboard(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNMTG_CardVersion_Dashboard2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgCardVersionDashboard(ctx context.Context, sel ast.SelectionSet, v *model.MtgCardVersionDashboard) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._MTG_CardVersion_Dashboard(ctx, sel, v)
}

func (ec *executionContext) marshalNMTG_Card_Dashboard2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgCardDashboard(ctx context.Context, sel ast.SelectionSet, v *model.MtgCardDashboard) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._MTG_Card_Dashboard(ctx, sel, v)
}

func (ec *executionContext) unmarshalNMTG_Color2magicᚑhelperᚋgraphᚋmodelᚐMtgColor(ctx context.Context, v any) (model.MtgColor, error) {
	var res model.MtgColor
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNMTG_Color2magicᚑhelperᚋgraphᚋmodelᚐMtgColor(ctx context.Context, sel ast.SelectionSet, v model.MtgColor) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNMTG_Color2ᚕmagicᚑhelperᚋgraphᚋmodelᚐMtgColorᚄ(ctx context.Context, v any) ([]model.MtgColor, error) {
	var vSlice []any
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]model.MtgColor, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNMTG_Color2magicᚑhelperᚋgraphᚋmodelᚐMtgColor(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNMTG_Color2ᚕmagicᚑhelperᚋgraphᚋmodelᚐMtgColorᚄ(ctx context.Context, sel ast.SelectionSet, v []model.MtgColor) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMTG_Color2magicᚑhelperᚋgraphᚋmodelᚐMtgColor(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNMTG_CreateCardPackageInput2magicᚑhelperᚋgraphᚋmodelᚐMtgCreateCardPackageInput(ctx context.Context, v any) (model.MtgCreateCardPackageInput, error) {
	res, err := ec.unmarshalInputMTG_CreateCardPackageInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNMTG_CreateDeckInput2magicᚑhelperᚋgraphᚋmodelᚐMtgCreateDeckInput(ctx context.Context, v any) (model.MtgCreateDeckInput, error) {
	res, err := ec.unmarshalInputMTG_CreateDeckInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNMTG_Deck2magicᚑhelperᚋgraphᚋmodelᚐMtgDeck(ctx context.Context, sel ast.SelectionSet, v model.MtgDeck) graphql.Marshaler {
	return ec._MTG_Deck(ctx, sel, &v)
}

func (ec *executionContext) marshalNMTG_Deck2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgDeck(ctx context.Context, sel ast.SelectionSet, v *model.MtgDeck) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._MTG_Deck(ctx, sel, v)
}

func (ec *executionContext) marshalNMTG_DeckCard2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgDeckCardᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.MtgDeckCard) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMTG_DeckCard2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgDeckCard(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNMTG_DeckCard2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgDeckCard(ctx context.Context, sel ast.SelectionSet, v *model.MtgDeckCard) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._MTG_DeckCard(ctx, sel, v)
}

func (ec *executionContext) unmarshalNMTG_DeckCardInput2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgDeckCardInputᚄ(ctx context.Context, v any) ([]*model.MtgDeckCardInput, error) {
	var vSlice []any
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.MtgDeckCardInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNMTG_DeckCardInput2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgDeckCardInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNMTG_DeckCardInput2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgDeckCardInput(ctx context.Context, v any) (*model.MtgDeckCardInput, error) {
	res, err := ec.unmarshalInputMTG_DeckCardInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNMTG_DeckCardType2magicᚑhelperᚋgraphᚋmodelᚐMtgDeckCardType(ctx context.Context, v any) (model.MtgDeckCardType, error) {
	var res model.MtgDeckCardType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNMTG_DeckCardType2magicᚑhelperᚋgraphᚋmodelᚐMtgDeckCardType(ctx context.Context, sel ast.SelectionSet, v model.MtgDeckCardType) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNMTG_DeckCard_Dashboard2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgDeckCardDashboardᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.MtgDeckCardDashboard) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMTG_DeckCard_Dashboard2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgDeckCardDashboard(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNMTG_DeckCard_Dashboard2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgDeckCardDashboard(ctx context.Context, sel ast.SelectionSet, v *model.MtgDeckCardDashboard) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._MTG_DeckCard_Dashboard(ctx, sel, v)
}

func (ec *executionContext) marshalNMTG_DeckDashboard2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgDeckDashboardᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.MtgDeckDashboard) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMTG_DeckDashboard2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgDeckDashboard(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNMTG_DeckDashboard2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgDeckDashboard(ctx context.Context, sel ast.SelectionSet, v *model.MtgDeckDashboard) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._MTG_DeckDashboard(ctx, sel, v)
}

func (ec *executionContext) unmarshalNMTG_DeleteCardPackageInput2magicᚑhelperᚋgraphᚋmodelᚐMtgDeleteCardPackageInput(ctx context.Context, v any) (model.MtgDeleteCardPackageInput, error) {
	res, err := ec.unmarshalInputMTG_DeleteCardPackageInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNMTG_DeleteDeckInput2magicᚑhelperᚋgraphᚋmodelᚐMtgDeleteDeckInput(ctx context.Context, v any) (model.MtgDeleteDeckInput, error) {
	res, err := ec.unmarshalInputMTG_DeleteDeckInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNMTG_EditCardPackageNameInput2magicᚑhelperᚋgraphᚋmodelᚐMtgEditCardPackageNameInput(ctx context.Context, v any) (model.MtgEditCardPackageNameInput, error) {
	res, err := ec.unmarshalInputMTG_EditCardPackageNameInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNMTG_EditCardPackageVisibilityInput2magicᚑhelperᚋgraphᚋmodelᚐMtgEditCardPackageVisibilityInput(ctx context.Context, v any) (model.MtgEditCardPackageVisibilityInput, error) {
	res, err := ec.unmarshalInputMTG_EditCardPackageVisibilityInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNMTG_Filter_CardTypeInput2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterCardTypeInputᚄ(ctx context.Context, v any) ([]*model.MtgFilterCardTypeInput, error) {
	var vSlice []any
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.MtgFilterCardTypeInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNMTG_Filter_CardTypeInput2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterCardTypeInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNMTG_Filter_CardTypeInput2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterCardTypeInput(ctx context.Context, v any) (*model.MtgFilterCardTypeInput, error) {
	res, err := ec.unmarshalInputMTG_Filter_CardTypeInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNMTG_Filter_CardTypes2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterCardTypesᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.MtgFilterCardTypes) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMTG_Filter_CardTypes2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterCardTypes(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNMTG_Filter_CardTypes2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterCardTypes(ctx context.Context, sel ast.SelectionSet, v *model.MtgFilterCardTypes) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._MTG_Filter_CardTypes(ctx, sel, v)
}

func (ec *executionContext) unmarshalNMTG_Filter_ColorInput2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterColorInputᚄ(ctx context.Context, v any) ([]*model.MtgFilterColorInput, error) {
	var vSlice []any
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.MtgFilterColorInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNMTG_Filter_ColorInput2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterColorInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNMTG_Filter_ColorInput2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterColorInput(ctx context.Context, v any) (*model.MtgFilterColorInput, error) {
	res, err := ec.unmarshalInputMTG_Filter_ColorInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNMTG_Filter_Entries2magicᚑhelperᚋgraphᚋmodelᚐMtgFilterEntries(ctx context.Context, sel ast.SelectionSet, v model.MtgFilterEntries) graphql.Marshaler {
	return ec._MTG_Filter_Entries(ctx, sel, &v)
}

func (ec *executionContext) marshalNMTG_Filter_Entries2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterEntries(ctx context.Context, sel ast.SelectionSet, v *model.MtgFilterEntries) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._MTG_Filter_Entries(ctx, sel, v)
}

func (ec *executionContext) marshalNMTG_Filter_Expansion2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterExpansionᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.MtgFilterExpansion) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMTG_Filter_Expansion2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterExpansion(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNMTG_Filter_Expansion2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterExpansion(ctx context.Context, sel ast.SelectionSet, v *model.MtgFilterExpansion) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._MTG_Filter_Expansion(ctx, sel, v)
}

func (ec *executionContext) unmarshalNMTG_Filter_GameInput2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterGameInputᚄ(ctx context.Context, v any) ([]*model.MtgFilterGameInput, error) {
	var vSlice []any
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.MtgFilterGameInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNMTG_Filter_GameInput2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterGameInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNMTG_Filter_GameInput2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterGameInput(ctx context.Context, v any) (*model.MtgFilterGameInput, error) {
	res, err := ec.unmarshalInputMTG_Filter_GameInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNMTG_Filter_LayoutInput2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterLayoutInputᚄ(ctx context.Context, v any) ([]*model.MtgFilterLayoutInput, error) {
	var vSlice []any
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.MtgFilterLayoutInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNMTG_Filter_LayoutInput2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterLayoutInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNMTG_Filter_LayoutInput2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterLayoutInput(ctx context.Context, v any) (*model.MtgFilterLayoutInput, error) {
	res, err := ec.unmarshalInputMTG_Filter_LayoutInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNMTG_Filter_Legality2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterLegality(ctx context.Context, sel ast.SelectionSet, v *model.MtgFilterLegality) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._MTG_Filter_Legality(ctx, sel, v)
}

func (ec *executionContext) unmarshalNMTG_Filter_LegalityEntryInput2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterLegalityEntryInputᚄ(ctx context.Context, v any) ([]*model.MtgFilterLegalityEntryInput, error) {
	var vSlice []any
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.MtgFilterLegalityEntryInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNMTG_Filter_LegalityEntryInput2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterLegalityEntryInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNMTG_Filter_LegalityEntryInput2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterLegalityEntryInput(ctx context.Context, v any) (*model.MtgFilterLegalityEntryInput, error) {
	res, err := ec.unmarshalInputMTG_Filter_LegalityEntryInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNMTG_Filter_LegalityInput2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterLegalityInputᚄ(ctx context.Context, v any) ([]*model.MtgFilterLegalityInput, error) {
	var vSlice []any
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.MtgFilterLegalityInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNMTG_Filter_LegalityInput2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterLegalityInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNMTG_Filter_LegalityInput2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterLegalityInput(ctx context.Context, v any) (*model.MtgFilterLegalityInput, error) {
	res, err := ec.unmarshalInputMTG_Filter_LegalityInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNMTG_Filter_ManaCostInput2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterManaCostInputᚄ(ctx context.Context, v any) ([]*model.MtgFilterManaCostInput, error) {
	var vSlice []any
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.MtgFilterManaCostInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNMTG_Filter_ManaCostInput2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterManaCostInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNMTG_Filter_ManaCostInput2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterManaCostInput(ctx context.Context, v any) (*model.MtgFilterManaCostInput, error) {
	res, err := ec.unmarshalInputMTG_Filter_ManaCostInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNMTG_Filter_PaginationInput2magicᚑhelperᚋgraphᚋmodelᚐMtgFilterPaginationInput(ctx context.Context, v any) (model.MtgFilterPaginationInput, error) {
	res, err := ec.unmarshalInputMTG_Filter_PaginationInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNMTG_Filter_RarityInput2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterRarityInputᚄ(ctx context.Context, v any) ([]*model.MtgFilterRarityInput, error) {
	var vSlice []any
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.MtgFilterRarityInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNMTG_Filter_RarityInput2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterRarityInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNMTG_Filter_RarityInput2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterRarityInput(ctx context.Context, v any) (*model.MtgFilterRarityInput, error) {
	res, err := ec.unmarshalInputMTG_Filter_RarityInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNMTG_Filter_RatingInput2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterRatingInput(ctx context.Context, v any) (*model.MtgFilterRatingInput, error) {
	res, err := ec.unmarshalInputMTG_Filter_RatingInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNMTG_Filter_Search2magicᚑhelperᚋgraphᚋmodelᚐMtgFilterSearch(ctx context.Context, sel ast.SelectionSet, v model.MtgFilterSearch) graphql.Marshaler {
	return ec._MTG_Filter_Search(ctx, sel, &v)
}

func (ec *executionContext) marshalNMTG_Filter_Search2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterSearch(ctx context.Context, sel ast.SelectionSet, v *model.MtgFilterSearch) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._MTG_Filter_Search(ctx, sel, v)
}

func (ec *executionContext) unmarshalNMTG_Filter_SearchInput2magicᚑhelperᚋgraphᚋmodelᚐMtgFilterSearchInput(ctx context.Context, v any) (model.MtgFilterSearchInput, error) {
	res, err := ec.unmarshalInputMTG_Filter_SearchInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNMTG_Filter_SetInput2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterSetInputᚄ(ctx context.Context, v any) ([]*model.MtgFilterSetInput, error) {
	var vSlice []any
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.MtgFilterSetInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNMTG_Filter_SetInput2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterSetInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNMTG_Filter_SetInput2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterSetInput(ctx context.Context, v any) (*model.MtgFilterSetInput, error) {
	res, err := ec.unmarshalInputMTG_Filter_SetInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNMTG_Filter_SortBy2magicᚑhelperᚋgraphᚋmodelᚐMtgFilterSortBy(ctx context.Context, v any) (model.MtgFilterSortBy, error) {
	var res model.MtgFilterSortBy
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNMTG_Filter_SortBy2magicᚑhelperᚋgraphᚋmodelᚐMtgFilterSortBy(ctx context.Context, sel ast.SelectionSet, v model.MtgFilterSortBy) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNMTG_Filter_SortDirection2magicᚑhelperᚋgraphᚋmodelᚐMtgFilterSortDirection(ctx context.Context, v any) (model.MtgFilterSortDirection, error) {
	var res model.MtgFilterSortDirection
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNMTG_Filter_SortDirection2magicᚑhelperᚋgraphᚋmodelᚐMtgFilterSortDirection(ctx context.Context, sel ast.SelectionSet, v model.MtgFilterSortDirection) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNMTG_Filter_SortInput2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterSortInputᚄ(ctx context.Context, v any) ([]*model.MtgFilterSortInput, error) {
	var vSlice []any
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.MtgFilterSortInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNMTG_Filter_SortInput2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterSortInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNMTG_Filter_SortInput2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterSortInput(ctx context.Context, v any) (*model.MtgFilterSortInput, error) {
	res, err := ec.unmarshalInputMTG_Filter_SortInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNMTG_Filter_SubtypeInput2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterSubtypeInputᚄ(ctx context.Context, v any) ([]*model.MtgFilterSubtypeInput, error) {
	var vSlice []any
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.MtgFilterSubtypeInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNMTG_Filter_SubtypeInput2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterSubtypeInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNMTG_Filter_SubtypeInput2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterSubtypeInput(ctx context.Context, v any) (*model.MtgFilterSubtypeInput, error) {
	res, err := ec.unmarshalInputMTG_Filter_SubtypeInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNMTG_Filter_TagInput2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterTagInputᚄ(ctx context.Context, v any) ([]*model.MtgFilterTagInput, error) {
	var vSlice []any
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.MtgFilterTagInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNMTG_Filter_TagInput2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterTagInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNMTG_Filter_TagInput2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterTagInput(ctx context.Context, v any) (*model.MtgFilterTagInput, error) {
	res, err := ec.unmarshalInputMTG_Filter_TagInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNMTG_Game2magicᚑhelperᚋgraphᚋmodelᚐMtgGame(ctx context.Context, v any) (model.MtgGame, error) {
	var res model.MtgGame
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNMTG_Game2magicᚑhelperᚋgraphᚋmodelᚐMtgGame(ctx context.Context, sel ast.SelectionSet, v model.MtgGame) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNMTG_Game2ᚕmagicᚑhelperᚋgraphᚋmodelᚐMtgGameᚄ(ctx context.Context, v any) ([]model.MtgGame, error) {
	var vSlice []any
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]model.MtgGame, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNMTG_Game2magicᚑhelperᚋgraphᚋmodelᚐMtgGame(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNMTG_Game2ᚕmagicᚑhelperᚋgraphᚋmodelᚐMtgGameᚄ(ctx context.Context, sel ast.SelectionSet, v []model.MtgGame) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMTG_Game2magicᚑhelperᚋgraphᚋmodelᚐMtgGame(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNMTG_Layout2magicᚑhelperᚋgraphᚋmodelᚐMtgLayout(ctx context.Context, v any) (model.MtgLayout, error) {
	var res model.MtgLayout
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNMTG_Layout2magicᚑhelperᚋgraphᚋmodelᚐMtgLayout(ctx context.Context, sel ast.SelectionSet, v model.MtgLayout) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNMTG_Layout2ᚕmagicᚑhelperᚋgraphᚋmodelᚐMtgLayoutᚄ(ctx context.Context, v any) ([]model.MtgLayout, error) {
	var vSlice []any
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]model.MtgLayout, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNMTG_Layout2magicᚑhelperᚋgraphᚋmodelᚐMtgLayout(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNMTG_Layout2ᚕmagicᚑhelperᚋgraphᚋmodelᚐMtgLayoutᚄ(ctx context.Context, sel ast.SelectionSet, v []model.MtgLayout) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMTG_Layout2magicᚑhelperᚋgraphᚋmodelᚐMtgLayout(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNMTG_Rarity2magicᚑhelperᚋgraphᚋmodelᚐMtgRarity(ctx context.Context, v any) (model.MtgRarity, error) {
	var res model.MtgRarity
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNMTG_Rarity2magicᚑhelperᚋgraphᚋmodelᚐMtgRarity(ctx context.Context, sel ast.SelectionSet, v model.MtgRarity) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNMTG_RemoveCardFromCardPackageInput2magicᚑhelperᚋgraphᚋmodelᚐMtgRemoveCardFromCardPackageInput(ctx context.Context, v any) (model.MtgRemoveCardFromCardPackageInput, error) {
	res, err := ec.unmarshalInputMTG_RemoveCardFromCardPackageInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNMTG_UpdateDeckInput2magicᚑhelperᚋgraphᚋmodelᚐMtgUpdateDeckInput(ctx context.Context, v any) (model.MtgUpdateDeckInput, error) {
	res, err := ec.unmarshalInputMTG_UpdateDeckInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNMainOrSide2magicᚑhelperᚋgraphᚋmodelᚐMainOrSide(ctx context.Context, v any) (model.MainOrSide, error) {
	var res model.MainOrSide
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNMainOrSide2magicᚑhelperᚋgraphᚋmodelᚐMainOrSide(ctx context.Context, sel ast.SelectionSet, v model.MainOrSide) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNMap2map(ctx context.Context, v any) (map[string]any, error) {
	res, err := graphql.UnmarshalMap(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNMap2map(ctx context.Context, sel ast.SelectionSet, v map[string]any) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	res := graphql.MarshalMap(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNPhantom2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐPhantomᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.Phantom) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPhantom2ᚖmagicᚑhelperᚋgraphᚋmodelᚐPhantom(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNPhantom2ᚖmagicᚑhelperᚋgraphᚋmodelᚐPhantom(ctx context.Context, sel ast.SelectionSet, v *model.Phantom) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Phantom(ctx, sel, v)
}

func (ec *executionContext) unmarshalNPhantomInput2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐPhantomInputᚄ(ctx context.Context, v any) ([]*model.PhantomInput, error) {
	var vSlice []any
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.PhantomInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNPhantomInput2ᚖmagicᚑhelperᚋgraphᚋmodelᚐPhantomInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNPhantomInput2ᚖmagicᚑhelperᚋgraphᚋmodelᚐPhantomInput(ctx context.Context, v any) (*model.PhantomInput, error) {
	res, err := ec.unmarshalInputPhantomInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNPosition2ᚖmagicᚑhelperᚋgraphᚋmodelᚐPosition(ctx context.Context, sel ast.SelectionSet, v *model.Position) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Position(ctx, sel, v)
}

func (ec *executionContext) unmarshalNPositionInput2ᚖmagicᚑhelperᚋgraphᚋmodelᚐPositionInput(ctx context.Context, v any) (*model.PositionInput, error) {
	res, err := ec.unmarshalInputPositionInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNRatableEntityType2magicᚑhelperᚋgraphᚋmodelᚐRatableEntityType(ctx context.Context, v any) (model.RatableEntityType, error) {
	var res model.RatableEntityType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNRatableEntityType2magicᚑhelperᚋgraphᚋmodelᚐRatableEntityType(ctx context.Context, sel ast.SelectionSet, v model.RatableEntityType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNRateInput2magicᚑhelperᚋgraphᚋmodelᚐRateInput(ctx context.Context, v any) (model.RateInput, error) {
	res, err := ec.unmarshalInputRateInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNRemoveIgnoredCardInput2magicᚑhelperᚋgraphᚋmodelᚐRemoveIgnoredCardInput(ctx context.Context, v any) (model.RemoveIgnoredCardInput, error) {
	res, err := ec.unmarshalInputRemoveIgnoredCardInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNResponse2magicᚑhelperᚋgraphᚋmodelᚐResponse(ctx context.Context, sel ast.SelectionSet, v model.Response) graphql.Marshaler {
	return ec._Response(ctx, sel, &v)
}

func (ec *executionContext) marshalNResponse2ᚖmagicᚑhelperᚋgraphᚋmodelᚐResponse(ctx context.Context, sel ast.SelectionSet, v *model.Response) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Response(ctx, sel, v)
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v any) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNString2ᚕstringᚄ(ctx context.Context, v any) ([]string, error) {
	var vSlice []any
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNString2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNTag2magicᚑhelperᚋgraphᚋmodelᚐTag(ctx context.Context, sel ast.SelectionSet, v model.Tag) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Tag(ctx, sel, v)
}

func (ec *executionContext) marshalNTag2ᚕmagicᚑhelperᚋgraphᚋmodelᚐTagᚄ(ctx context.Context, sel ast.SelectionSet, v []model.Tag) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTag2magicᚑhelperᚋgraphᚋmodelᚐTag(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNTagType2magicᚑhelperᚋgraphᚋmodelᚐTagType(ctx context.Context, v any) (model.TagType, error) {
	var res model.TagType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTagType2magicᚑhelperᚋgraphᚋmodelᚐTagType(ctx context.Context, sel ast.SelectionSet, v model.TagType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNTernaryBoolean2magicᚑhelperᚋgraphᚋmodelᚐTernaryBoolean(ctx context.Context, v any) (model.TernaryBoolean, error) {
	var res model.TernaryBoolean
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTernaryBoolean2magicᚑhelperᚋgraphᚋmodelᚐTernaryBoolean(ctx context.Context, sel ast.SelectionSet, v model.TernaryBoolean) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNUnassignTagInput2magicᚑhelperᚋgraphᚋmodelᚐUnassignTagInput(ctx context.Context, v any) (model.UnassignTagInput, error) {
	res, err := ec.unmarshalInputUnassignTagInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateTagInput2magicᚑhelperᚋgraphᚋmodelᚐUpdateTagInput(ctx context.Context, v any) (model.UpdateTagInput, error) {
	res, err := ec.unmarshalInputUpdateTagInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUser2ᚖmagicᚑhelperᚋgraphᚋmodelᚐUser(ctx context.Context, sel ast.SelectionSet, v *model.User) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._User(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUserRole2magicᚑhelperᚋgraphᚋmodelᚐUserRole(ctx context.Context, v any) (model.UserRole, error) {
	var res model.UserRole
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUserRole2magicᚑhelperᚋgraphᚋmodelᚐUserRole(ctx context.Context, sel ast.SelectionSet, v model.UserRole) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNUserRole2ᚕmagicᚑhelperᚋgraphᚋmodelᚐUserRoleᚄ(ctx context.Context, v any) ([]model.UserRole, error) {
	var vSlice []any
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]model.UserRole, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNUserRole2magicᚑhelperᚋgraphᚋmodelᚐUserRole(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNUserRole2ᚕmagicᚑhelperᚋgraphᚋmodelᚐUserRoleᚄ(ctx context.Context, sel ast.SelectionSet, v []model.UserRole) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNUserRole2magicᚑhelperᚋgraphᚋmodelᚐUserRole(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirectiveᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v any) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2ᚕstringᚄ(ctx context.Context, v any) ([]string, error) {
	var vSlice []any
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v any) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalOAdminImportReport2ᚖmagicᚑhelperᚋgraphᚋmodelᚐAdminImportReport(ctx context.Context, sel ast.SelectionSet, v *model.AdminImportReport) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._AdminImportReport(ctx, sel, v)
}

func (ec *executionContext) marshalOAdminLegalitiesDiff2ᚖmagicᚑhelperᚋgraphᚋmodelᚐAdminLegalitiesDiff(ctx context.Context, sel ast.SelectionSet, v *model.AdminLegalitiesDiff) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._AdminLegalitiesDiff(ctx, sel, v)
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v any) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	return res
}

func (ec *executionContext) unmarshalOBoolean2ᚖbool(ctx context.Context, v any) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalBoolean(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2ᚖbool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalBoolean(*v)
	return res
}

func (ec *executionContext) unmarshalOFloat2ᚖfloat64(ctx context.Context, v any) (*float64, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalFloatContext(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOFloat2ᚖfloat64(ctx context.Context, sel ast.SelectionSet, v *float64) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalFloatContext(*v)
	return graphql.WrapContextMarshaler(ctx, res)
}

func (ec *executionContext) unmarshalOID2ᚖstring(ctx context.Context, v any) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalID(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOID2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalID(*v)
	return res
}

func (ec *executionContext) unmarshalOInt2ᚖint(ctx context.Context, v any) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalInt(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2ᚖint(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalInt(*v)
	return res
}

func (ec *executionContext) marshalOMTG_CardFace2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgCardFaceᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.MtgCardFace) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMTG_CardFace2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgCardFace(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOMTG_Color2ᚕmagicᚑhelperᚋgraphᚋmodelᚐMtgColorᚄ(ctx context.Context, v any) ([]model.MtgColor, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]model.MtgColor, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNMTG_Color2magicᚑhelperᚋgraphᚋmodelᚐMtgColor(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOMTG_Color2ᚕmagicᚑhelperᚋgraphᚋmodelᚐMtgColorᚄ(ctx context.Context, sel ast.SelectionSet, v []model.MtgColor) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMTG_Color2magicᚑhelperᚋgraphᚋmodelᚐMtgColor(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOMTG_DeckCardFrontImageInput2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgDeckCardFrontImageInput(ctx context.Context, v any) (*model.MtgDeckCardFrontImageInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputMTG_DeckCardFrontImageInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOMTG_Deck_CardFrontImage2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgDeckCardFrontImage(ctx context.Context, sel ast.SelectionSet, v *model.MtgDeckCardFrontImage) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._MTG_Deck_CardFrontImage(ctx, sel, v)
}

func (ec *executionContext) marshalOMTG_Image2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgImage(ctx context.Context, sel ast.SelectionSet, v *model.MtgImage) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._MTG_Image(ctx, sel, v)
}

func (ec *executionContext) unmarshalOMTG_Layout2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgLayout(ctx context.Context, v any) (*model.MtgLayout, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.MtgLayout)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOMTG_Layout2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgLayout(ctx context.Context, sel ast.SelectionSet, v *model.MtgLayout) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOMap2map(ctx context.Context, v any) (map[string]any, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalMap(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOMap2map(ctx context.Context, sel ast.SelectionSet, v map[string]any) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalMap(v)
	return res
}

func (ec *executionContext) unmarshalOString2ᚕstringᚄ(ctx context.Context, v any) ([]string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOString2ᚖstring(ctx context.Context, v any) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalString(*v)
	return res
}

func (ec *executionContext) marshalOTag2magicᚑhelperᚋgraphᚋmodelᚐTag(ctx context.Context, sel ast.SelectionSet, v model.Tag) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Tag(ctx, sel, v)
}

func (ec *executionContext) marshalOUserRating2ᚖmagicᚑhelperᚋgraphᚋmodelᚐUserRating(ctx context.Context, sel ast.SelectionSet, v *model.UserRating) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._UserRating(ctx, sel, v)
}

func (ec *executionContext) marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐFieldᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************
