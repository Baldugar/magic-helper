// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package gentypes

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"magic-helper/graph/model"
	"strconv"
	"sync"
	"sync/atomic"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Mutation() MutationResolver
	Query() QueryResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	AdminDashboard struct {
		Imports              func(childComplexity int) int
		LatestLegalitiesDiff func(childComplexity int) int
	}

	AdminImportReport struct {
		CompletedAt      func(childComplexity int) int
		DurationMs       func(childComplexity int) int
		ErrorMessage     func(childComplexity int) int
		ID               func(childComplexity int) int
		JobName          func(childComplexity int) int
		Metadata         func(childComplexity int) int
		RecordsProcessed func(childComplexity int) int
		StartedAt        func(childComplexity int) int
		Status           func(childComplexity int) int
	}

	AdminImportSummary struct {
		JobName     func(childComplexity int) int
		LastRun     func(childComplexity int) int
		Latency     func(childComplexity int) int
		PreviousRun func(childComplexity int) int
	}

	AdminLatencyMetrics struct {
		AvgDurationMs  func(childComplexity int) int
		LastDurationMs func(childComplexity int) int
		LastStartedAt  func(childComplexity int) int
		P50DurationMs  func(childComplexity int) int
		P90DurationMs  func(childComplexity int) int
		TotalRuns      func(childComplexity int) int
	}

	AdminLegalitiesDiff struct {
		Entries  func(childComplexity int) int
		ImportID func(childComplexity int) int
		JobName  func(childComplexity int) int
	}

	AdminLegalitiesDiffEntry struct {
		CardID         func(childComplexity int) int
		CardName       func(childComplexity int) int
		ChangedAt      func(childComplexity int) int
		CurrentStatus  func(childComplexity int) int
		Format         func(childComplexity int) int
		PreviousStatus func(childComplexity int) int
		SetCode        func(childComplexity int) int
		SetName        func(childComplexity int) int
	}

	CardTag struct {
		Description func(childComplexity int) int
		ID          func(childComplexity int) int
		MyRating    func(childComplexity int) int
		Name        func(childComplexity int) int
	}

	DeckTag struct {
		Colors      func(childComplexity int) int
		Description func(childComplexity int) int
		ID          func(childComplexity int) int
		MyRating    func(childComplexity int) int
		Name        func(childComplexity int) int
	}

	FlowZone struct {
		CardChildren func(childComplexity int) int
		Height       func(childComplexity int) int
		ID           func(childComplexity int) int
		Name         func(childComplexity int) int
		Position     func(childComplexity int) int
		Width        func(childComplexity int) int
		ZoneChildren func(childComplexity int) int
	}

	MTG_Card struct {
		CardTags       func(childComplexity int) int
		Cmc            func(childComplexity int) int
		ColorIdentity  func(childComplexity int) int
		ColorIndicator func(childComplexity int) int
		Colors         func(childComplexity int) int
		DeckTags       func(childComplexity int) int
		EDHRecRank     func(childComplexity int) int
		ID             func(childComplexity int) int
		Keywords       func(childComplexity int) int
		Layout         func(childComplexity int) int
		Loyalty        func(childComplexity int) int
		ManaCost       func(childComplexity int) int
		MyRating       func(childComplexity int) int
		Name           func(childComplexity int) int
		OracleText     func(childComplexity int) int
		Power          func(childComplexity int) int
		ProducedMana   func(childComplexity int) int
		Toughness      func(childComplexity int) int
		TypeLine       func(childComplexity int) int
		Versions       func(childComplexity int) int
	}

	MTG_CardFace struct {
		Artist         func(childComplexity int) int
		Cmc            func(childComplexity int) int
		ColorIndicator func(childComplexity int) int
		Colors         func(childComplexity int) int
		FlavorText     func(childComplexity int) int
		ImageUris      func(childComplexity int) int
		Layout         func(childComplexity int) int
		Loyalty        func(childComplexity int) int
		ManaCost       func(childComplexity int) int
		Name           func(childComplexity int) int
		OracleText     func(childComplexity int) int
		Power          func(childComplexity int) int
		Toughness      func(childComplexity int) int
		TypeLine       func(childComplexity int) int
	}

	MTG_CardFace_Dashboard struct {
		ImageUris func(childComplexity int) int
	}

	MTG_CardPackage struct {
		Cards    func(childComplexity int) int
		ID       func(childComplexity int) int
		IsPublic func(childComplexity int) int
		Name     func(childComplexity int) int
		OwnerID  func(childComplexity int) int
		Zones    func(childComplexity int) int
	}

	MTG_CardPackageCard struct {
		Card              func(childComplexity int) int
		Count             func(childComplexity int) int
		MainOrSide        func(childComplexity int) int
		Phantoms          func(childComplexity int) int
		Position          func(childComplexity int) int
		SelectedVersionID func(childComplexity int) int
	}

	MTG_CardVersion struct {
		Artist      func(childComplexity int) int
		CardFaces   func(childComplexity int) int
		FlavorName  func(childComplexity int) int
		FlavorText  func(childComplexity int) int
		Games       func(childComplexity int) int
		ID          func(childComplexity int) int
		ImageUris   func(childComplexity int) int
		IsAlchemy   func(childComplexity int) int
		IsDefault   func(childComplexity int) int
		Lang        func(childComplexity int) int
		Legalities  func(childComplexity int) int
		PrintedName func(childComplexity int) int
		Rarity      func(childComplexity int) int
		ReleasedAt  func(childComplexity int) int
		Reprint     func(childComplexity int) int
		Set         func(childComplexity int) int
		SetID       func(childComplexity int) int
		SetName     func(childComplexity int) int
		SetType     func(childComplexity int) int
		Variation   func(childComplexity int) int
		VariationOf func(childComplexity int) int
	}

	MTG_CardVersion_Dashboard struct {
		CardFaces func(childComplexity int) int
		ID        func(childComplexity int) int
		ImageUris func(childComplexity int) int
		IsAlchemy func(childComplexity int) int
		IsDefault func(childComplexity int) int
	}

	MTG_Card_Dashboard struct {
		ID       func(childComplexity int) int
		Versions func(childComplexity int) int
	}

	MTG_Deck struct {
		CardFrontImage func(childComplexity int) int
		Cards          func(childComplexity int) int
		ID             func(childComplexity int) int
		IgnoredCards   func(childComplexity int) int
		Name           func(childComplexity int) int
		Zones          func(childComplexity int) int
	}

	MTG_DeckCard struct {
		Card              func(childComplexity int) int
		Count             func(childComplexity int) int
		DeckCardType      func(childComplexity int) int
		MainOrSide        func(childComplexity int) int
		Phantoms          func(childComplexity int) int
		Position          func(childComplexity int) int
		SelectedVersionID func(childComplexity int) int
	}

	MTG_DeckCard_Dashboard struct {
		Card              func(childComplexity int) int
		SelectedVersionID func(childComplexity int) int
	}

	MTG_DeckDashboard struct {
		CardFrontImage func(childComplexity int) int
		Cards          func(childComplexity int) int
		ID             func(childComplexity int) int
		Name           func(childComplexity int) int
	}

	MTG_Deck_CardFrontImage struct {
		CardID    func(childComplexity int) int
		Image     func(childComplexity int) int
		VersionID func(childComplexity int) int
	}

	MTG_Filter_CardTypes struct {
		CardType func(childComplexity int) int
		Subtypes func(childComplexity int) int
	}

	MTG_Filter_Entries struct {
		Expansions func(childComplexity int) int
		Layouts    func(childComplexity int) int
		Legality   func(childComplexity int) int
		Types      func(childComplexity int) int
	}

	MTG_Filter_Expansion struct {
		Games      func(childComplexity int) int
		ImageURL   func(childComplexity int) int
		ReleasedAt func(childComplexity int) int
		Set        func(childComplexity int) int
		SetName    func(childComplexity int) int
		SetType    func(childComplexity int) int
	}

	MTG_Filter_Legality struct {
		Formats        func(childComplexity int) int
		LegalityValues func(childComplexity int) int
	}

	MTG_Filter_Search struct {
		PagedCards func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	MTG_Image struct {
		ArtCrop    func(childComplexity int) int
		BorderCrop func(childComplexity int) int
		Large      func(childComplexity int) int
		Normal     func(childComplexity int) int
		Png        func(childComplexity int) int
		Small      func(childComplexity int) int
	}

	Mutation struct {
		AddIgnoredCard               func(childComplexity int, input model.AddIgnoredCardInput) int
		AddMTGCardToCardPackage      func(childComplexity int, input model.MtgAddCardToCardPackageInput) int
		AdminBackfillImport          func(childComplexity int, input model.AdminImportActionInput) int
		AdminRetryImport             func(childComplexity int, input model.AdminImportActionInput) int
		AssignTag                    func(childComplexity int, input model.AssignTagInput) int
		CreateMTGCardPackage         func(childComplexity int, input model.MtgCreateCardPackageInput) int
		CreateMTGDeck                func(childComplexity int, input model.MtgCreateDeckInput) int
		CreateTag                    func(childComplexity int, input model.CreateTagInput) int
		DeleteMTGCardPackage         func(childComplexity int, input model.MtgDeleteCardPackageInput) int
		DeleteMTGDeck                func(childComplexity int, input model.MtgDeleteDeckInput) int
		DeleteTag                    func(childComplexity int, tagID string) int
		EditMTGCardPackageName       func(childComplexity int, input model.MtgEditCardPackageNameInput) int
		EditMTGCardPackageVisibility func(childComplexity int, input model.MtgEditCardPackageVisibilityInput) int
		Rate                         func(childComplexity int, input model.RateInput) int
		RemoveIgnoredCard            func(childComplexity int, input model.RemoveIgnoredCardInput) int
		RemoveMTGCardFromCardPackage func(childComplexity int, input model.MtgRemoveCardFromCardPackageInput) int
		SaveMTGDeckAsCopy            func(childComplexity int, input model.MtgUpdateDeckInput) int
		UnassignTag                  func(childComplexity int, input model.UnassignTagInput) int
		UpdateMTGDeck                func(childComplexity int, input model.MtgUpdateDeckInput) int
		UpdateTag                    func(childComplexity int, input model.UpdateTagInput) int
	}

	Phantom struct {
		ID       func(childComplexity int) int
		Position func(childComplexity int) int
	}

	Position struct {
		X func(childComplexity int) int
		Y func(childComplexity int) int
	}

	Query struct {
		AdminDashboard      func(childComplexity int) int
		AdminImportReports  func(childComplexity int, job model.AdminJob, limit *int) int
		AdminLegalitiesDiff func(childComplexity int, importID string) int
		CardTags            func(childComplexity int) int
		DeckTags            func(childComplexity int) int
		GetMTGCardPackages  func(childComplexity int, cardPackageID *string, includePublic *bool) int
		GetMTGCards         func(childComplexity int) int
		GetMTGCardsFiltered func(childComplexity int, filter model.MtgFilterSearchInput, pagination model.MtgFilterPaginationInput, sort []*model.MtgFilterSortInput) int
		GetMTGDeck          func(childComplexity int, deckID string) int
		GetMTGDecks         func(childComplexity int) int
		GetMTGFilters       func(childComplexity int) int
		Tag                 func(childComplexity int, id string) int
		Tags                func(childComplexity int) int
	}

	Response struct {
		Message func(childComplexity int) int
		Status  func(childComplexity int) int
	}

	User struct {
		ID    func(childComplexity int) int
		Roles func(childComplexity int) int
	}

	UserRating struct {
		User  func(childComplexity int) int
		Value func(childComplexity int) int
	}
}

type MutationResolver interface {
	CreateMTGDeck(ctx context.Context, input model.MtgCreateDeckInput) (*model.Response, error)
	DeleteMTGDeck(ctx context.Context, input model.MtgDeleteDeckInput) (*model.Response, error)
	UpdateMTGDeck(ctx context.Context, input model.MtgUpdateDeckInput) (*model.Response, error)
	SaveMTGDeckAsCopy(ctx context.Context, input model.MtgUpdateDeckInput) (*model.Response, error)
	CreateMTGCardPackage(ctx context.Context, input model.MtgCreateCardPackageInput) (*model.Response, error)
	DeleteMTGCardPackage(ctx context.Context, input model.MtgDeleteCardPackageInput) (*model.Response, error)
	EditMTGCardPackageName(ctx context.Context, input model.MtgEditCardPackageNameInput) (*model.Response, error)
	EditMTGCardPackageVisibility(ctx context.Context, input model.MtgEditCardPackageVisibilityInput) (*model.Response, error)
	AddMTGCardToCardPackage(ctx context.Context, input model.MtgAddCardToCardPackageInput) (*model.Response, error)
	RemoveMTGCardFromCardPackage(ctx context.Context, input model.MtgRemoveCardFromCardPackageInput) (*model.Response, error)
	CreateTag(ctx context.Context, input model.CreateTagInput) (*model.Response, error)
	UpdateTag(ctx context.Context, input model.UpdateTagInput) (*model.Response, error)
	DeleteTag(ctx context.Context, tagID string) (*model.Response, error)
	AssignTag(ctx context.Context, input model.AssignTagInput) (*model.Response, error)
	UnassignTag(ctx context.Context, input model.UnassignTagInput) (*model.Response, error)
	Rate(ctx context.Context, input model.RateInput) (*model.Response, error)
	AddIgnoredCard(ctx context.Context, input model.AddIgnoredCardInput) (*model.Response, error)
	RemoveIgnoredCard(ctx context.Context, input model.RemoveIgnoredCardInput) (*model.Response, error)
	AdminRetryImport(ctx context.Context, input model.AdminImportActionInput) (*model.Response, error)
	AdminBackfillImport(ctx context.Context, input model.AdminImportActionInput) (*model.Response, error)
}
type QueryResolver interface {
	GetMTGCards(ctx context.Context) ([]*model.MtgCard, error)
	GetMTGCardsFiltered(ctx context.Context, filter model.MtgFilterSearchInput, pagination model.MtgFilterPaginationInput, sort []*model.MtgFilterSortInput) (*model.MtgFilterSearch, error)
	GetMTGFilters(ctx context.Context) (*model.MtgFilterEntries, error)
	GetMTGDecks(ctx context.Context) ([]*model.MtgDeckDashboard, error)
	GetMTGDeck(ctx context.Context, deckID string) (*model.MtgDeck, error)
	GetMTGCardPackages(ctx context.Context, cardPackageID *string, includePublic *bool) ([]*model.MtgCardPackage, error)
	Tags(ctx context.Context) ([]model.Tag, error)
	CardTags(ctx context.Context) ([]*model.CardTag, error)
	DeckTags(ctx context.Context) ([]*model.DeckTag, error)
	Tag(ctx context.Context, id string) (model.Tag, error)
	AdminDashboard(ctx context.Context) (*model.AdminDashboard, error)
	AdminLegalitiesDiff(ctx context.Context, importID string) (*model.AdminLegalitiesDiff, error)
	AdminImportReports(ctx context.Context, job model.AdminJob, limit *int) ([]*model.AdminImportReport, error)
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]any) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "AdminDashboard.imports":
		if e.complexity.AdminDashboard.Imports == nil {
			break
		}

		return e.complexity.AdminDashboard.Imports(childComplexity), true

	case "AdminDashboard.latestLegalitiesDiff":
		if e.complexity.AdminDashboard.LatestLegalitiesDiff == nil {
			break
		}

		return e.complexity.AdminDashboard.LatestLegalitiesDiff(childComplexity), true

	case "AdminImportReport.completedAt":
		if e.complexity.AdminImportReport.CompletedAt == nil {
			break
		}

		return e.complexity.AdminImportReport.CompletedAt(childComplexity), true

	case "AdminImportReport.durationMs":
		if e.complexity.AdminImportReport.DurationMs == nil {
			break
		}

		return e.complexity.AdminImportReport.DurationMs(childComplexity), true

	case "AdminImportReport.errorMessage":
		if e.complexity.AdminImportReport.ErrorMessage == nil {
			break
		}

		return e.complexity.AdminImportReport.ErrorMessage(childComplexity), true

	case "AdminImportReport.id":
		if e.complexity.AdminImportReport.ID == nil {
			break
		}

		return e.complexity.AdminImportReport.ID(childComplexity), true

	case "AdminImportReport.jobName":
		if e.complexity.AdminImportReport.JobName == nil {
			break
		}

		return e.complexity.AdminImportReport.JobName(childComplexity), true

	case "AdminImportReport.metadata":
		if e.complexity.AdminImportReport.Metadata == nil {
			break
		}

		return e.complexity.AdminImportReport.Metadata(childComplexity), true

	case "AdminImportReport.recordsProcessed":
		if e.complexity.AdminImportReport.RecordsProcessed == nil {
			break
		}

		return e.complexity.AdminImportReport.RecordsProcessed(childComplexity), true

	case "AdminImportReport.startedAt":
		if e.complexity.AdminImportReport.StartedAt == nil {
			break
		}

		return e.complexity.AdminImportReport.StartedAt(childComplexity), true

	case "AdminImportReport.status":
		if e.complexity.AdminImportReport.Status == nil {
			break
		}

		return e.complexity.AdminImportReport.Status(childComplexity), true

	case "AdminImportSummary.jobName":
		if e.complexity.AdminImportSummary.JobName == nil {
			break
		}

		return e.complexity.AdminImportSummary.JobName(childComplexity), true

	case "AdminImportSummary.lastRun":
		if e.complexity.AdminImportSummary.LastRun == nil {
			break
		}

		return e.complexity.AdminImportSummary.LastRun(childComplexity), true

	case "AdminImportSummary.latency":
		if e.complexity.AdminImportSummary.Latency == nil {
			break
		}

		return e.complexity.AdminImportSummary.Latency(childComplexity), true

	case "AdminImportSummary.previousRun":
		if e.complexity.AdminImportSummary.PreviousRun == nil {
			break
		}

		return e.complexity.AdminImportSummary.PreviousRun(childComplexity), true

	case "AdminLatencyMetrics.avgDurationMs":
		if e.complexity.AdminLatencyMetrics.AvgDurationMs == nil {
			break
		}

		return e.complexity.AdminLatencyMetrics.AvgDurationMs(childComplexity), true

	case "AdminLatencyMetrics.lastDurationMs":
		if e.complexity.AdminLatencyMetrics.LastDurationMs == nil {
			break
		}

		return e.complexity.AdminLatencyMetrics.LastDurationMs(childComplexity), true

	case "AdminLatencyMetrics.lastStartedAt":
		if e.complexity.AdminLatencyMetrics.LastStartedAt == nil {
			break
		}

		return e.complexity.AdminLatencyMetrics.LastStartedAt(childComplexity), true

	case "AdminLatencyMetrics.p50DurationMs":
		if e.complexity.AdminLatencyMetrics.P50DurationMs == nil {
			break
		}

		return e.complexity.AdminLatencyMetrics.P50DurationMs(childComplexity), true

	case "AdminLatencyMetrics.p90DurationMs":
		if e.complexity.AdminLatencyMetrics.P90DurationMs == nil {
			break
		}

		return e.complexity.AdminLatencyMetrics.P90DurationMs(childComplexity), true

	case "AdminLatencyMetrics.totalRuns":
		if e.complexity.AdminLatencyMetrics.TotalRuns == nil {
			break
		}

		return e.complexity.AdminLatencyMetrics.TotalRuns(childComplexity), true

	case "AdminLegalitiesDiff.entries":
		if e.complexity.AdminLegalitiesDiff.Entries == nil {
			break
		}

		return e.complexity.AdminLegalitiesDiff.Entries(childComplexity), true

	case "AdminLegalitiesDiff.importId":
		if e.complexity.AdminLegalitiesDiff.ImportID == nil {
			break
		}

		return e.complexity.AdminLegalitiesDiff.ImportID(childComplexity), true

	case "AdminLegalitiesDiff.jobName":
		if e.complexity.AdminLegalitiesDiff.JobName == nil {
			break
		}

		return e.complexity.AdminLegalitiesDiff.JobName(childComplexity), true

	case "AdminLegalitiesDiffEntry.cardID":
		if e.complexity.AdminLegalitiesDiffEntry.CardID == nil {
			break
		}

		return e.complexity.AdminLegalitiesDiffEntry.CardID(childComplexity), true

	case "AdminLegalitiesDiffEntry.cardName":
		if e.complexity.AdminLegalitiesDiffEntry.CardName == nil {
			break
		}

		return e.complexity.AdminLegalitiesDiffEntry.CardName(childComplexity), true

	case "AdminLegalitiesDiffEntry.changedAt":
		if e.complexity.AdminLegalitiesDiffEntry.ChangedAt == nil {
			break
		}

		return e.complexity.AdminLegalitiesDiffEntry.ChangedAt(childComplexity), true

	case "AdminLegalitiesDiffEntry.currentStatus":
		if e.complexity.AdminLegalitiesDiffEntry.CurrentStatus == nil {
			break
		}

		return e.complexity.AdminLegalitiesDiffEntry.CurrentStatus(childComplexity), true

	case "AdminLegalitiesDiffEntry.format":
		if e.complexity.AdminLegalitiesDiffEntry.Format == nil {
			break
		}

		return e.complexity.AdminLegalitiesDiffEntry.Format(childComplexity), true

	case "AdminLegalitiesDiffEntry.previousStatus":
		if e.complexity.AdminLegalitiesDiffEntry.PreviousStatus == nil {
			break
		}

		return e.complexity.AdminLegalitiesDiffEntry.PreviousStatus(childComplexity), true

	case "AdminLegalitiesDiffEntry.setCode":
		if e.complexity.AdminLegalitiesDiffEntry.SetCode == nil {
			break
		}

		return e.complexity.AdminLegalitiesDiffEntry.SetCode(childComplexity), true

	case "AdminLegalitiesDiffEntry.setName":
		if e.complexity.AdminLegalitiesDiffEntry.SetName == nil {
			break
		}

		return e.complexity.AdminLegalitiesDiffEntry.SetName(childComplexity), true

	case "CardTag.description":
		if e.complexity.CardTag.Description == nil {
			break
		}

		return e.complexity.CardTag.Description(childComplexity), true

	case "CardTag.ID":
		if e.complexity.CardTag.ID == nil {
			break
		}

		return e.complexity.CardTag.ID(childComplexity), true

	case "CardTag.myRating":
		if e.complexity.CardTag.MyRating == nil {
			break
		}

		return e.complexity.CardTag.MyRating(childComplexity), true

	case "CardTag.name":
		if e.complexity.CardTag.Name == nil {
			break
		}

		return e.complexity.CardTag.Name(childComplexity), true

	case "DeckTag.colors":
		if e.complexity.DeckTag.Colors == nil {
			break
		}

		return e.complexity.DeckTag.Colors(childComplexity), true

	case "DeckTag.description":
		if e.complexity.DeckTag.Description == nil {
			break
		}

		return e.complexity.DeckTag.Description(childComplexity), true

	case "DeckTag.ID":
		if e.complexity.DeckTag.ID == nil {
			break
		}

		return e.complexity.DeckTag.ID(childComplexity), true

	case "DeckTag.myRating":
		if e.complexity.DeckTag.MyRating == nil {
			break
		}

		return e.complexity.DeckTag.MyRating(childComplexity), true

	case "DeckTag.name":
		if e.complexity.DeckTag.Name == nil {
			break
		}

		return e.complexity.DeckTag.Name(childComplexity), true

	case "FlowZone.cardChildren":
		if e.complexity.FlowZone.CardChildren == nil {
			break
		}

		return e.complexity.FlowZone.CardChildren(childComplexity), true

	case "FlowZone.height":
		if e.complexity.FlowZone.Height == nil {
			break
		}

		return e.complexity.FlowZone.Height(childComplexity), true

	case "FlowZone.ID":
		if e.complexity.FlowZone.ID == nil {
			break
		}

		return e.complexity.FlowZone.ID(childComplexity), true

	case "FlowZone.name":
		if e.complexity.FlowZone.Name == nil {
			break
		}

		return e.complexity.FlowZone.Name(childComplexity), true

	case "FlowZone.position":
		if e.complexity.FlowZone.Position == nil {
			break
		}

		return e.complexity.FlowZone.Position(childComplexity), true

	case "FlowZone.width":
		if e.complexity.FlowZone.Width == nil {
			break
		}

		return e.complexity.FlowZone.Width(childComplexity), true

	case "FlowZone.zoneChildren":
		if e.complexity.FlowZone.ZoneChildren == nil {
			break
		}

		return e.complexity.FlowZone.ZoneChildren(childComplexity), true

	case "MTG_Card.cardTags":
		if e.complexity.MTG_Card.CardTags == nil {
			break
		}

		return e.complexity.MTG_Card.CardTags(childComplexity), true

	case "MTG_Card.CMC":
		if e.complexity.MTG_Card.Cmc == nil {
			break
		}

		return e.complexity.MTG_Card.Cmc(childComplexity), true

	case "MTG_Card.colorIdentity":
		if e.complexity.MTG_Card.ColorIdentity == nil {
			break
		}

		return e.complexity.MTG_Card.ColorIdentity(childComplexity), true

	case "MTG_Card.colorIndicator":
		if e.complexity.MTG_Card.ColorIndicator == nil {
			break
		}

		return e.complexity.MTG_Card.ColorIndicator(childComplexity), true

	case "MTG_Card.colors":
		if e.complexity.MTG_Card.Colors == nil {
			break
		}

		return e.complexity.MTG_Card.Colors(childComplexity), true

	case "MTG_Card.deckTags":
		if e.complexity.MTG_Card.DeckTags == nil {
			break
		}

		return e.complexity.MTG_Card.DeckTags(childComplexity), true

	case "MTG_Card.EDHRecRank":
		if e.complexity.MTG_Card.EDHRecRank == nil {
			break
		}

		return e.complexity.MTG_Card.EDHRecRank(childComplexity), true

	case "MTG_Card.ID":
		if e.complexity.MTG_Card.ID == nil {
			break
		}

		return e.complexity.MTG_Card.ID(childComplexity), true

	case "MTG_Card.keywords":
		if e.complexity.MTG_Card.Keywords == nil {
			break
		}

		return e.complexity.MTG_Card.Keywords(childComplexity), true

	case "MTG_Card.layout":
		if e.complexity.MTG_Card.Layout == nil {
			break
		}

		return e.complexity.MTG_Card.Layout(childComplexity), true

	case "MTG_Card.loyalty":
		if e.complexity.MTG_Card.Loyalty == nil {
			break
		}

		return e.complexity.MTG_Card.Loyalty(childComplexity), true

	case "MTG_Card.manaCost":
		if e.complexity.MTG_Card.ManaCost == nil {
			break
		}

		return e.complexity.MTG_Card.ManaCost(childComplexity), true

	case "MTG_Card.myRating":
		if e.complexity.MTG_Card.MyRating == nil {
			break
		}

		return e.complexity.MTG_Card.MyRating(childComplexity), true

	case "MTG_Card.name":
		if e.complexity.MTG_Card.Name == nil {
			break
		}

		return e.complexity.MTG_Card.Name(childComplexity), true

	case "MTG_Card.oracleText":
		if e.complexity.MTG_Card.OracleText == nil {
			break
		}

		return e.complexity.MTG_Card.OracleText(childComplexity), true

	case "MTG_Card.power":
		if e.complexity.MTG_Card.Power == nil {
			break
		}

		return e.complexity.MTG_Card.Power(childComplexity), true

	case "MTG_Card.producedMana":
		if e.complexity.MTG_Card.ProducedMana == nil {
			break
		}

		return e.complexity.MTG_Card.ProducedMana(childComplexity), true

	case "MTG_Card.toughness":
		if e.complexity.MTG_Card.Toughness == nil {
			break
		}

		return e.complexity.MTG_Card.Toughness(childComplexity), true

	case "MTG_Card.typeLine":
		if e.complexity.MTG_Card.TypeLine == nil {
			break
		}

		return e.complexity.MTG_Card.TypeLine(childComplexity), true

	case "MTG_Card.versions":
		if e.complexity.MTG_Card.Versions == nil {
			break
		}

		return e.complexity.MTG_Card.Versions(childComplexity), true

	case "MTG_CardFace.artist":
		if e.complexity.MTG_CardFace.Artist == nil {
			break
		}

		return e.complexity.MTG_CardFace.Artist(childComplexity), true

	case "MTG_CardFace.CMC":
		if e.complexity.MTG_CardFace.Cmc == nil {
			break
		}

		return e.complexity.MTG_CardFace.Cmc(childComplexity), true

	case "MTG_CardFace.colorIndicator":
		if e.complexity.MTG_CardFace.ColorIndicator == nil {
			break
		}

		return e.complexity.MTG_CardFace.ColorIndicator(childComplexity), true

	case "MTG_CardFace.colors":
		if e.complexity.MTG_CardFace.Colors == nil {
			break
		}

		return e.complexity.MTG_CardFace.Colors(childComplexity), true

	case "MTG_CardFace.flavorText":
		if e.complexity.MTG_CardFace.FlavorText == nil {
			break
		}

		return e.complexity.MTG_CardFace.FlavorText(childComplexity), true

	case "MTG_CardFace.imageUris":
		if e.complexity.MTG_CardFace.ImageUris == nil {
			break
		}

		return e.complexity.MTG_CardFace.ImageUris(childComplexity), true

	case "MTG_CardFace.layout":
		if e.complexity.MTG_CardFace.Layout == nil {
			break
		}

		return e.complexity.MTG_CardFace.Layout(childComplexity), true

	case "MTG_CardFace.loyalty":
		if e.complexity.MTG_CardFace.Loyalty == nil {
			break
		}

		return e.complexity.MTG_CardFace.Loyalty(childComplexity), true

	case "MTG_CardFace.manaCost":
		if e.complexity.MTG_CardFace.ManaCost == nil {
			break
		}

		return e.complexity.MTG_CardFace.ManaCost(childComplexity), true

	case "MTG_CardFace.name":
		if e.complexity.MTG_CardFace.Name == nil {
			break
		}

		return e.complexity.MTG_CardFace.Name(childComplexity), true

	case "MTG_CardFace.oracleText":
		if e.complexity.MTG_CardFace.OracleText == nil {
			break
		}

		return e.complexity.MTG_CardFace.OracleText(childComplexity), true

	case "MTG_CardFace.power":
		if e.complexity.MTG_CardFace.Power == nil {
			break
		}

		return e.complexity.MTG_CardFace.Power(childComplexity), true

	case "MTG_CardFace.toughness":
		if e.complexity.MTG_CardFace.Toughness == nil {
			break
		}

		return e.complexity.MTG_CardFace.Toughness(childComplexity), true

	case "MTG_CardFace.typeLine":
		if e.complexity.MTG_CardFace.TypeLine == nil {
			break
		}

		return e.complexity.MTG_CardFace.TypeLine(childComplexity), true

	case "MTG_CardFace_Dashboard.imageUris":
		if e.complexity.MTG_CardFace_Dashboard.ImageUris == nil {
			break
		}

		return e.complexity.MTG_CardFace_Dashboard.ImageUris(childComplexity), true

	case "MTG_CardPackage.cards":
		if e.complexity.MTG_CardPackage.Cards == nil {
			break
		}

		return e.complexity.MTG_CardPackage.Cards(childComplexity), true

	case "MTG_CardPackage.ID":
		if e.complexity.MTG_CardPackage.ID == nil {
			break
		}

		return e.complexity.MTG_CardPackage.ID(childComplexity), true

	case "MTG_CardPackage.isPublic":
		if e.complexity.MTG_CardPackage.IsPublic == nil {
			break
		}

		return e.complexity.MTG_CardPackage.IsPublic(childComplexity), true

	case "MTG_CardPackage.name":
		if e.complexity.MTG_CardPackage.Name == nil {
			break
		}

		return e.complexity.MTG_CardPackage.Name(childComplexity), true

	case "MTG_CardPackage.ownerID":
		if e.complexity.MTG_CardPackage.OwnerID == nil {
			break
		}

		return e.complexity.MTG_CardPackage.OwnerID(childComplexity), true

	case "MTG_CardPackage.zones":
		if e.complexity.MTG_CardPackage.Zones == nil {
			break
		}

		return e.complexity.MTG_CardPackage.Zones(childComplexity), true

	case "MTG_CardPackageCard.card":
		if e.complexity.MTG_CardPackageCard.Card == nil {
			break
		}

		return e.complexity.MTG_CardPackageCard.Card(childComplexity), true

	case "MTG_CardPackageCard.count":
		if e.complexity.MTG_CardPackageCard.Count == nil {
			break
		}

		return e.complexity.MTG_CardPackageCard.Count(childComplexity), true

	case "MTG_CardPackageCard.mainOrSide":
		if e.complexity.MTG_CardPackageCard.MainOrSide == nil {
			break
		}

		return e.complexity.MTG_CardPackageCard.MainOrSide(childComplexity), true

	case "MTG_CardPackageCard.phantoms":
		if e.complexity.MTG_CardPackageCard.Phantoms == nil {
			break
		}

		return e.complexity.MTG_CardPackageCard.Phantoms(childComplexity), true

	case "MTG_CardPackageCard.position":
		if e.complexity.MTG_CardPackageCard.Position == nil {
			break
		}

		return e.complexity.MTG_CardPackageCard.Position(childComplexity), true

	case "MTG_CardPackageCard.selectedVersionID":
		if e.complexity.MTG_CardPackageCard.SelectedVersionID == nil {
			break
		}

		return e.complexity.MTG_CardPackageCard.SelectedVersionID(childComplexity), true

	case "MTG_CardVersion.artist":
		if e.complexity.MTG_CardVersion.Artist == nil {
			break
		}

		return e.complexity.MTG_CardVersion.Artist(childComplexity), true

	case "MTG_CardVersion.cardFaces":
		if e.complexity.MTG_CardVersion.CardFaces == nil {
			break
		}

		return e.complexity.MTG_CardVersion.CardFaces(childComplexity), true

	case "MTG_CardVersion.flavorName":
		if e.complexity.MTG_CardVersion.FlavorName == nil {
			break
		}

		return e.complexity.MTG_CardVersion.FlavorName(childComplexity), true

	case "MTG_CardVersion.flavorText":
		if e.complexity.MTG_CardVersion.FlavorText == nil {
			break
		}

		return e.complexity.MTG_CardVersion.FlavorText(childComplexity), true

	case "MTG_CardVersion.games":
		if e.complexity.MTG_CardVersion.Games == nil {
			break
		}

		return e.complexity.MTG_CardVersion.Games(childComplexity), true

	case "MTG_CardVersion.ID":
		if e.complexity.MTG_CardVersion.ID == nil {
			break
		}

		return e.complexity.MTG_CardVersion.ID(childComplexity), true

	case "MTG_CardVersion.imageUris":
		if e.complexity.MTG_CardVersion.ImageUris == nil {
			break
		}

		return e.complexity.MTG_CardVersion.ImageUris(childComplexity), true

	case "MTG_CardVersion.isAlchemy":
		if e.complexity.MTG_CardVersion.IsAlchemy == nil {
			break
		}

		return e.complexity.MTG_CardVersion.IsAlchemy(childComplexity), true

	case "MTG_CardVersion.isDefault":
		if e.complexity.MTG_CardVersion.IsDefault == nil {
			break
		}

		return e.complexity.MTG_CardVersion.IsDefault(childComplexity), true

	case "MTG_CardVersion.lang":
		if e.complexity.MTG_CardVersion.Lang == nil {
			break
		}

		return e.complexity.MTG_CardVersion.Lang(childComplexity), true

	case "MTG_CardVersion.legalities":
		if e.complexity.MTG_CardVersion.Legalities == nil {
			break
		}

		return e.complexity.MTG_CardVersion.Legalities(childComplexity), true

	case "MTG_CardVersion.printedName":
		if e.complexity.MTG_CardVersion.PrintedName == nil {
			break
		}

		return e.complexity.MTG_CardVersion.PrintedName(childComplexity), true

	case "MTG_CardVersion.rarity":
		if e.complexity.MTG_CardVersion.Rarity == nil {
			break
		}

		return e.complexity.MTG_CardVersion.Rarity(childComplexity), true

	case "MTG_CardVersion.releasedAt":
		if e.complexity.MTG_CardVersion.ReleasedAt == nil {
			break
		}

		return e.complexity.MTG_CardVersion.ReleasedAt(childComplexity), true

	case "MTG_CardVersion.reprint":
		if e.complexity.MTG_CardVersion.Reprint == nil {
			break
		}

		return e.complexity.MTG_CardVersion.Reprint(childComplexity), true

	case "MTG_CardVersion.set":
		if e.complexity.MTG_CardVersion.Set == nil {
			break
		}

		return e.complexity.MTG_CardVersion.Set(childComplexity), true

	case "MTG_CardVersion.setID":
		if e.complexity.MTG_CardVersion.SetID == nil {
			break
		}

		return e.complexity.MTG_CardVersion.SetID(childComplexity), true

	case "MTG_CardVersion.setName":
		if e.complexity.MTG_CardVersion.SetName == nil {
			break
		}

		return e.complexity.MTG_CardVersion.SetName(childComplexity), true

	case "MTG_CardVersion.setType":
		if e.complexity.MTG_CardVersion.SetType == nil {
			break
		}

		return e.complexity.MTG_CardVersion.SetType(childComplexity), true

	case "MTG_CardVersion.variation":
		if e.complexity.MTG_CardVersion.Variation == nil {
			break
		}

		return e.complexity.MTG_CardVersion.Variation(childComplexity), true

	case "MTG_CardVersion.variationOf":
		if e.complexity.MTG_CardVersion.VariationOf == nil {
			break
		}

		return e.complexity.MTG_CardVersion.VariationOf(childComplexity), true

	case "MTG_CardVersion_Dashboard.cardFaces":
		if e.complexity.MTG_CardVersion_Dashboard.CardFaces == nil {
			break
		}

		return e.complexity.MTG_CardVersion_Dashboard.CardFaces(childComplexity), true

	case "MTG_CardVersion_Dashboard.ID":
		if e.complexity.MTG_CardVersion_Dashboard.ID == nil {
			break
		}

		return e.complexity.MTG_CardVersion_Dashboard.ID(childComplexity), true

	case "MTG_CardVersion_Dashboard.imageUris":
		if e.complexity.MTG_CardVersion_Dashboard.ImageUris == nil {
			break
		}

		return e.complexity.MTG_CardVersion_Dashboard.ImageUris(childComplexity), true

	case "MTG_CardVersion_Dashboard.isAlchemy":
		if e.complexity.MTG_CardVersion_Dashboard.IsAlchemy == nil {
			break
		}

		return e.complexity.MTG_CardVersion_Dashboard.IsAlchemy(childComplexity), true

	case "MTG_CardVersion_Dashboard.isDefault":
		if e.complexity.MTG_CardVersion_Dashboard.IsDefault == nil {
			break
		}

		return e.complexity.MTG_CardVersion_Dashboard.IsDefault(childComplexity), true

	case "MTG_Card_Dashboard.ID":
		if e.complexity.MTG_Card_Dashboard.ID == nil {
			break
		}

		return e.complexity.MTG_Card_Dashboard.ID(childComplexity), true

	case "MTG_Card_Dashboard.versions":
		if e.complexity.MTG_Card_Dashboard.Versions == nil {
			break
		}

		return e.complexity.MTG_Card_Dashboard.Versions(childComplexity), true

	case "MTG_Deck.cardFrontImage":
		if e.complexity.MTG_Deck.CardFrontImage == nil {
			break
		}

		return e.complexity.MTG_Deck.CardFrontImage(childComplexity), true

	case "MTG_Deck.cards":
		if e.complexity.MTG_Deck.Cards == nil {
			break
		}

		return e.complexity.MTG_Deck.Cards(childComplexity), true

	case "MTG_Deck.ID":
		if e.complexity.MTG_Deck.ID == nil {
			break
		}

		return e.complexity.MTG_Deck.ID(childComplexity), true

	case "MTG_Deck.ignoredCards":
		if e.complexity.MTG_Deck.IgnoredCards == nil {
			break
		}

		return e.complexity.MTG_Deck.IgnoredCards(childComplexity), true

	case "MTG_Deck.name":
		if e.complexity.MTG_Deck.Name == nil {
			break
		}

		return e.complexity.MTG_Deck.Name(childComplexity), true

	case "MTG_Deck.zones":
		if e.complexity.MTG_Deck.Zones == nil {
			break
		}

		return e.complexity.MTG_Deck.Zones(childComplexity), true

	case "MTG_DeckCard.card":
		if e.complexity.MTG_DeckCard.Card == nil {
			break
		}

		return e.complexity.MTG_DeckCard.Card(childComplexity), true

	case "MTG_DeckCard.count":
		if e.complexity.MTG_DeckCard.Count == nil {
			break
		}

		return e.complexity.MTG_DeckCard.Count(childComplexity), true

	case "MTG_DeckCard.deckCardType":
		if e.complexity.MTG_DeckCard.DeckCardType == nil {
			break
		}

		return e.complexity.MTG_DeckCard.DeckCardType(childComplexity), true

	case "MTG_DeckCard.mainOrSide":
		if e.complexity.MTG_DeckCard.MainOrSide == nil {
			break
		}

		return e.complexity.MTG_DeckCard.MainOrSide(childComplexity), true

	case "MTG_DeckCard.phantoms":
		if e.complexity.MTG_DeckCard.Phantoms == nil {
			break
		}

		return e.complexity.MTG_DeckCard.Phantoms(childComplexity), true

	case "MTG_DeckCard.position":
		if e.complexity.MTG_DeckCard.Position == nil {
			break
		}

		return e.complexity.MTG_DeckCard.Position(childComplexity), true

	case "MTG_DeckCard.selectedVersionID":
		if e.complexity.MTG_DeckCard.SelectedVersionID == nil {
			break
		}

		return e.complexity.MTG_DeckCard.SelectedVersionID(childComplexity), true

	case "MTG_DeckCard_Dashboard.card":
		if e.complexity.MTG_DeckCard_Dashboard.Card == nil {
			break
		}

		return e.complexity.MTG_DeckCard_Dashboard.Card(childComplexity), true

	case "MTG_DeckCard_Dashboard.selectedVersionID":
		if e.complexity.MTG_DeckCard_Dashboard.SelectedVersionID == nil {
			break
		}

		return e.complexity.MTG_DeckCard_Dashboard.SelectedVersionID(childComplexity), true

	case "MTG_DeckDashboard.cardFrontImage":
		if e.complexity.MTG_DeckDashboard.CardFrontImage == nil {
			break
		}

		return e.complexity.MTG_DeckDashboard.CardFrontImage(childComplexity), true

	case "MTG_DeckDashboard.cards":
		if e.complexity.MTG_DeckDashboard.Cards == nil {
			break
		}

		return e.complexity.MTG_DeckDashboard.Cards(childComplexity), true

	case "MTG_DeckDashboard.ID":
		if e.complexity.MTG_DeckDashboard.ID == nil {
			break
		}

		return e.complexity.MTG_DeckDashboard.ID(childComplexity), true

	case "MTG_DeckDashboard.name":
		if e.complexity.MTG_DeckDashboard.Name == nil {
			break
		}

		return e.complexity.MTG_DeckDashboard.Name(childComplexity), true

	case "MTG_Deck_CardFrontImage.cardID":
		if e.complexity.MTG_Deck_CardFrontImage.CardID == nil {
			break
		}

		return e.complexity.MTG_Deck_CardFrontImage.CardID(childComplexity), true

	case "MTG_Deck_CardFrontImage.image":
		if e.complexity.MTG_Deck_CardFrontImage.Image == nil {
			break
		}

		return e.complexity.MTG_Deck_CardFrontImage.Image(childComplexity), true

	case "MTG_Deck_CardFrontImage.versionID":
		if e.complexity.MTG_Deck_CardFrontImage.VersionID == nil {
			break
		}

		return e.complexity.MTG_Deck_CardFrontImage.VersionID(childComplexity), true

	case "MTG_Filter_CardTypes.cardType":
		if e.complexity.MTG_Filter_CardTypes.CardType == nil {
			break
		}

		return e.complexity.MTG_Filter_CardTypes.CardType(childComplexity), true

	case "MTG_Filter_CardTypes.subtypes":
		if e.complexity.MTG_Filter_CardTypes.Subtypes == nil {
			break
		}

		return e.complexity.MTG_Filter_CardTypes.Subtypes(childComplexity), true

	case "MTG_Filter_Entries.expansions":
		if e.complexity.MTG_Filter_Entries.Expansions == nil {
			break
		}

		return e.complexity.MTG_Filter_Entries.Expansions(childComplexity), true

	case "MTG_Filter_Entries.layouts":
		if e.complexity.MTG_Filter_Entries.Layouts == nil {
			break
		}

		return e.complexity.MTG_Filter_Entries.Layouts(childComplexity), true

	case "MTG_Filter_Entries.legality":
		if e.complexity.MTG_Filter_Entries.Legality == nil {
			break
		}

		return e.complexity.MTG_Filter_Entries.Legality(childComplexity), true

	case "MTG_Filter_Entries.types":
		if e.complexity.MTG_Filter_Entries.Types == nil {
			break
		}

		return e.complexity.MTG_Filter_Entries.Types(childComplexity), true

	case "MTG_Filter_Expansion.games":
		if e.complexity.MTG_Filter_Expansion.Games == nil {
			break
		}

		return e.complexity.MTG_Filter_Expansion.Games(childComplexity), true

	case "MTG_Filter_Expansion.imageURL":
		if e.complexity.MTG_Filter_Expansion.ImageURL == nil {
			break
		}

		return e.complexity.MTG_Filter_Expansion.ImageURL(childComplexity), true

	case "MTG_Filter_Expansion.releasedAt":
		if e.complexity.MTG_Filter_Expansion.ReleasedAt == nil {
			break
		}

		return e.complexity.MTG_Filter_Expansion.ReleasedAt(childComplexity), true

	case "MTG_Filter_Expansion.set":
		if e.complexity.MTG_Filter_Expansion.Set == nil {
			break
		}

		return e.complexity.MTG_Filter_Expansion.Set(childComplexity), true

	case "MTG_Filter_Expansion.setName":
		if e.complexity.MTG_Filter_Expansion.SetName == nil {
			break
		}

		return e.complexity.MTG_Filter_Expansion.SetName(childComplexity), true

	case "MTG_Filter_Expansion.setType":
		if e.complexity.MTG_Filter_Expansion.SetType == nil {
			break
		}

		return e.complexity.MTG_Filter_Expansion.SetType(childComplexity), true

	case "MTG_Filter_Legality.formats":
		if e.complexity.MTG_Filter_Legality.Formats == nil {
			break
		}

		return e.complexity.MTG_Filter_Legality.Formats(childComplexity), true

	case "MTG_Filter_Legality.legalityValues":
		if e.complexity.MTG_Filter_Legality.LegalityValues == nil {
			break
		}

		return e.complexity.MTG_Filter_Legality.LegalityValues(childComplexity), true

	case "MTG_Filter_Search.pagedCards":
		if e.complexity.MTG_Filter_Search.PagedCards == nil {
			break
		}

		return e.complexity.MTG_Filter_Search.PagedCards(childComplexity), true

	case "MTG_Filter_Search.totalCount":
		if e.complexity.MTG_Filter_Search.TotalCount == nil {
			break
		}

		return e.complexity.MTG_Filter_Search.TotalCount(childComplexity), true

	case "MTG_Image.artCrop":
		if e.complexity.MTG_Image.ArtCrop == nil {
			break
		}

		return e.complexity.MTG_Image.ArtCrop(childComplexity), true

	case "MTG_Image.borderCrop":
		if e.complexity.MTG_Image.BorderCrop == nil {
			break
		}

		return e.complexity.MTG_Image.BorderCrop(childComplexity), true

	case "MTG_Image.large":
		if e.complexity.MTG_Image.Large == nil {
			break
		}

		return e.complexity.MTG_Image.Large(childComplexity), true

	case "MTG_Image.normal":
		if e.complexity.MTG_Image.Normal == nil {
			break
		}

		return e.complexity.MTG_Image.Normal(childComplexity), true

	case "MTG_Image.PNG":
		if e.complexity.MTG_Image.Png == nil {
			break
		}

		return e.complexity.MTG_Image.Png(childComplexity), true

	case "MTG_Image.small":
		if e.complexity.MTG_Image.Small == nil {
			break
		}

		return e.complexity.MTG_Image.Small(childComplexity), true

	case "Mutation.addIgnoredCard":
		if e.complexity.Mutation.AddIgnoredCard == nil {
			break
		}

		args, err := ec.field_Mutation_addIgnoredCard_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddIgnoredCard(childComplexity, args["input"].(model.AddIgnoredCardInput)), true

	case "Mutation.addMTGCardToCardPackage":
		if e.complexity.Mutation.AddMTGCardToCardPackage == nil {
			break
		}

		args, err := ec.field_Mutation_addMTGCardToCardPackage_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddMTGCardToCardPackage(childComplexity, args["input"].(model.MtgAddCardToCardPackageInput)), true

	case "Mutation.adminBackfillImport":
		if e.complexity.Mutation.AdminBackfillImport == nil {
			break
		}

		args, err := ec.field_Mutation_adminBackfillImport_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AdminBackfillImport(childComplexity, args["input"].(model.AdminImportActionInput)), true

	case "Mutation.adminRetryImport":
		if e.complexity.Mutation.AdminRetryImport == nil {
			break
		}

		args, err := ec.field_Mutation_adminRetryImport_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AdminRetryImport(childComplexity, args["input"].(model.AdminImportActionInput)), true

	case "Mutation.assignTag":
		if e.complexity.Mutation.AssignTag == nil {
			break
		}

		args, err := ec.field_Mutation_assignTag_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AssignTag(childComplexity, args["input"].(model.AssignTagInput)), true

	case "Mutation.createMTGCardPackage":
		if e.complexity.Mutation.CreateMTGCardPackage == nil {
			break
		}

		args, err := ec.field_Mutation_createMTGCardPackage_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateMTGCardPackage(childComplexity, args["input"].(model.MtgCreateCardPackageInput)), true

	case "Mutation.createMTGDeck":
		if e.complexity.Mutation.CreateMTGDeck == nil {
			break
		}

		args, err := ec.field_Mutation_createMTGDeck_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateMTGDeck(childComplexity, args["input"].(model.MtgCreateDeckInput)), true

	case "Mutation.createTag":
		if e.complexity.Mutation.CreateTag == nil {
			break
		}

		args, err := ec.field_Mutation_createTag_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateTag(childComplexity, args["input"].(model.CreateTagInput)), true

	case "Mutation.deleteMTGCardPackage":
		if e.complexity.Mutation.DeleteMTGCardPackage == nil {
			break
		}

		args, err := ec.field_Mutation_deleteMTGCardPackage_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteMTGCardPackage(childComplexity, args["input"].(model.MtgDeleteCardPackageInput)), true

	case "Mutation.deleteMTGDeck":
		if e.complexity.Mutation.DeleteMTGDeck == nil {
			break
		}

		args, err := ec.field_Mutation_deleteMTGDeck_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteMTGDeck(childComplexity, args["input"].(model.MtgDeleteDeckInput)), true

	case "Mutation.deleteTag":
		if e.complexity.Mutation.DeleteTag == nil {
			break
		}

		args, err := ec.field_Mutation_deleteTag_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteTag(childComplexity, args["tagID"].(string)), true

	case "Mutation.editMTGCardPackageName":
		if e.complexity.Mutation.EditMTGCardPackageName == nil {
			break
		}

		args, err := ec.field_Mutation_editMTGCardPackageName_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.EditMTGCardPackageName(childComplexity, args["input"].(model.MtgEditCardPackageNameInput)), true

	case "Mutation.editMTGCardPackageVisibility":
		if e.complexity.Mutation.EditMTGCardPackageVisibility == nil {
			break
		}

		args, err := ec.field_Mutation_editMTGCardPackageVisibility_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.EditMTGCardPackageVisibility(childComplexity, args["input"].(model.MtgEditCardPackageVisibilityInput)), true

	case "Mutation.rate":
		if e.complexity.Mutation.Rate == nil {
			break
		}

		args, err := ec.field_Mutation_rate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.Rate(childComplexity, args["input"].(model.RateInput)), true

	case "Mutation.removeIgnoredCard":
		if e.complexity.Mutation.RemoveIgnoredCard == nil {
			break
		}

		args, err := ec.field_Mutation_removeIgnoredCard_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RemoveIgnoredCard(childComplexity, args["input"].(model.RemoveIgnoredCardInput)), true

	case "Mutation.removeMTGCardFromCardPackage":
		if e.complexity.Mutation.RemoveMTGCardFromCardPackage == nil {
			break
		}

		args, err := ec.field_Mutation_removeMTGCardFromCardPackage_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RemoveMTGCardFromCardPackage(childComplexity, args["input"].(model.MtgRemoveCardFromCardPackageInput)), true

	case "Mutation.saveMTGDeckAsCopy":
		if e.complexity.Mutation.SaveMTGDeckAsCopy == nil {
			break
		}

		args, err := ec.field_Mutation_saveMTGDeckAsCopy_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SaveMTGDeckAsCopy(childComplexity, args["input"].(model.MtgUpdateDeckInput)), true

	case "Mutation.unassignTag":
		if e.complexity.Mutation.UnassignTag == nil {
			break
		}

		args, err := ec.field_Mutation_unassignTag_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UnassignTag(childComplexity, args["input"].(model.UnassignTagInput)), true

	case "Mutation.updateMTGDeck":
		if e.complexity.Mutation.UpdateMTGDeck == nil {
			break
		}

		args, err := ec.field_Mutation_updateMTGDeck_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateMTGDeck(childComplexity, args["input"].(model.MtgUpdateDeckInput)), true

	case "Mutation.updateTag":
		if e.complexity.Mutation.UpdateTag == nil {
			break
		}

		args, err := ec.field_Mutation_updateTag_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateTag(childComplexity, args["input"].(model.UpdateTagInput)), true

	case "Phantom.ID":
		if e.complexity.Phantom.ID == nil {
			break
		}

		return e.complexity.Phantom.ID(childComplexity), true

	case "Phantom.position":
		if e.complexity.Phantom.Position == nil {
			break
		}

		return e.complexity.Phantom.Position(childComplexity), true

	case "Position.x":
		if e.complexity.Position.X == nil {
			break
		}

		return e.complexity.Position.X(childComplexity), true

	case "Position.y":
		if e.complexity.Position.Y == nil {
			break
		}

		return e.complexity.Position.Y(childComplexity), true

	case "Query.adminDashboard":
		if e.complexity.Query.AdminDashboard == nil {
			break
		}

		return e.complexity.Query.AdminDashboard(childComplexity), true

	case "Query.adminImportReports":
		if e.complexity.Query.AdminImportReports == nil {
			break
		}

		args, err := ec.field_Query_adminImportReports_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AdminImportReports(childComplexity, args["job"].(model.AdminJob), args["limit"].(*int)), true

	case "Query.adminLegalitiesDiff":
		if e.complexity.Query.AdminLegalitiesDiff == nil {
			break
		}

		args, err := ec.field_Query_adminLegalitiesDiff_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AdminLegalitiesDiff(childComplexity, args["importId"].(string)), true

	case "Query.cardTags":
		if e.complexity.Query.CardTags == nil {
			break
		}

		return e.complexity.Query.CardTags(childComplexity), true

	case "Query.deckTags":
		if e.complexity.Query.DeckTags == nil {
			break
		}

		return e.complexity.Query.DeckTags(childComplexity), true

	case "Query.getMTGCardPackages":
		if e.complexity.Query.GetMTGCardPackages == nil {
			break
		}

		args, err := ec.field_Query_getMTGCardPackages_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetMTGCardPackages(childComplexity, args["cardPackageID"].(*string), args["includePublic"].(*bool)), true

	case "Query.getMTGCards":
		if e.complexity.Query.GetMTGCards == nil {
			break
		}

		return e.complexity.Query.GetMTGCards(childComplexity), true

	case "Query.getMTGCardsFiltered":
		if e.complexity.Query.GetMTGCardsFiltered == nil {
			break
		}

		args, err := ec.field_Query_getMTGCardsFiltered_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetMTGCardsFiltered(childComplexity, args["filter"].(model.MtgFilterSearchInput), args["pagination"].(model.MtgFilterPaginationInput), args["sort"].([]*model.MtgFilterSortInput)), true

	case "Query.getMTGDeck":
		if e.complexity.Query.GetMTGDeck == nil {
			break
		}

		args, err := ec.field_Query_getMTGDeck_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetMTGDeck(childComplexity, args["deckID"].(string)), true

	case "Query.getMTGDecks":
		if e.complexity.Query.GetMTGDecks == nil {
			break
		}

		return e.complexity.Query.GetMTGDecks(childComplexity), true

	case "Query.getMTGFilters":
		if e.complexity.Query.GetMTGFilters == nil {
			break
		}

		return e.complexity.Query.GetMTGFilters(childComplexity), true

	case "Query.tag":
		if e.complexity.Query.Tag == nil {
			break
		}

		args, err := ec.field_Query_tag_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Tag(childComplexity, args["id"].(string)), true

	case "Query.tags":
		if e.complexity.Query.Tags == nil {
			break
		}

		return e.complexity.Query.Tags(childComplexity), true

	case "Response.message":
		if e.complexity.Response.Message == nil {
			break
		}

		return e.complexity.Response.Message(childComplexity), true

	case "Response.status":
		if e.complexity.Response.Status == nil {
			break
		}

		return e.complexity.Response.Status(childComplexity), true

	case "User.ID":
		if e.complexity.User.ID == nil {
			break
		}

		return e.complexity.User.ID(childComplexity), true

	case "User.roles":
		if e.complexity.User.Roles == nil {
			break
		}

		return e.complexity.User.Roles(childComplexity), true

	case "UserRating.user":
		if e.complexity.UserRating.User == nil {
			break
		}

		return e.complexity.UserRating.User(childComplexity), true

	case "UserRating.value":
		if e.complexity.UserRating.Value == nil {
			break
		}

		return e.complexity.UserRating.Value(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	opCtx := graphql.GetOperationContext(ctx)
	ec := executionContext{opCtx, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputAddIgnoredCardInput,
		ec.unmarshalInputAdminImportActionInput,
		ec.unmarshalInputAssignTagInput,
		ec.unmarshalInputCreateTagInput,
		ec.unmarshalInputFlowZoneInput,
		ec.unmarshalInputMTG_AddCardToCardPackageInput,
		ec.unmarshalInputMTG_CardPackageCardInput,
		ec.unmarshalInputMTG_CreateCardPackageInput,
		ec.unmarshalInputMTG_CreateDeckInput,
		ec.unmarshalInputMTG_DeckCardFrontImageInput,
		ec.unmarshalInputMTG_DeckCardInput,
		ec.unmarshalInputMTG_DeleteCardPackageInput,
		ec.unmarshalInputMTG_DeleteDeckInput,
		ec.unmarshalInputMTG_EditCardPackageNameInput,
		ec.unmarshalInputMTG_EditCardPackageVisibilityInput,
		ec.unmarshalInputMTG_Filter_CardTypeInput,
		ec.unmarshalInputMTG_Filter_ColorInput,
		ec.unmarshalInputMTG_Filter_GameInput,
		ec.unmarshalInputMTG_Filter_LayoutInput,
		ec.unmarshalInputMTG_Filter_LegalityEntryInput,
		ec.unmarshalInputMTG_Filter_LegalityInput,
		ec.unmarshalInputMTG_Filter_ManaCostInput,
		ec.unmarshalInputMTG_Filter_PaginationInput,
		ec.unmarshalInputMTG_Filter_RarityInput,
		ec.unmarshalInputMTG_Filter_RatingInput,
		ec.unmarshalInputMTG_Filter_SearchInput,
		ec.unmarshalInputMTG_Filter_SetInput,
		ec.unmarshalInputMTG_Filter_SortInput,
		ec.unmarshalInputMTG_Filter_SubtypeInput,
		ec.unmarshalInputMTG_Filter_TagInput,
		ec.unmarshalInputMTG_RemoveCardFromCardPackageInput,
		ec.unmarshalInputMTG_UpdateDeckInput,
		ec.unmarshalInputPhantomInput,
		ec.unmarshalInputPositionInput,
		ec.unmarshalInputRateInput,
		ec.unmarshalInputRemoveIgnoredCardInput,
		ec.unmarshalInputUnassignTagInput,
		ec.unmarshalInputUpdateTagInput,
	)
	first := true

	switch opCtx.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, opCtx.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, opCtx.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../../../graphql/Admin/enum.graphqls", Input: `"""
Roles that can be assigned to a user.
"""
enum UserRole {
    ADMIN
    USER
}

"""
Background jobs supported by the importer.
"""
enum AdminJob {
    MTG_CARDS
    MTG_SETS
}

"""
Execution status values for an import run.
"""
enum AdminImportStatus {
    RUNNING
    SUCCESS
    FAILED
    SKIPPED
}
`, BuiltIn: false},
	{Name: "../../../graphql/Admin/input.graphqls", Input: `"""
Parameters to trigger or backfill import jobs.
"""
input AdminImportActionInput {
    job: AdminJob!
    force: Boolean = false
}
`, BuiltIn: false},
	{Name: "../../../graphql/Admin/type.graphqls", Input: `"""
Aggregate admin dashboard information.
"""
type AdminDashboard {
    imports: [AdminImportSummary!]!
    latestLegalitiesDiff: AdminLegalitiesDiff
}

"""
Summary for an import job with recent runs and metrics.
"""
type AdminImportSummary {
    jobName: AdminJob!
    lastRun: AdminImportReport
    previousRun: AdminImportReport
    latency: AdminLatencyMetrics!
}

"""
Detailed import report data exposed to admins.
"""
type AdminImportReport {
    id: ID!
    jobName: AdminJob!
    status: AdminImportStatus!
    startedAt: Int!
    completedAt: Int
    durationMs: Int
    recordsProcessed: Int
    errorMessage: String
    metadata: Map
}

"""
Latency metrics derived from recent import runs.
"""
type AdminLatencyMetrics {
    lastDurationMs: Int
    avgDurationMs: Int
    p50DurationMs: Int
    p90DurationMs: Int
    totalRuns: Int!
    lastStartedAt: Int
}

"""
Single legality change entry between consecutive imports.
"""
type AdminLegalitiesDiffEntry {
    cardID: ID!
    cardName: String!
    format: String!
    previousStatus: String
    currentStatus: String
    setCode: String
    setName: String
    changedAt: Int!
}

"""
Collection of legality changes tied to an import run.
"""
type AdminLegalitiesDiff {
    importId: ID!
    jobName: AdminJob!
    entries: [AdminLegalitiesDiffEntry!]!
}
`, BuiltIn: false},
	{Name: "../../../graphql/Flow/input.graphqls", Input: `"""
Used to save the deck builder zones and their children.
"""
input FlowZoneInput {
    ID: ID!
    name: String!
    position: PositionInput!
    width: Float!
    height: Float!
    cardChildren: [ID!]!
    zoneChildren: [ID!]!
}

"""
Used to save the position of an entity in the deck builder.
"""
input PositionInput {
    x: Float!
    y: Float!
}
`, BuiltIn: false},
	{Name: "../../../graphql/Flow/type.graphqls", Input: `"""
Represents a zone in the deck builder.
"""
type FlowZone {
    ID: ID!
    name: String!
    position: Position!
    width: Float!
    height: Float!
    cardChildren: [ID!]!
    zoneChildren: [ID!]!
}

"""
Represents the position of an entity in the deck builder.
"""
type Position {
    x: Float!
    y: Float!
}
`, BuiltIn: false},
	{Name: "../../../graphql/MTG/Card/enum.graphqls", Input: `"""
Magic color identity abbreviations.
"""
enum MTG_Color {
    C
    W
    U
    B
    R
    G
}

"""
Rarity tiers for a printing.
"""
enum MTG_Rarity {
    common
    uncommon
    rare
    mythic
}

"""
Card layouts as defined by Scryfall.
"""
enum MTG_Layout {
    normal
    split
    flip
    transform
    modal_dfc
    meld
    leveler
    class
    case
    saga
    adventure
    mutate
    prototype
    battle
    planar
    scheme
    vanguard
    token
    double_faced_token
    emblem
    augment
    host
    art_series
    reversible_card
}

"""
Game platforms where a print is available.
"""
enum MTG_Game {
    paper
    mtgo
    arena
}
`, BuiltIn: false},
	{Name: "../../../graphql/MTG/Card/type.graphqls", Input: `"""
Aggregated MTG card entity with curated versions and user context.
"""
type MTG_Card {
    ID: ID! @goTag(key: "json", value: "_key")
    layout: MTG_Layout!
    CMC: Float!
    colorIdentity: [MTG_Color!]!
    colorIndicator: [String!]
    colors: [MTG_Color!]
    EDHRecRank: Int
    keywords: [String!]!
    loyalty: String
    manaCost: String
    name: String!
    oracleText: String
    power: String
    producedMana: [MTG_Color!]
    toughness: String
    typeLine: String!
    versions: [MTG_CardVersion!]!
    myRating: UserRating
    cardTags: [CardTag!]!
    deckTags: [DeckTag!]!
}

"""
A specific printing/version of a card used by the app.
"""
type MTG_CardVersion {
    ID: ID!
    isDefault: Boolean!
    isAlchemy: Boolean!
    artist: String
    lang: String!
    flavorName: String
    flavorText: String
    cardFaces: [MTG_CardFace!]
    legalities: Map!
    games: [MTG_Game!]!
    imageUris: MTG_Image
    printedName: String!
    rarity: MTG_Rarity!
    releasedAt: String!
    reprint: Boolean!
    setName: String!
    setType: String!
    set: String!
    setID: String!
    variation: Boolean!
    variationOf: String
}

"""
One face of a multi-faced card version.
"""
type MTG_CardFace {
    artist: String
    CMC: Float
    colorIndicator: [String!]
    colors: [MTG_Color!]
    flavorText: String
    imageUris: MTG_Image
    layout: MTG_Layout
    loyalty: String
    manaCost: String!
    name: String!
    oracleText: String
    power: String
    toughness: String
    typeLine: String
}

"""
Image URLs in multiple sizes from Scryfall.
"""
type MTG_Image {
    artCrop: String!
    borderCrop: String!
    large: String!
    normal: String!
    PNG: String!
    small: String!
}

"""
Minimal card representation for dashboard listings.
"""
type MTG_Card_Dashboard {
    ID: ID! @goTag(key: "json", value: "_key")
    versions: [MTG_CardVersion_Dashboard!]!
}

"""
Minimal card version data for dashboard UI.
"""
type MTG_CardVersion_Dashboard {
    ID: ID!
    isDefault: Boolean!
    isAlchemy: Boolean!
    cardFaces: [MTG_CardFace_Dashboard!]!
    imageUris: MTG_Image
}

"""
Minimal face data for dashboard UI.
"""
type MTG_CardFace_Dashboard {
    imageUris: MTG_Image
}
`, BuiltIn: false},
	{Name: "../../../graphql/MTG/CardPackage/input.graphqls", Input: `"""
Create a new card package.
"""
input MTG_CreateCardPackageInput {
    name: String!
    isPublic: Boolean = false
}

"""
Delete a card package by ID.
"""
input MTG_DeleteCardPackageInput {
    cardPackageID: ID!
}

"""
Edit a card package name.
"""
input MTG_EditCardPackageNameInput {
    cardPackageID: ID!
    name: String!
}
"""
Toggle card package visibility.
"""
input MTG_EditCardPackageVisibilityInput {
    cardPackageID: ID!
    isPublic: Boolean!
}



"""
Add a card to a package with count.
"""
input MTG_AddCardToCardPackageInput {
    cardPackageID: ID!
    card: ID!
    count: Int!
}

"""
Remove a card from a package.
"""
input MTG_RemoveCardFromCardPackageInput {
    cardPackageID: ID!
    card: ID!
}

"""
Card entry details for a package.
"""
input MTG_CardPackageCardInput {
    card: ID!
    selectedVersionID: String
    count: Int!
    mainOrSide: MainOrSide!
}
`, BuiltIn: false},
	{Name: "../../../graphql/MTG/CardPackage/type.graphqls", Input: `"""
A package grouping cards outside of a deck context.
"""
type MTG_CardPackage {
    ID: ID! @goTag(key: "json", value: "_key")
    name: String!
    isPublic: Boolean!
    ownerID: ID
    cards: [MTG_CardPackageCard!]!
    zones: [FlowZone!]!
}

"""
A card entry inside a card package.
"""
type MTG_CardPackageCard {
    card: MTG_Card!
    selectedVersionID: String
    count: Int!
    mainOrSide: MainOrSide!
    position: Position!
    phantoms: [Phantom!]!
}
`, BuiltIn: false},
	{Name: "../../../graphql/MTG/Deck/enum.graphqls", Input: `"""
Supported deck archetypes.
"""
enum DeckType {
    # STANDARD
    BRAWL_60
    BRAWL_100
}

"""
Indicates whether a card is in main or sideboard.
"""
enum MainOrSide {
    MAIN
    SIDEBOARD
}

"""
Card role in deck (normal or commander).
"""
enum MTG_DeckCardType {
    NORMAL
    COMMANDER
}
`, BuiltIn: false},
	{Name: "../../../graphql/MTG/Deck/input.graphqls", Input: `"""
Input to create a new deck.
"""
input MTG_CreateDeckInput {
    name: String!
}

"""
Input to delete a deck by ID.
"""
input MTG_DeleteDeckInput {
    deckID: ID!
}

"""
Input to update deck fields, cards, zones and front image.
"""
input MTG_UpdateDeckInput {
    deckID: ID!
    name: String!
    cardFrontImage: MTG_DeckCardFrontImageInput
    cards: [MTG_DeckCardInput!]!
    zones: [FlowZoneInput!]!
}

"""
Front image selection referencing a card version.
"""
input MTG_DeckCardFrontImageInput {
    cardID: ID!
    versionID: ID!
}

"""
Deck card entry with position and selection metadata.
"""
input MTG_DeckCardInput {
    ID: ID!
    card: ID!
    selectedVersionID: String
    count: Int!
    position: PositionInput!
    mainOrSide: MainOrSide!
    deckCardType: MTG_DeckCardType!
    phantoms: [PhantomInput!]!
}

"""
Phantom placeholder to aid UI grouping.
"""
input PhantomInput {
    ID: ID!
    position: PositionInput!
}
`, BuiltIn: false},
	{Name: "../../../graphql/MTG/Deck/type.graphqls", Input: `"""
A user deck with cards, positions, zones and optional front image.
"""
type MTG_Deck {
    ID: ID! @goTag(key: "json", value: "_key")
    name: String!
    cardFrontImage: MTG_Deck_CardFrontImage
    cards: [MTG_DeckCard!]!
    zones: [FlowZone!]!
    ignoredCards: [String!]!
}

"""
A card entry in a deck with selection and positioning metadata.
"""
type MTG_DeckCard {
    card: MTG_Card!
    selectedVersionID: String
    count: Int!
    position: Position!
    mainOrSide: MainOrSide!
    deckCardType: MTG_DeckCardType!
    phantoms: [Phantom!]!
}

"""
A phantom placeholder used for visual grouping on the board.
"""
type Phantom {
    position: Position!
    ID: ID!
}

"""
Deck summary for dashboard listings.
"""
type MTG_DeckDashboard {
    ID: ID! @goTag(key: "json", value: "_key")
    name: String!
    cardFrontImage: MTG_Deck_CardFrontImage
    cards: [MTG_DeckCard_Dashboard!]!
}

"""
Selected front image for a deck, referencing a card version.
"""
type MTG_Deck_CardFrontImage {
    cardID: ID!
    versionID: ID!
    image: String!
}

"""
Minimal deck card data for dashboard UI.
"""
type MTG_DeckCard_Dashboard {
    card: MTG_Card_Dashboard!
    selectedVersionID: String
}
`, BuiltIn: false},
	{Name: "../../../graphql/MTG/Filter/enum.graphqls", Input: `"""
Three-state boolean used for filter entries.
"""
enum TernaryBoolean {
    TRUE
    FALSE
    UNSET
}

"""
Sortable fields for card lists.
"""
enum MTG_Filter_SortBy {
    NAME
    CMC
    RARITY
    COLOR
    TYPE
    SET
    RELEASED_AT
}

"""
Sort direction.
"""
enum MTG_Filter_SortDirection {
    ASC
    DESC
}
`, BuiltIn: false},
	{Name: "../../../graphql/MTG/Filter/input.graphqls", Input: `"""
Combined filter input used to filter cards.
"""
input MTG_Filter_SearchInput {
    searchString: String
    rarity: [MTG_Filter_RarityInput!]!
    color: [MTG_Filter_ColorInput!]!
    multiColor: TernaryBoolean!
    manaCosts: [MTG_Filter_ManaCostInput!]!
    cardTypes: [MTG_Filter_CardTypeInput!]!
    subtypes: [MTG_Filter_SubtypeInput!]!
    sets: [MTG_Filter_SetInput!]!
    legalities: [MTG_Filter_LegalityInput!]!
    layouts: [MTG_Filter_LayoutInput!]!
    games: [MTG_Filter_GameInput!]!
    hideIgnored: Boolean!
    tags: [MTG_Filter_TagInput!]!
    rating: MTG_Filter_RatingInput!
    commander: ID
    deckID: ID
    isSelectingCommander: Boolean!
}

"""
Rarity filter entry with ternary state.
"""
input MTG_Filter_RarityInput {
    rarity: MTG_Rarity!
    value: TernaryBoolean!
}

"""
Color filter entry with ternary state.
"""
input MTG_Filter_ColorInput {
    color: MTG_Color!
    value: TernaryBoolean!
}

"""
Mana cost filter entry with ternary state or special values.
"""
input MTG_Filter_ManaCostInput {
    manaCost: String!
    value: TernaryBoolean!
}

"""
Card type filter entry with ternary state.
"""
input MTG_Filter_CardTypeInput {
    cardType: String!
    value: TernaryBoolean!
}

"""
Subtype filter entry with ternary state.
"""
input MTG_Filter_SubtypeInput {
    subtype: String!
    value: TernaryBoolean!
}

"""
Set filter entry with ternary state.
"""
input MTG_Filter_SetInput {
    set: String!
    value: TernaryBoolean!
}

"""
Single legality value with ternary state.
"""
input MTG_Filter_LegalityEntryInput {
    legalityValue: String!
    value: TernaryBoolean!
}

"""
Legality format and associated statuses.
"""
input MTG_Filter_LegalityInput {
    format: String!
    legalityEntries: [MTG_Filter_LegalityEntryInput!]!
}

"""
Layout filter entry with ternary state.
"""
input MTG_Filter_LayoutInput {
    layout: MTG_Layout!
    value: TernaryBoolean!
}

"""
Game platform filter entry with ternary state.
"""
input MTG_Filter_GameInput {
    game: MTG_Game!
    value: TernaryBoolean!
}

"""
Tag filter entry by name or id with ternary state.
"""
input MTG_Filter_TagInput {
    tag: String!
    value: TernaryBoolean!
}

"""
Min/max rating bounds for filtering.
"""
input MTG_Filter_RatingInput {
    min: Int
    max: Int
}

"""
Page and page size for cursorless pagination.
"""
input MTG_Filter_PaginationInput {
    page: Int!
    pageSize: Int!
}

"""
Sort directive with field, direction, and enabled flag.
"""
input MTG_Filter_SortInput {
    sortBy: MTG_Filter_SortBy!
    sortDirection: MTG_Filter_SortDirection!
    enabled: Boolean!
}
`, BuiltIn: false},
	{Name: "../../../graphql/MTG/Filter/type.graphqls", Input: `"""
Aggregated entries used to render filter UI.
"""
type MTG_Filter_Entries {
    types: [MTG_Filter_CardTypes!]!
    expansions: [MTG_Filter_Expansion!]!
    legality: MTG_Filter_Legality!
    layouts: [MTG_Layout!]!
}

"""
A card type and its associated subtypes.
"""
type MTG_Filter_CardTypes {
    cardType: String!
    subtypes: [String!]!
}

"""
Distinct legality formats and statuses collected from cards.
"""
type MTG_Filter_Legality {
    formats: [String!]!
    legalityValues: [String!]!
}

"""
Expansion metadata used by filters and sorting.
"""
type MTG_Filter_Expansion {
    set: String!
    setName: String!
    releasedAt: Int!
    imageURL: String!
    setType: String!
    games: [MTG_Game!]!
}

"""
Search results and total count for pagination.
"""
type MTG_Filter_Search {
    pagedCards: [MTG_Card!]!
    totalCount: Int!
}
`, BuiltIn: false},
	{Name: "../../../graphql/MTG/IgnoredCard/input.graphqls", Input: `"""
Mark a card as ignored for the specified deck.
"""
input AddIgnoredCardInput {
    cardID: ID!
    deckID: ID!
}

"""
Remove an ignored mark for a deck/card pair.
"""
input RemoveIgnoredCardInput {
    cardID: ID!
    deckID: ID!
}
`, BuiltIn: false},
	{Name: "../../../graphql/MTG/Tag/type.graphqls", Input: `type DeckTag implements Tag {
    ID: ID! @goTag(key: "json", value: "_key")
    name: String!
    description: String
    # aggregatedRating: AggregatedRating!
    # ratings: [UserRating!]!
    myRating: UserRating
    colors: [MTG_Color!]!
}
`, BuiltIn: false},
	{Name: "../../../graphql/mutation.graphqls", Input: `"""
Root-level write operations.
"""
type Mutation {
    # Decks
    """
    Create a new deck and return its ID in Response.message.
    """
    createMTGDeck(input: MTG_CreateDeckInput!): Response!
    """
    Delete a deck by ID.
    """
    deleteMTGDeck(input: MTG_DeleteDeckInput!): Response!
    """
    Replace deck fields and card edges.
    """
    updateMTGDeck(input: MTG_UpdateDeckInput!): Response!
    """
    Create a new deck by copying another deck's data.
    """
    saveMTGDeckAsCopy(input: MTG_UpdateDeckInput!): Response!
    # Card Packages
    """
    Create a card package container.
    """
    createMTGCardPackage(input: MTG_CreateCardPackageInput!): Response!
    """
    Delete a card package and its edges.
    """
    deleteMTGCardPackage(input: MTG_DeleteCardPackageInput!): Response!
    """
    Edit a card package name.
    """
    editMTGCardPackageName(input: MTG_EditCardPackageNameInput!): Response!
    """
    Update a card package visibility flag.
    """
    editMTGCardPackageVisibility(input: MTG_EditCardPackageVisibilityInput!): Response!
    """
    Add a card to a package (edge insert).
    """
    addMTGCardToCardPackage(input: MTG_AddCardToCardPackageInput!): Response!
    """
    Remove a card from a package (edge delete).
    """
    removeMTGCardFromCardPackage(input: MTG_RemoveCardFromCardPackageInput!): Response!
    # Tags
    """
    Create a tag and optionally link to a card.
    """
    createTag(input: CreateTagInput!): Response!
    """
    Update tag name/description/colors.
    """
    updateTag(input: UpdateTagInput!): Response!
    """
    Delete a tag and its edges.
    """
    deleteTag(tagID: ID!): Response!
    """
    Link a tag to a card.
    """
    assignTag(input: AssignTagInput!): Response!
    """
    Unlink a tag from a card.
    """
    unassignTag(input: UnassignTagInput!): Response!
    # Ratings
    """
    Rate a card or tag.
    """
    rate(input: RateInput!): Response!
    # Ignored Cards
    """
    Mark a card as ignored for a deck.
    """
    addIgnoredCard(input: AddIgnoredCardInput!): Response!
    """
    Remove ignored mark from a deck/card pair.
    """
    removeIgnoredCard(input: RemoveIgnoredCardInput!): Response!
    """
    Trigger a retry of an import job.
    """
    adminRetryImport(input: AdminImportActionInput!): Response!
    """
    Force a backfill import run ignoring scheduling safeguards.
    """
    adminBackfillImport(input: AdminImportActionInput!): Response!
}

`, BuiltIn: false},
	{Name: "../../../graphql/query.graphqls", Input: `"""
Root-level read operations.
"""
type Query {
    # Cards
    """
    Return all curated MTG cards with ratings and tags.
    """
    getMTGCards: [MTG_Card!]!
    getMTGCardsFiltered(
        filter: MTG_Filter_SearchInput!
        pagination: MTG_Filter_PaginationInput!
        sort: [MTG_Filter_SortInput!]!
    ): MTG_Filter_Search!
    """
    Return available filter options (types, layouts, expansions, legalities).
    """
    getMTGFilters: MTG_Filter_Entries!
    # Decks
    """
    List all decks for dashboard view.
    """
    getMTGDecks: [MTG_DeckDashboard!]!
    """
    Return a single deck by ID with cards and metadata.
    """
    getMTGDeck(deckID: ID!): MTG_Deck!
    # Card Packages
    """
    List card packages or fetch one by ID.
    """
    getMTGCardPackages(cardPackageID: ID, includePublic: Boolean = false): [MTG_CardPackage!]!
    # Tags
    """
    Return all tags (card and deck).
    """
    tags: [Tag!]!
    """
    Return only CardTag items.
    """
    cardTags: [CardTag!]!
    """
    Return only DeckTag items.
    """
    deckTags: [DeckTag!]!
    """
    Fetch a tag by ID (CardTag or DeckTag).
    """
    tag(id: ID!): Tag
    """
    Admin dashboard data with import status, metrics, and legality diffs.
    """
    adminDashboard: AdminDashboard!
    """
    Fetch a specific legality diff by import ID.
    """
    adminLegalitiesDiff(importId: ID!): AdminLegalitiesDiff
    """
    List recent import reports for the given job.
    """
    adminImportReports(job: AdminJob!, limit: Int = 25): [AdminImportReport!]!
}

`, BuiltIn: false},
	{Name: "../../../graphql/Rating/enum.graphqls", Input: `"""
Entities that can be rated by users.
"""
enum RatableEntityType {
    CARD
    TAG
}
`, BuiltIn: false},
	{Name: "../../../graphql/Rating/input.graphqls", Input: `"""
Rate a card or tag by ID.
"""
input RateInput {
    entityID: ID!
    entityType: RatableEntityType!
    value: Int!
}
`, BuiltIn: false},
	{Name: "../../../graphql/Rating/type.graphqls", Input: `"""
A user's rating for an entity (card or tag).
"""
type UserRating {
    user: User!
    value: Int!
}
`, BuiltIn: false},
	{Name: "../../../graphql/Tag/enum.graphqls", Input: `"""
Union discriminator for tag concrete types.
"""
enum TagType {
    CardTag
    DeckTag
}
`, BuiltIn: false},
	{Name: "../../../graphql/Tag/input.graphqls", Input: `"""
Create a new tag, optionally linked to a card.
"""
input CreateTagInput {
    type: TagType!
    name: String!
    description: String
    colors: [MTG_Color!]
    cardID: ID
}

"""
Update tag fields.
"""
input UpdateTagInput {
    ID: ID!
    name: String
    description: String
    colors: [MTG_Color!]
}

"""
Assign a tag to a card.
"""
input AssignTagInput {
    tagID: ID!
    cardID: ID!
}

"""
Remove a tag from a card.
"""
input UnassignTagInput {
    tagID: ID!
    cardID: ID!
}
`, BuiltIn: false},
	{Name: "../../../graphql/Tag/type.graphqls", Input: `"""
A tag that can annotate cards or decks.
"""
interface Tag {
    ID: ID! @goTag(key: "json", value: "_key")
    name: String!
    description: String
    myRating: UserRating
}

"""
A tag intended for annotating cards.
"""
type CardTag implements Tag {
    ID: ID! @goTag(key: "json", value: "_key")
    name: String!
    description: String
    myRating: UserRating
}
`, BuiltIn: false},
	{Name: "../../../graphql/type.base.graphqls", Input: `"""
Attach a struct tag to a Go field generated by gqlgen.
"""
directive @goTag(key: String!, value: String) on INPUT_FIELD_DEFINITION | FIELD_DEFINITION
scalar Map

"""
Generic response wrapper with status and optional message.
"""
type Response {
    status: Boolean!
    message: String
}
`, BuiltIn: false},
	{Name: "../../../graphql/User/type.graphqls", Input: `"""
A user entity used for ratings and ownership.
"""
type User {
    ID: ID! @goTag(key: "json", value: "_key")
    roles: [UserRole!]!
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) field_Mutation_addIgnoredCard_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_addIgnoredCard_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_addIgnoredCard_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.AddIgnoredCardInput, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal model.AddIgnoredCardInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNAddIgnoredCardInput2magichelpergraphmodelAddIgnoredCardInput(ctx, tmp)
	}

	var zeroVal model.AddIgnoredCardInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_addMTGCardToCardPackage_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_addMTGCardToCardPackage_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_addMTGCardToCardPackage_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.MtgAddCardToCardPackageInput, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal model.MtgAddCardToCardPackageInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNMTG_AddCardToCardPackageInput2magichelpergraphmodelMtgAddCardToCardPackageInput(ctx, tmp)
	}

	var zeroVal model.MtgAddCardToCardPackageInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_adminBackfillImport_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_adminBackfillImport_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_adminBackfillImport_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.AdminImportActionInput, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal model.AdminImportActionInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNAdminImportActionInput2magichelpergraphmodelAdminImportActionInput(ctx, tmp)
	}

	var zeroVal model.AdminImportActionInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_adminRetryImport_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_adminRetryImport_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_adminRetryImport_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.AdminImportActionInput, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal model.AdminImportActionInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNAdminImportActionInput2magichelpergraphmodelAdminImportActionInput(ctx, tmp)
	}

	var zeroVal model.AdminImportActionInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_assignTag_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_assignTag_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_assignTag_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.AssignTagInput, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal model.AssignTagInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNAssignTagInput2magichelpergraphmodelAssignTagInput(ctx, tmp)
	}

	var zeroVal model.AssignTagInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_createMTGCardPackage_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_createMTGCardPackage_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_createMTGCardPackage_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.MtgCreateCardPackageInput, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal model.MtgCreateCardPackageInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNMTG_CreateCardPackageInput2magichelpergraphmodelMtgCreateCardPackageInput(ctx, tmp)
	}

	var zeroVal model.MtgCreateCardPackageInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_createMTGDeck_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_createMTGDeck_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_createMTGDeck_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.MtgCreateDeckInput, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal model.MtgCreateDeckInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNMTG_CreateDeckInput2magichelpergraphmodelMtgCreateDeckInput(ctx, tmp)
	}

	var zeroVal model.MtgCreateDeckInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_createTag_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_createTag_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_createTag_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.CreateTagInput, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal model.CreateTagInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNCreateTagInput2magichelpergraphmodelCreateTagInput(ctx, tmp)
	}

	var zeroVal model.CreateTagInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_deleteMTGCardPackage_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_deleteMTGCardPackage_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_deleteMTGCardPackage_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.MtgDeleteCardPackageInput, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal model.MtgDeleteCardPackageInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNMTG_DeleteCardPackageInput2magichelpergraphmodelMtgDeleteCardPackageInput(ctx, tmp)
	}

	var zeroVal model.MtgDeleteCardPackageInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_deleteMTGDeck_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_deleteMTGDeck_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_deleteMTGDeck_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.MtgDeleteDeckInput, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal model.MtgDeleteDeckInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNMTG_DeleteDeckInput2magichelpergraphmodelMtgDeleteDeckInput(ctx, tmp)
	}

	var zeroVal model.MtgDeleteDeckInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_deleteTag_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_deleteTag_argsTagID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["tagID"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_deleteTag_argsTagID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["tagID"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("tagID"))
	if tmp, ok := rawArgs["tagID"]; ok {
		return ec.unmarshalNID2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_editMTGCardPackageName_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_editMTGCardPackageName_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_editMTGCardPackageName_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.MtgEditCardPackageNameInput, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal model.MtgEditCardPackageNameInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNMTG_EditCardPackageNameInput2magichelpergraphmodelMtgEditCardPackageNameInput(ctx, tmp)
	}

	var zeroVal model.MtgEditCardPackageNameInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_editMTGCardPackageVisibility_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_editMTGCardPackageVisibility_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_editMTGCardPackageVisibility_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.MtgEditCardPackageVisibilityInput, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal model.MtgEditCardPackageVisibilityInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNMTG_EditCardPackageVisibilityInput2magichelpergraphmodelMtgEditCardPackageVisibilityInput(ctx, tmp)
	}

	var zeroVal model.MtgEditCardPackageVisibilityInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_rate_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_rate_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_rate_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.RateInput, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal model.RateInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNRateInput2magichelpergraphmodelRateInput(ctx, tmp)
	}

	var zeroVal model.RateInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_removeIgnoredCard_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_removeIgnoredCard_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_removeIgnoredCard_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.RemoveIgnoredCardInput, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal model.RemoveIgnoredCardInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNRemoveIgnoredCardInput2magichelpergraphmodelRemoveIgnoredCardInput(ctx, tmp)
	}

	var zeroVal model.RemoveIgnoredCardInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_removeMTGCardFromCardPackage_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_removeMTGCardFromCardPackage_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_removeMTGCardFromCardPackage_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.MtgRemoveCardFromCardPackageInput, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal model.MtgRemoveCardFromCardPackageInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNMTG_RemoveCardFromCardPackageInput2magichelpergraphmodelMtgRemoveCardFromCardPackageInput(ctx, tmp)
	}

	var zeroVal model.MtgRemoveCardFromCardPackageInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_saveMTGDeckAsCopy_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_saveMTGDeckAsCopy_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_saveMTGDeckAsCopy_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.MtgUpdateDeckInput, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal model.MtgUpdateDeckInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNMTG_UpdateDeckInput2magichelpergraphmodelMtgUpdateDeckInput(ctx, tmp)
	}

	var zeroVal model.MtgUpdateDeckInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_unassignTag_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_unassignTag_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_unassignTag_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.UnassignTagInput, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal model.UnassignTagInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNUnassignTagInput2magichelpergraphmodelUnassignTagInput(ctx, tmp)
	}

	var zeroVal model.UnassignTagInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_updateMTGDeck_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_updateMTGDeck_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_updateMTGDeck_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.MtgUpdateDeckInput, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal model.MtgUpdateDeckInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNMTG_UpdateDeckInput2magichelpergraphmodelMtgUpdateDeckInput(ctx, tmp)
	}

	var zeroVal model.MtgUpdateDeckInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_updateTag_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_updateTag_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_updateTag_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.UpdateTagInput, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal model.UpdateTagInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNUpdateTagInput2magichelpergraphmodelUpdateTagInput(ctx, tmp)
	}

	var zeroVal model.UpdateTagInput
	return zeroVal, nil
}

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query___type_argsName(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["name"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query___type_argsName(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["name"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
	if tmp, ok := rawArgs["name"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Query_adminImportReports_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_adminImportReports_argsJob(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["job"] = arg0
	arg1, err := ec.field_Query_adminImportReports_argsLimit(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg1
	return args, nil
}
func (ec *executionContext) field_Query_adminImportReports_argsJob(
	ctx context.Context,
	rawArgs map[string]any,
) (model.AdminJob, error) {
	if _, ok := rawArgs["job"]; !ok {
		var zeroVal model.AdminJob
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("job"))
	if tmp, ok := rawArgs["job"]; ok {
		return ec.unmarshalNAdminJob2magichelpergraphmodelAdminJob(ctx, tmp)
	}

	var zeroVal model.AdminJob
	return zeroVal, nil
}

func (ec *executionContext) field_Query_adminImportReports_argsLimit(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["limit"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
	if tmp, ok := rawArgs["limit"]; ok {
		return ec.unmarshalOInt2int(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Query_adminLegalitiesDiff_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_adminLegalitiesDiff_argsImportID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["importId"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_adminLegalitiesDiff_argsImportID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["importId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("importId"))
	if tmp, ok := rawArgs["importId"]; ok {
		return ec.unmarshalNID2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getMTGCardPackages_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_getMTGCardPackages_argsCardPackageID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["cardPackageID"] = arg0
	arg1, err := ec.field_Query_getMTGCardPackages_argsIncludePublic(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["includePublic"] = arg1
	return args, nil
}
func (ec *executionContext) field_Query_getMTGCardPackages_argsCardPackageID(
	ctx context.Context,
	rawArgs map[string]any,
) (*string, error) {
	if _, ok := rawArgs["cardPackageID"]; !ok {
		var zeroVal *string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("cardPackageID"))
	if tmp, ok := rawArgs["cardPackageID"]; ok {
		return ec.unmarshalOID2string(ctx, tmp)
	}

	var zeroVal *string
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getMTGCardPackages_argsIncludePublic(
	ctx context.Context,
	rawArgs map[string]any,
) (*bool, error) {
	if _, ok := rawArgs["includePublic"]; !ok {
		var zeroVal *bool
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("includePublic"))
	if tmp, ok := rawArgs["includePublic"]; ok {
		return ec.unmarshalOBoolean2bool(ctx, tmp)
	}

	var zeroVal *bool
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getMTGCardsFiltered_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_getMTGCardsFiltered_argsFilter(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["filter"] = arg0
	arg1, err := ec.field_Query_getMTGCardsFiltered_argsPagination(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["pagination"] = arg1
	arg2, err := ec.field_Query_getMTGCardsFiltered_argsSort(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["sort"] = arg2
	return args, nil
}
func (ec *executionContext) field_Query_getMTGCardsFiltered_argsFilter(
	ctx context.Context,
	rawArgs map[string]any,
) (model.MtgFilterSearchInput, error) {
	if _, ok := rawArgs["filter"]; !ok {
		var zeroVal model.MtgFilterSearchInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
	if tmp, ok := rawArgs["filter"]; ok {
		return ec.unmarshalNMTG_Filter_SearchInput2magichelpergraphmodelMtgFilterSearchInput(ctx, tmp)
	}

	var zeroVal model.MtgFilterSearchInput
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getMTGCardsFiltered_argsPagination(
	ctx context.Context,
	rawArgs map[string]any,
) (model.MtgFilterPaginationInput, error) {
	if _, ok := rawArgs["pagination"]; !ok {
		var zeroVal model.MtgFilterPaginationInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
	if tmp, ok := rawArgs["pagination"]; ok {
		return ec.unmarshalNMTG_Filter_PaginationInput2magichelpergraphmodelMtgFilterPaginationInput(ctx, tmp)
	}

	var zeroVal model.MtgFilterPaginationInput
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getMTGCardsFiltered_argsSort(
	ctx context.Context,
	rawArgs map[string]any,
) ([]*model.MtgFilterSortInput, error) {
	if _, ok := rawArgs["sort"]; !ok {
		var zeroVal []*model.MtgFilterSortInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("sort"))
	if tmp, ok := rawArgs["sort"]; ok {
		return ec.unmarshalNMTG_Filter_SortInput2magichelpergraphmodelMtgFilterSortInput(ctx, tmp)
	}

	var zeroVal []*model.MtgFilterSortInput
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getMTGDeck_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_getMTGDeck_argsDeckID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["deckID"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_getMTGDeck_argsDeckID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["deckID"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("deckID"))
	if tmp, ok := rawArgs["deckID"]; ok {
		return ec.unmarshalNID2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Query_tag_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_tag_argsID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_tag_argsID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["id"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
	if tmp, ok := rawArgs["id"]; ok {
		return ec.unmarshalNID2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field___Directive_args_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field___Directive_args_argsIncludeDeprecated(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}
func (ec *executionContext) field___Directive_args_argsIncludeDeprecated(
	ctx context.Context,
	rawArgs map[string]any,
) (*bool, error) {
	if _, ok := rawArgs["includeDeprecated"]; !ok {
		var zeroVal *bool
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		return ec.unmarshalOBoolean2bool(ctx, tmp)
	}

	var zeroVal *bool
	return zeroVal, nil
}

func (ec *executionContext) field___Field_args_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field___Field_args_argsIncludeDeprecated(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}
func (ec *executionContext) field___Field_args_argsIncludeDeprecated(
	ctx context.Context,
	rawArgs map[string]any,
) (*bool, error) {
	if _, ok := rawArgs["includeDeprecated"]; !ok {
		var zeroVal *bool
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		return ec.unmarshalOBoolean2bool(ctx, tmp)
	}

	var zeroVal *bool
	return zeroVal, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field___Type_enumValues_argsIncludeDeprecated(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}
func (ec *executionContext) field___Type_enumValues_argsIncludeDeprecated(
	ctx context.Context,
	rawArgs map[string]any,
) (bool, error) {
	if _, ok := rawArgs["includeDeprecated"]; !ok {
		var zeroVal bool
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		return ec.unmarshalOBoolean2bool(ctx, tmp)
	}

	var zeroVal bool
	return zeroVal, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field___Type_fields_argsIncludeDeprecated(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}
func (ec *executionContext) field___Type_fields_argsIncludeDeprecated(
	ctx context.Context,
	rawArgs map[string]any,
) (bool, error) {
	if _, ok := rawArgs["includeDeprecated"]; !ok {
		var zeroVal bool
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		return ec.unmarshalOBoolean2bool(ctx, tmp)
	}

	var zeroVal bool
	return zeroVal, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _AdminDashboard_imports(ctx context.Context, field graphql.CollectedField, obj *model.AdminDashboard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminDashboard_imports(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Imports, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.AdminImportSummary)
	fc.Result = res
	return ec.marshalNAdminImportSummary2magichelpergraphmodelAdminImportSummary(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminDashboard_imports(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminDashboard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "jobName":
				return ec.fieldContext_AdminImportSummary_jobName(ctx, field)
			case "lastRun":
				return ec.fieldContext_AdminImportSummary_lastRun(ctx, field)
			case "previousRun":
				return ec.fieldContext_AdminImportSummary_previousRun(ctx, field)
			case "latency":
				return ec.fieldContext_AdminImportSummary_latency(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AdminImportSummary", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminDashboard_latestLegalitiesDiff(ctx context.Context, field graphql.CollectedField, obj *model.AdminDashboard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminDashboard_latestLegalitiesDiff(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LatestLegalitiesDiff, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.AdminLegalitiesDiff)
	fc.Result = res
	return ec.marshalOAdminLegalitiesDiff2magichelpergraphmodelAdminLegalitiesDiff(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminDashboard_latestLegalitiesDiff(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminDashboard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "importId":
				return ec.fieldContext_AdminLegalitiesDiff_importId(ctx, field)
			case "jobName":
				return ec.fieldContext_AdminLegalitiesDiff_jobName(ctx, field)
			case "entries":
				return ec.fieldContext_AdminLegalitiesDiff_entries(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AdminLegalitiesDiff", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminImportReport_id(ctx context.Context, field graphql.CollectedField, obj *model.AdminImportReport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminImportReport_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminImportReport_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminImportReport",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminImportReport_jobName(ctx context.Context, field graphql.CollectedField, obj *model.AdminImportReport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminImportReport_jobName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.JobName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.AdminJob)
	fc.Result = res
	return ec.marshalNAdminJob2magichelpergraphmodelAdminJob(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminImportReport_jobName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminImportReport",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type AdminJob does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminImportReport_status(ctx context.Context, field graphql.CollectedField, obj *model.AdminImportReport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminImportReport_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.AdminImportStatus)
	fc.Result = res
	return ec.marshalNAdminImportStatus2magichelpergraphmodelAdminImportStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminImportReport_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminImportReport",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type AdminImportStatus does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminImportReport_startedAt(ctx context.Context, field graphql.CollectedField, obj *model.AdminImportReport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminImportReport_startedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminImportReport_startedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminImportReport",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminImportReport_completedAt(ctx context.Context, field graphql.CollectedField, obj *model.AdminImportReport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminImportReport_completedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CompletedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminImportReport_completedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminImportReport",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminImportReport_durationMs(ctx context.Context, field graphql.CollectedField, obj *model.AdminImportReport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminImportReport_durationMs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DurationMs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminImportReport_durationMs(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminImportReport",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminImportReport_recordsProcessed(ctx context.Context, field graphql.CollectedField, obj *model.AdminImportReport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminImportReport_recordsProcessed(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RecordsProcessed, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminImportReport_recordsProcessed(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminImportReport",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminImportReport_errorMessage(ctx context.Context, field graphql.CollectedField, obj *model.AdminImportReport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminImportReport_errorMessage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ErrorMessage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminImportReport_errorMessage(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminImportReport",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminImportReport_metadata(ctx context.Context, field graphql.CollectedField, obj *model.AdminImportReport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminImportReport_metadata(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Metadata, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]any)
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminImportReport_metadata(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminImportReport",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminImportSummary_jobName(ctx context.Context, field graphql.CollectedField, obj *model.AdminImportSummary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminImportSummary_jobName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.JobName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.AdminJob)
	fc.Result = res
	return ec.marshalNAdminJob2magichelpergraphmodelAdminJob(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminImportSummary_jobName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminImportSummary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type AdminJob does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminImportSummary_lastRun(ctx context.Context, field graphql.CollectedField, obj *model.AdminImportSummary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminImportSummary_lastRun(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastRun, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.AdminImportReport)
	fc.Result = res
	return ec.marshalOAdminImportReport2magichelpergraphmodelAdminImportReport(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminImportSummary_lastRun(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminImportSummary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_AdminImportReport_id(ctx, field)
			case "jobName":
				return ec.fieldContext_AdminImportReport_jobName(ctx, field)
			case "status":
				return ec.fieldContext_AdminImportReport_status(ctx, field)
			case "startedAt":
				return ec.fieldContext_AdminImportReport_startedAt(ctx, field)
			case "completedAt":
				return ec.fieldContext_AdminImportReport_completedAt(ctx, field)
			case "durationMs":
				return ec.fieldContext_AdminImportReport_durationMs(ctx, field)
			case "recordsProcessed":
				return ec.fieldContext_AdminImportReport_recordsProcessed(ctx, field)
			case "errorMessage":
				return ec.fieldContext_AdminImportReport_errorMessage(ctx, field)
			case "metadata":
				return ec.fieldContext_AdminImportReport_metadata(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AdminImportReport", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminImportSummary_previousRun(ctx context.Context, field graphql.CollectedField, obj *model.AdminImportSummary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminImportSummary_previousRun(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PreviousRun, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.AdminImportReport)
	fc.Result = res
	return ec.marshalOAdminImportReport2magichelpergraphmodelAdminImportReport(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminImportSummary_previousRun(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminImportSummary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_AdminImportReport_id(ctx, field)
			case "jobName":
				return ec.fieldContext_AdminImportReport_jobName(ctx, field)
			case "status":
				return ec.fieldContext_AdminImportReport_status(ctx, field)
			case "startedAt":
				return ec.fieldContext_AdminImportReport_startedAt(ctx, field)
			case "completedAt":
				return ec.fieldContext_AdminImportReport_completedAt(ctx, field)
			case "durationMs":
				return ec.fieldContext_AdminImportReport_durationMs(ctx, field)
			case "recordsProcessed":
				return ec.fieldContext_AdminImportReport_recordsProcessed(ctx, field)
			case "errorMessage":
				return ec.fieldContext_AdminImportReport_errorMessage(ctx, field)
			case "metadata":
				return ec.fieldContext_AdminImportReport_metadata(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AdminImportReport", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminImportSummary_latency(ctx context.Context, field graphql.CollectedField, obj *model.AdminImportSummary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminImportSummary_latency(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Latency, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.AdminLatencyMetrics)
	fc.Result = res
	return ec.marshalNAdminLatencyMetrics2magichelpergraphmodelAdminLatencyMetrics(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminImportSummary_latency(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminImportSummary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "lastDurationMs":
				return ec.fieldContext_AdminLatencyMetrics_lastDurationMs(ctx, field)
			case "avgDurationMs":
				return ec.fieldContext_AdminLatencyMetrics_avgDurationMs(ctx, field)
			case "p50DurationMs":
				return ec.fieldContext_AdminLatencyMetrics_p50DurationMs(ctx, field)
			case "p90DurationMs":
				return ec.fieldContext_AdminLatencyMetrics_p90DurationMs(ctx, field)
			case "totalRuns":
				return ec.fieldContext_AdminLatencyMetrics_totalRuns(ctx, field)
			case "lastStartedAt":
				return ec.fieldContext_AdminLatencyMetrics_lastStartedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AdminLatencyMetrics", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminLatencyMetrics_lastDurationMs(ctx context.Context, field graphql.CollectedField, obj *model.AdminLatencyMetrics) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminLatencyMetrics_lastDurationMs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastDurationMs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminLatencyMetrics_lastDurationMs(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminLatencyMetrics",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminLatencyMetrics_avgDurationMs(ctx context.Context, field graphql.CollectedField, obj *model.AdminLatencyMetrics) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminLatencyMetrics_avgDurationMs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AvgDurationMs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminLatencyMetrics_avgDurationMs(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminLatencyMetrics",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminLatencyMetrics_p50DurationMs(ctx context.Context, field graphql.CollectedField, obj *model.AdminLatencyMetrics) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminLatencyMetrics_p50DurationMs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.P50DurationMs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminLatencyMetrics_p50DurationMs(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminLatencyMetrics",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminLatencyMetrics_p90DurationMs(ctx context.Context, field graphql.CollectedField, obj *model.AdminLatencyMetrics) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminLatencyMetrics_p90DurationMs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.P90DurationMs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminLatencyMetrics_p90DurationMs(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminLatencyMetrics",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminLatencyMetrics_totalRuns(ctx context.Context, field graphql.CollectedField, obj *model.AdminLatencyMetrics) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminLatencyMetrics_totalRuns(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalRuns, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminLatencyMetrics_totalRuns(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminLatencyMetrics",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminLatencyMetrics_lastStartedAt(ctx context.Context, field graphql.CollectedField, obj *model.AdminLatencyMetrics) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminLatencyMetrics_lastStartedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastStartedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminLatencyMetrics_lastStartedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminLatencyMetrics",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminLegalitiesDiff_importId(ctx context.Context, field graphql.CollectedField, obj *model.AdminLegalitiesDiff) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminLegalitiesDiff_importId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ImportID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminLegalitiesDiff_importId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminLegalitiesDiff",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminLegalitiesDiff_jobName(ctx context.Context, field graphql.CollectedField, obj *model.AdminLegalitiesDiff) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminLegalitiesDiff_jobName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.JobName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.AdminJob)
	fc.Result = res
	return ec.marshalNAdminJob2magichelpergraphmodelAdminJob(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminLegalitiesDiff_jobName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminLegalitiesDiff",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type AdminJob does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminLegalitiesDiff_entries(ctx context.Context, field graphql.CollectedField, obj *model.AdminLegalitiesDiff) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminLegalitiesDiff_entries(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Entries, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.AdminLegalitiesDiffEntry)
	fc.Result = res
	return ec.marshalNAdminLegalitiesDiffEntry2magichelpergraphmodelAdminLegalitiesDiffEntry(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminLegalitiesDiff_entries(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminLegalitiesDiff",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cardID":
				return ec.fieldContext_AdminLegalitiesDiffEntry_cardID(ctx, field)
			case "cardName":
				return ec.fieldContext_AdminLegalitiesDiffEntry_cardName(ctx, field)
			case "format":
				return ec.fieldContext_AdminLegalitiesDiffEntry_format(ctx, field)
			case "previousStatus":
				return ec.fieldContext_AdminLegalitiesDiffEntry_previousStatus(ctx, field)
			case "currentStatus":
				return ec.fieldContext_AdminLegalitiesDiffEntry_currentStatus(ctx, field)
			case "setCode":
				return ec.fieldContext_AdminLegalitiesDiffEntry_setCode(ctx, field)
			case "setName":
				return ec.fieldContext_AdminLegalitiesDiffEntry_setName(ctx, field)
			case "changedAt":
				return ec.fieldContext_AdminLegalitiesDiffEntry_changedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AdminLegalitiesDiffEntry", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminLegalitiesDiffEntry_cardID(ctx context.Context, field graphql.CollectedField, obj *model.AdminLegalitiesDiffEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminLegalitiesDiffEntry_cardID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CardID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminLegalitiesDiffEntry_cardID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminLegalitiesDiffEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminLegalitiesDiffEntry_cardName(ctx context.Context, field graphql.CollectedField, obj *model.AdminLegalitiesDiffEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminLegalitiesDiffEntry_cardName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CardName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminLegalitiesDiffEntry_cardName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminLegalitiesDiffEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminLegalitiesDiffEntry_format(ctx context.Context, field graphql.CollectedField, obj *model.AdminLegalitiesDiffEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminLegalitiesDiffEntry_format(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Format, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminLegalitiesDiffEntry_format(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminLegalitiesDiffEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminLegalitiesDiffEntry_previousStatus(ctx context.Context, field graphql.CollectedField, obj *model.AdminLegalitiesDiffEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminLegalitiesDiffEntry_previousStatus(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PreviousStatus, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminLegalitiesDiffEntry_previousStatus(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminLegalitiesDiffEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminLegalitiesDiffEntry_currentStatus(ctx context.Context, field graphql.CollectedField, obj *model.AdminLegalitiesDiffEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminLegalitiesDiffEntry_currentStatus(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CurrentStatus, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminLegalitiesDiffEntry_currentStatus(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminLegalitiesDiffEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminLegalitiesDiffEntry_setCode(ctx context.Context, field graphql.CollectedField, obj *model.AdminLegalitiesDiffEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminLegalitiesDiffEntry_setCode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SetCode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminLegalitiesDiffEntry_setCode(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminLegalitiesDiffEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminLegalitiesDiffEntry_setName(ctx context.Context, field graphql.CollectedField, obj *model.AdminLegalitiesDiffEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminLegalitiesDiffEntry_setName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SetName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminLegalitiesDiffEntry_setName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminLegalitiesDiffEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminLegalitiesDiffEntry_changedAt(ctx context.Context, field graphql.CollectedField, obj *model.AdminLegalitiesDiffEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminLegalitiesDiffEntry_changedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ChangedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminLegalitiesDiffEntry_changedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminLegalitiesDiffEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CardTag_ID(ctx context.Context, field graphql.CollectedField, obj *model.CardTag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CardTag_ID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CardTag_ID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CardTag",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CardTag_name(ctx context.Context, field graphql.CollectedField, obj *model.CardTag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CardTag_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CardTag_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CardTag",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CardTag_description(ctx context.Context, field graphql.CollectedField, obj *model.CardTag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CardTag_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CardTag_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CardTag",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CardTag_myRating(ctx context.Context, field graphql.CollectedField, obj *model.CardTag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CardTag_myRating(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MyRating, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.UserRating)
	fc.Result = res
	return ec.marshalOUserRating2magichelpergraphmodelUserRating(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CardTag_myRating(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CardTag",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "user":
				return ec.fieldContext_UserRating_user(ctx, field)
			case "value":
				return ec.fieldContext_UserRating_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserRating", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeckTag_ID(ctx context.Context, field graphql.CollectedField, obj *model.DeckTag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeckTag_ID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeckTag_ID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeckTag",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeckTag_name(ctx context.Context, field graphql.CollectedField, obj *model.DeckTag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeckTag_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeckTag_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeckTag",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeckTag_description(ctx context.Context, field graphql.CollectedField, obj *model.DeckTag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeckTag_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeckTag_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeckTag",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeckTag_myRating(ctx context.Context, field graphql.CollectedField, obj *model.DeckTag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeckTag_myRating(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MyRating, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.UserRating)
	fc.Result = res
	return ec.marshalOUserRating2magichelpergraphmodelUserRating(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeckTag_myRating(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeckTag",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "user":
				return ec.fieldContext_UserRating_user(ctx, field)
			case "value":
				return ec.fieldContext_UserRating_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserRating", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeckTag_colors(ctx context.Context, field graphql.CollectedField, obj *model.DeckTag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeckTag_colors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Colors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.MtgColor)
	fc.Result = res
	return ec.marshalNMTG_Color2magichelpergraphmodelMtgColor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeckTag_colors(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeckTag",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type MTG_Color does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FlowZone_ID(ctx context.Context, field graphql.CollectedField, obj *model.FlowZone) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FlowZone_ID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FlowZone_ID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FlowZone",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FlowZone_name(ctx context.Context, field graphql.CollectedField, obj *model.FlowZone) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FlowZone_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FlowZone_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FlowZone",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FlowZone_position(ctx context.Context, field graphql.CollectedField, obj *model.FlowZone) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FlowZone_position(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Position, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Position)
	fc.Result = res
	return ec.marshalNPosition2magichelpergraphmodelPosition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FlowZone_position(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FlowZone",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "x":
				return ec.fieldContext_Position_x(ctx, field)
			case "y":
				return ec.fieldContext_Position_y(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Position", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FlowZone_width(ctx context.Context, field graphql.CollectedField, obj *model.FlowZone) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FlowZone_width(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Width, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FlowZone_width(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FlowZone",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FlowZone_height(ctx context.Context, field graphql.CollectedField, obj *model.FlowZone) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FlowZone_height(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Height, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FlowZone_height(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FlowZone",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FlowZone_cardChildren(ctx context.Context, field graphql.CollectedField, obj *model.FlowZone) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FlowZone_cardChildren(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CardChildren, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FlowZone_cardChildren(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FlowZone",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FlowZone_zoneChildren(ctx context.Context, field graphql.CollectedField, obj *model.FlowZone) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FlowZone_zoneChildren(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ZoneChildren, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FlowZone_zoneChildren(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FlowZone",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Card_ID(ctx context.Context, field graphql.CollectedField, obj *model.MtgCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Card_ID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Card_ID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Card",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Card_layout(ctx context.Context, field graphql.CollectedField, obj *model.MtgCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Card_layout(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Layout, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.MtgLayout)
	fc.Result = res
	return ec.marshalNMTG_Layout2magichelpergraphmodelMtgLayout(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Card_layout(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Card",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type MTG_Layout does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Card_CMC(ctx context.Context, field graphql.CollectedField, obj *model.MtgCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Card_CMC(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cmc, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Card_CMC(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Card",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Card_colorIdentity(ctx context.Context, field graphql.CollectedField, obj *model.MtgCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Card_colorIdentity(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ColorIdentity, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.MtgColor)
	fc.Result = res
	return ec.marshalNMTG_Color2magichelpergraphmodelMtgColor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Card_colorIdentity(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Card",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type MTG_Color does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Card_colorIndicator(ctx context.Context, field graphql.CollectedField, obj *model.MtgCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Card_colorIndicator(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ColorIndicator, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Card_colorIndicator(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Card",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Card_colors(ctx context.Context, field graphql.CollectedField, obj *model.MtgCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Card_colors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Colors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.MtgColor)
	fc.Result = res
	return ec.marshalOMTG_Color2magichelpergraphmodelMtgColor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Card_colors(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Card",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type MTG_Color does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Card_EDHRecRank(ctx context.Context, field graphql.CollectedField, obj *model.MtgCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Card_EDHRecRank(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EDHRecRank, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Card_EDHRecRank(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Card",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Card_keywords(ctx context.Context, field graphql.CollectedField, obj *model.MtgCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Card_keywords(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Keywords, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Card_keywords(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Card",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Card_loyalty(ctx context.Context, field graphql.CollectedField, obj *model.MtgCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Card_loyalty(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Loyalty, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Card_loyalty(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Card",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Card_manaCost(ctx context.Context, field graphql.CollectedField, obj *model.MtgCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Card_manaCost(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ManaCost, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Card_manaCost(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Card",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Card_name(ctx context.Context, field graphql.CollectedField, obj *model.MtgCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Card_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Card_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Card",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Card_oracleText(ctx context.Context, field graphql.CollectedField, obj *model.MtgCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Card_oracleText(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OracleText, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Card_oracleText(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Card",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Card_power(ctx context.Context, field graphql.CollectedField, obj *model.MtgCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Card_power(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Power, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Card_power(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Card",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Card_producedMana(ctx context.Context, field graphql.CollectedField, obj *model.MtgCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Card_producedMana(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProducedMana, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.MtgColor)
	fc.Result = res
	return ec.marshalOMTG_Color2magichelpergraphmodelMtgColor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Card_producedMana(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Card",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type MTG_Color does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Card_toughness(ctx context.Context, field graphql.CollectedField, obj *model.MtgCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Card_toughness(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Toughness, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Card_toughness(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Card",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Card_typeLine(ctx context.Context, field graphql.CollectedField, obj *model.MtgCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Card_typeLine(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TypeLine, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Card_typeLine(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Card",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Card_versions(ctx context.Context, field graphql.CollectedField, obj *model.MtgCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Card_versions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Versions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.MtgCardVersion)
	fc.Result = res
	return ec.marshalNMTG_CardVersion2magichelpergraphmodelMtgCardVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Card_versions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Card",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ID":
				return ec.fieldContext_MTG_CardVersion_ID(ctx, field)
			case "isDefault":
				return ec.fieldContext_MTG_CardVersion_isDefault(ctx, field)
			case "isAlchemy":
				return ec.fieldContext_MTG_CardVersion_isAlchemy(ctx, field)
			case "artist":
				return ec.fieldContext_MTG_CardVersion_artist(ctx, field)
			case "lang":
				return ec.fieldContext_MTG_CardVersion_lang(ctx, field)
			case "flavorName":
				return ec.fieldContext_MTG_CardVersion_flavorName(ctx, field)
			case "flavorText":
				return ec.fieldContext_MTG_CardVersion_flavorText(ctx, field)
			case "cardFaces":
				return ec.fieldContext_MTG_CardVersion_cardFaces(ctx, field)
			case "legalities":
				return ec.fieldContext_MTG_CardVersion_legalities(ctx, field)
			case "games":
				return ec.fieldContext_MTG_CardVersion_games(ctx, field)
			case "imageUris":
				return ec.fieldContext_MTG_CardVersion_imageUris(ctx, field)
			case "printedName":
				return ec.fieldContext_MTG_CardVersion_printedName(ctx, field)
			case "rarity":
				return ec.fieldContext_MTG_CardVersion_rarity(ctx, field)
			case "releasedAt":
				return ec.fieldContext_MTG_CardVersion_releasedAt(ctx, field)
			case "reprint":
				return ec.fieldContext_MTG_CardVersion_reprint(ctx, field)
			case "setName":
				return ec.fieldContext_MTG_CardVersion_setName(ctx, field)
			case "setType":
				return ec.fieldContext_MTG_CardVersion_setType(ctx, field)
			case "set":
				return ec.fieldContext_MTG_CardVersion_set(ctx, field)
			case "setID":
				return ec.fieldContext_MTG_CardVersion_setID(ctx, field)
			case "variation":
				return ec.fieldContext_MTG_CardVersion_variation(ctx, field)
			case "variationOf":
				return ec.fieldContext_MTG_CardVersion_variationOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MTG_CardVersion", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Card_myRating(ctx context.Context, field graphql.CollectedField, obj *model.MtgCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Card_myRating(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MyRating, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.UserRating)
	fc.Result = res
	return ec.marshalOUserRating2magichelpergraphmodelUserRating(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Card_myRating(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Card",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "user":
				return ec.fieldContext_UserRating_user(ctx, field)
			case "value":
				return ec.fieldContext_UserRating_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserRating", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Card_cardTags(ctx context.Context, field graphql.CollectedField, obj *model.MtgCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Card_cardTags(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CardTags, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.CardTag)
	fc.Result = res
	return ec.marshalNCardTag2magichelpergraphmodelCardTag(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Card_cardTags(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Card",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ID":
				return ec.fieldContext_CardTag_ID(ctx, field)
			case "name":
				return ec.fieldContext_CardTag_name(ctx, field)
			case "description":
				return ec.fieldContext_CardTag_description(ctx, field)
			case "myRating":
				return ec.fieldContext_CardTag_myRating(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CardTag", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Card_deckTags(ctx context.Context, field graphql.CollectedField, obj *model.MtgCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Card_deckTags(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeckTags, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.DeckTag)
	fc.Result = res
	return ec.marshalNDeckTag2magichelpergraphmodelDeckTag(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Card_deckTags(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Card",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ID":
				return ec.fieldContext_DeckTag_ID(ctx, field)
			case "name":
				return ec.fieldContext_DeckTag_name(ctx, field)
			case "description":
				return ec.fieldContext_DeckTag_description(ctx, field)
			case "myRating":
				return ec.fieldContext_DeckTag_myRating(ctx, field)
			case "colors":
				return ec.fieldContext_DeckTag_colors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DeckTag", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardFace_artist(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardFace) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardFace_artist(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Artist, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardFace_artist(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardFace",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardFace_CMC(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardFace) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardFace_CMC(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cmc, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardFace_CMC(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardFace",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardFace_colorIndicator(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardFace) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardFace_colorIndicator(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ColorIndicator, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardFace_colorIndicator(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardFace",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardFace_colors(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardFace) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardFace_colors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Colors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.MtgColor)
	fc.Result = res
	return ec.marshalOMTG_Color2magichelpergraphmodelMtgColor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardFace_colors(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardFace",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type MTG_Color does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardFace_flavorText(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardFace) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardFace_flavorText(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FlavorText, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardFace_flavorText(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardFace",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardFace_imageUris(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardFace) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardFace_imageUris(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ImageUris, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.MtgImage)
	fc.Result = res
	return ec.marshalOMTG_Image2magichelpergraphmodelMtgImage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardFace_imageUris(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardFace",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "artCrop":
				return ec.fieldContext_MTG_Image_artCrop(ctx, field)
			case "borderCrop":
				return ec.fieldContext_MTG_Image_borderCrop(ctx, field)
			case "large":
				return ec.fieldContext_MTG_Image_large(ctx, field)
			case "normal":
				return ec.fieldContext_MTG_Image_normal(ctx, field)
			case "PNG":
				return ec.fieldContext_MTG_Image_PNG(ctx, field)
			case "small":
				return ec.fieldContext_MTG_Image_small(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MTG_Image", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardFace_layout(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardFace) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardFace_layout(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Layout, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.MtgLayout)
	fc.Result = res
	return ec.marshalOMTG_Layout2magichelpergraphmodelMtgLayout(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardFace_layout(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardFace",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type MTG_Layout does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardFace_loyalty(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardFace) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardFace_loyalty(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Loyalty, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardFace_loyalty(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardFace",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardFace_manaCost(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardFace) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardFace_manaCost(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ManaCost, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardFace_manaCost(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardFace",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardFace_name(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardFace) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardFace_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardFace_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardFace",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardFace_oracleText(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardFace) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardFace_oracleText(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OracleText, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardFace_oracleText(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardFace",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardFace_power(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardFace) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardFace_power(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Power, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardFace_power(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardFace",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardFace_toughness(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardFace) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardFace_toughness(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Toughness, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardFace_toughness(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardFace",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardFace_typeLine(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardFace) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardFace_typeLine(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TypeLine, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardFace_typeLine(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardFace",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardFace_Dashboard_imageUris(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardFaceDashboard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardFace_Dashboard_imageUris(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ImageUris, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.MtgImage)
	fc.Result = res
	return ec.marshalOMTG_Image2magichelpergraphmodelMtgImage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardFace_Dashboard_imageUris(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardFace_Dashboard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "artCrop":
				return ec.fieldContext_MTG_Image_artCrop(ctx, field)
			case "borderCrop":
				return ec.fieldContext_MTG_Image_borderCrop(ctx, field)
			case "large":
				return ec.fieldContext_MTG_Image_large(ctx, field)
			case "normal":
				return ec.fieldContext_MTG_Image_normal(ctx, field)
			case "PNG":
				return ec.fieldContext_MTG_Image_PNG(ctx, field)
			case "small":
				return ec.fieldContext_MTG_Image_small(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MTG_Image", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardPackage_ID(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardPackage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardPackage_ID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardPackage_ID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardPackage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardPackage_name(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardPackage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardPackage_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardPackage_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardPackage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardPackage_isPublic(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardPackage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardPackage_isPublic(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsPublic, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardPackage_isPublic(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardPackage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardPackage_ownerID(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardPackage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardPackage_ownerID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OwnerID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardPackage_ownerID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardPackage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardPackage_cards(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardPackage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardPackage_cards(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cards, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.MtgCardPackageCard)
	fc.Result = res
	return ec.marshalNMTG_CardPackageCard2magichelpergraphmodelMtgCardPackageCard(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardPackage_cards(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardPackage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "card":
				return ec.fieldContext_MTG_CardPackageCard_card(ctx, field)
			case "selectedVersionID":
				return ec.fieldContext_MTG_CardPackageCard_selectedVersionID(ctx, field)
			case "count":
				return ec.fieldContext_MTG_CardPackageCard_count(ctx, field)
			case "mainOrSide":
				return ec.fieldContext_MTG_CardPackageCard_mainOrSide(ctx, field)
			case "position":
				return ec.fieldContext_MTG_CardPackageCard_position(ctx, field)
			case "phantoms":
				return ec.fieldContext_MTG_CardPackageCard_phantoms(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MTG_CardPackageCard", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardPackage_zones(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardPackage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardPackage_zones(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Zones, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.FlowZone)
	fc.Result = res
	return ec.marshalNFlowZone2magichelpergraphmodelFlowZone(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardPackage_zones(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardPackage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ID":
				return ec.fieldContext_FlowZone_ID(ctx, field)
			case "name":
				return ec.fieldContext_FlowZone_name(ctx, field)
			case "position":
				return ec.fieldContext_FlowZone_position(ctx, field)
			case "width":
				return ec.fieldContext_FlowZone_width(ctx, field)
			case "height":
				return ec.fieldContext_FlowZone_height(ctx, field)
			case "cardChildren":
				return ec.fieldContext_FlowZone_cardChildren(ctx, field)
			case "zoneChildren":
				return ec.fieldContext_FlowZone_zoneChildren(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FlowZone", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardPackageCard_card(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardPackageCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardPackageCard_card(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Card, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.MtgCard)
	fc.Result = res
	return ec.marshalNMTG_Card2magichelpergraphmodelMtgCard(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardPackageCard_card(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardPackageCard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ID":
				return ec.fieldContext_MTG_Card_ID(ctx, field)
			case "layout":
				return ec.fieldContext_MTG_Card_layout(ctx, field)
			case "CMC":
				return ec.fieldContext_MTG_Card_CMC(ctx, field)
			case "colorIdentity":
				return ec.fieldContext_MTG_Card_colorIdentity(ctx, field)
			case "colorIndicator":
				return ec.fieldContext_MTG_Card_colorIndicator(ctx, field)
			case "colors":
				return ec.fieldContext_MTG_Card_colors(ctx, field)
			case "EDHRecRank":
				return ec.fieldContext_MTG_Card_EDHRecRank(ctx, field)
			case "keywords":
				return ec.fieldContext_MTG_Card_keywords(ctx, field)
			case "loyalty":
				return ec.fieldContext_MTG_Card_loyalty(ctx, field)
			case "manaCost":
				return ec.fieldContext_MTG_Card_manaCost(ctx, field)
			case "name":
				return ec.fieldContext_MTG_Card_name(ctx, field)
			case "oracleText":
				return ec.fieldContext_MTG_Card_oracleText(ctx, field)
			case "power":
				return ec.fieldContext_MTG_Card_power(ctx, field)
			case "producedMana":
				return ec.fieldContext_MTG_Card_producedMana(ctx, field)
			case "toughness":
				return ec.fieldContext_MTG_Card_toughness(ctx, field)
			case "typeLine":
				return ec.fieldContext_MTG_Card_typeLine(ctx, field)
			case "versions":
				return ec.fieldContext_MTG_Card_versions(ctx, field)
			case "myRating":
				return ec.fieldContext_MTG_Card_myRating(ctx, field)
			case "cardTags":
				return ec.fieldContext_MTG_Card_cardTags(ctx, field)
			case "deckTags":
				return ec.fieldContext_MTG_Card_deckTags(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MTG_Card", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardPackageCard_selectedVersionID(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardPackageCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardPackageCard_selectedVersionID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SelectedVersionID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardPackageCard_selectedVersionID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardPackageCard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardPackageCard_count(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardPackageCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardPackageCard_count(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardPackageCard_count(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardPackageCard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardPackageCard_mainOrSide(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardPackageCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardPackageCard_mainOrSide(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MainOrSide, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.MainOrSide)
	fc.Result = res
	return ec.marshalNMainOrSide2magichelpergraphmodelMainOrSide(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardPackageCard_mainOrSide(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardPackageCard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type MainOrSide does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardPackageCard_position(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardPackageCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardPackageCard_position(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Position, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Position)
	fc.Result = res
	return ec.marshalNPosition2magichelpergraphmodelPosition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardPackageCard_position(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardPackageCard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "x":
				return ec.fieldContext_Position_x(ctx, field)
			case "y":
				return ec.fieldContext_Position_y(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Position", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardPackageCard_phantoms(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardPackageCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardPackageCard_phantoms(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Phantoms, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Phantom)
	fc.Result = res
	return ec.marshalNPhantom2magichelpergraphmodelPhantom(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardPackageCard_phantoms(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardPackageCard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "position":
				return ec.fieldContext_Phantom_position(ctx, field)
			case "ID":
				return ec.fieldContext_Phantom_ID(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Phantom", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardVersion_ID(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardVersion_ID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardVersion_ID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardVersion_isDefault(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardVersion_isDefault(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDefault, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardVersion_isDefault(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardVersion_isAlchemy(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardVersion_isAlchemy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsAlchemy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardVersion_isAlchemy(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardVersion_artist(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardVersion_artist(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Artist, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardVersion_artist(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardVersion_lang(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardVersion_lang(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Lang, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardVersion_lang(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardVersion_flavorName(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardVersion_flavorName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FlavorName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardVersion_flavorName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardVersion_flavorText(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardVersion_flavorText(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FlavorText, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardVersion_flavorText(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardVersion_cardFaces(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardVersion_cardFaces(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CardFaces, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.MtgCardFace)
	fc.Result = res
	return ec.marshalOMTG_CardFace2magichelpergraphmodelMtgCardFace(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardVersion_cardFaces(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "artist":
				return ec.fieldContext_MTG_CardFace_artist(ctx, field)
			case "CMC":
				return ec.fieldContext_MTG_CardFace_CMC(ctx, field)
			case "colorIndicator":
				return ec.fieldContext_MTG_CardFace_colorIndicator(ctx, field)
			case "colors":
				return ec.fieldContext_MTG_CardFace_colors(ctx, field)
			case "flavorText":
				return ec.fieldContext_MTG_CardFace_flavorText(ctx, field)
			case "imageUris":
				return ec.fieldContext_MTG_CardFace_imageUris(ctx, field)
			case "layout":
				return ec.fieldContext_MTG_CardFace_layout(ctx, field)
			case "loyalty":
				return ec.fieldContext_MTG_CardFace_loyalty(ctx, field)
			case "manaCost":
				return ec.fieldContext_MTG_CardFace_manaCost(ctx, field)
			case "name":
				return ec.fieldContext_MTG_CardFace_name(ctx, field)
			case "oracleText":
				return ec.fieldContext_MTG_CardFace_oracleText(ctx, field)
			case "power":
				return ec.fieldContext_MTG_CardFace_power(ctx, field)
			case "toughness":
				return ec.fieldContext_MTG_CardFace_toughness(ctx, field)
			case "typeLine":
				return ec.fieldContext_MTG_CardFace_typeLine(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MTG_CardFace", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardVersion_legalities(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardVersion_legalities(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Legalities, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(map[string]any)
	fc.Result = res
	return ec.marshalNMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardVersion_legalities(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardVersion_games(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardVersion_games(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Games, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.MtgGame)
	fc.Result = res
	return ec.marshalNMTG_Game2magichelpergraphmodelMtgGame(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardVersion_games(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type MTG_Game does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardVersion_imageUris(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardVersion_imageUris(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ImageUris, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.MtgImage)
	fc.Result = res
	return ec.marshalOMTG_Image2magichelpergraphmodelMtgImage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardVersion_imageUris(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "artCrop":
				return ec.fieldContext_MTG_Image_artCrop(ctx, field)
			case "borderCrop":
				return ec.fieldContext_MTG_Image_borderCrop(ctx, field)
			case "large":
				return ec.fieldContext_MTG_Image_large(ctx, field)
			case "normal":
				return ec.fieldContext_MTG_Image_normal(ctx, field)
			case "PNG":
				return ec.fieldContext_MTG_Image_PNG(ctx, field)
			case "small":
				return ec.fieldContext_MTG_Image_small(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MTG_Image", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardVersion_printedName(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardVersion_printedName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PrintedName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardVersion_printedName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardVersion_rarity(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardVersion_rarity(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Rarity, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.MtgRarity)
	fc.Result = res
	return ec.marshalNMTG_Rarity2magichelpergraphmodelMtgRarity(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardVersion_rarity(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type MTG_Rarity does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardVersion_releasedAt(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardVersion_releasedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ReleasedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardVersion_releasedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardVersion_reprint(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardVersion_reprint(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Reprint, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardVersion_reprint(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardVersion_setName(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardVersion_setName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SetName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardVersion_setName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardVersion_setType(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardVersion_setType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SetType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardVersion_setType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardVersion_set(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardVersion_set(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Set, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardVersion_set(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardVersion_setID(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardVersion_setID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SetID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardVersion_setID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardVersion_variation(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardVersion_variation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Variation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardVersion_variation(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardVersion_variationOf(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardVersion_variationOf(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.VariationOf, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardVersion_variationOf(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardVersion_Dashboard_ID(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardVersionDashboard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardVersion_Dashboard_ID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardVersion_Dashboard_ID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardVersion_Dashboard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardVersion_Dashboard_isDefault(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardVersionDashboard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardVersion_Dashboard_isDefault(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDefault, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardVersion_Dashboard_isDefault(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardVersion_Dashboard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardVersion_Dashboard_isAlchemy(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardVersionDashboard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardVersion_Dashboard_isAlchemy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsAlchemy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardVersion_Dashboard_isAlchemy(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardVersion_Dashboard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardVersion_Dashboard_cardFaces(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardVersionDashboard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardVersion_Dashboard_cardFaces(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CardFaces, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.MtgCardFaceDashboard)
	fc.Result = res
	return ec.marshalNMTG_CardFace_Dashboard2magichelpergraphmodelMtgCardFaceDashboard(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardVersion_Dashboard_cardFaces(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardVersion_Dashboard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "imageUris":
				return ec.fieldContext_MTG_CardFace_Dashboard_imageUris(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MTG_CardFace_Dashboard", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardVersion_Dashboard_imageUris(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardVersionDashboard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardVersion_Dashboard_imageUris(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ImageUris, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.MtgImage)
	fc.Result = res
	return ec.marshalOMTG_Image2magichelpergraphmodelMtgImage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardVersion_Dashboard_imageUris(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardVersion_Dashboard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "artCrop":
				return ec.fieldContext_MTG_Image_artCrop(ctx, field)
			case "borderCrop":
				return ec.fieldContext_MTG_Image_borderCrop(ctx, field)
			case "large":
				return ec.fieldContext_MTG_Image_large(ctx, field)
			case "normal":
				return ec.fieldContext_MTG_Image_normal(ctx, field)
			case "PNG":
				return ec.fieldContext_MTG_Image_PNG(ctx, field)
			case "small":
				return ec.fieldContext_MTG_Image_small(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MTG_Image", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Card_Dashboard_ID(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardDashboard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Card_Dashboard_ID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Card_Dashboard_ID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Card_Dashboard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Card_Dashboard_versions(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardDashboard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Card_Dashboard_versions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Versions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.MtgCardVersionDashboard)
	fc.Result = res
	return ec.marshalNMTG_CardVersion_Dashboard2magichelpergraphmodelMtgCardVersionDashboard(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Card_Dashboard_versions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Card_Dashboard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ID":
				return ec.fieldContext_MTG_CardVersion_Dashboard_ID(ctx, field)
			case "isDefault":
				return ec.fieldContext_MTG_CardVersion_Dashboard_isDefault(ctx, field)
			case "isAlchemy":
				return ec.fieldContext_MTG_CardVersion_Dashboard_isAlchemy(ctx, field)
			case "cardFaces":
				return ec.fieldContext_MTG_CardVersion_Dashboard_cardFaces(ctx, field)
			case "imageUris":
				return ec.fieldContext_MTG_CardVersion_Dashboard_imageUris(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MTG_CardVersion_Dashboard", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Deck_ID(ctx context.Context, field graphql.CollectedField, obj *model.MtgDeck) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Deck_ID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Deck_ID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Deck",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Deck_name(ctx context.Context, field graphql.CollectedField, obj *model.MtgDeck) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Deck_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Deck_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Deck",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Deck_cardFrontImage(ctx context.Context, field graphql.CollectedField, obj *model.MtgDeck) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Deck_cardFrontImage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CardFrontImage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.MtgDeckCardFrontImage)
	fc.Result = res
	return ec.marshalOMTG_Deck_CardFrontImage2magichelpergraphmodelMtgDeckCardFrontImage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Deck_cardFrontImage(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Deck",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cardID":
				return ec.fieldContext_MTG_Deck_CardFrontImage_cardID(ctx, field)
			case "versionID":
				return ec.fieldContext_MTG_Deck_CardFrontImage_versionID(ctx, field)
			case "image":
				return ec.fieldContext_MTG_Deck_CardFrontImage_image(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MTG_Deck_CardFrontImage", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Deck_cards(ctx context.Context, field graphql.CollectedField, obj *model.MtgDeck) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Deck_cards(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cards, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.MtgDeckCard)
	fc.Result = res
	return ec.marshalNMTG_DeckCard2magichelpergraphmodelMtgDeckCard(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Deck_cards(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Deck",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "card":
				return ec.fieldContext_MTG_DeckCard_card(ctx, field)
			case "selectedVersionID":
				return ec.fieldContext_MTG_DeckCard_selectedVersionID(ctx, field)
			case "count":
				return ec.fieldContext_MTG_DeckCard_count(ctx, field)
			case "position":
				return ec.fieldContext_MTG_DeckCard_position(ctx, field)
			case "mainOrSide":
				return ec.fieldContext_MTG_DeckCard_mainOrSide(ctx, field)
			case "deckCardType":
				return ec.fieldContext_MTG_DeckCard_deckCardType(ctx, field)
			case "phantoms":
				return ec.fieldContext_MTG_DeckCard_phantoms(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MTG_DeckCard", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Deck_zones(ctx context.Context, field graphql.CollectedField, obj *model.MtgDeck) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Deck_zones(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Zones, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.FlowZone)
	fc.Result = res
	return ec.marshalNFlowZone2magichelpergraphmodelFlowZone(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Deck_zones(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Deck",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ID":
				return ec.fieldContext_FlowZone_ID(ctx, field)
			case "name":
				return ec.fieldContext_FlowZone_name(ctx, field)
			case "position":
				return ec.fieldContext_FlowZone_position(ctx, field)
			case "width":
				return ec.fieldContext_FlowZone_width(ctx, field)
			case "height":
				return ec.fieldContext_FlowZone_height(ctx, field)
			case "cardChildren":
				return ec.fieldContext_FlowZone_cardChildren(ctx, field)
			case "zoneChildren":
				return ec.fieldContext_FlowZone_zoneChildren(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FlowZone", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Deck_ignoredCards(ctx context.Context, field graphql.CollectedField, obj *model.MtgDeck) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Deck_ignoredCards(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IgnoredCards, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Deck_ignoredCards(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Deck",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_DeckCard_card(ctx context.Context, field graphql.CollectedField, obj *model.MtgDeckCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_DeckCard_card(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Card, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.MtgCard)
	fc.Result = res
	return ec.marshalNMTG_Card2magichelpergraphmodelMtgCard(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_DeckCard_card(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_DeckCard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ID":
				return ec.fieldContext_MTG_Card_ID(ctx, field)
			case "layout":
				return ec.fieldContext_MTG_Card_layout(ctx, field)
			case "CMC":
				return ec.fieldContext_MTG_Card_CMC(ctx, field)
			case "colorIdentity":
				return ec.fieldContext_MTG_Card_colorIdentity(ctx, field)
			case "colorIndicator":
				return ec.fieldContext_MTG_Card_colorIndicator(ctx, field)
			case "colors":
				return ec.fieldContext_MTG_Card_colors(ctx, field)
			case "EDHRecRank":
				return ec.fieldContext_MTG_Card_EDHRecRank(ctx, field)
			case "keywords":
				return ec.fieldContext_MTG_Card_keywords(ctx, field)
			case "loyalty":
				return ec.fieldContext_MTG_Card_loyalty(ctx, field)
			case "manaCost":
				return ec.fieldContext_MTG_Card_manaCost(ctx, field)
			case "name":
				return ec.fieldContext_MTG_Card_name(ctx, field)
			case "oracleText":
				return ec.fieldContext_MTG_Card_oracleText(ctx, field)
			case "power":
				return ec.fieldContext_MTG_Card_power(ctx, field)
			case "producedMana":
				return ec.fieldContext_MTG_Card_producedMana(ctx, field)
			case "toughness":
				return ec.fieldContext_MTG_Card_toughness(ctx, field)
			case "typeLine":
				return ec.fieldContext_MTG_Card_typeLine(ctx, field)
			case "versions":
				return ec.fieldContext_MTG_Card_versions(ctx, field)
			case "myRating":
				return ec.fieldContext_MTG_Card_myRating(ctx, field)
			case "cardTags":
				return ec.fieldContext_MTG_Card_cardTags(ctx, field)
			case "deckTags":
				return ec.fieldContext_MTG_Card_deckTags(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MTG_Card", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_DeckCard_selectedVersionID(ctx context.Context, field graphql.CollectedField, obj *model.MtgDeckCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_DeckCard_selectedVersionID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SelectedVersionID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_DeckCard_selectedVersionID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_DeckCard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_DeckCard_count(ctx context.Context, field graphql.CollectedField, obj *model.MtgDeckCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_DeckCard_count(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_DeckCard_count(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_DeckCard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_DeckCard_position(ctx context.Context, field graphql.CollectedField, obj *model.MtgDeckCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_DeckCard_position(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Position, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Position)
	fc.Result = res
	return ec.marshalNPosition2magichelpergraphmodelPosition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_DeckCard_position(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_DeckCard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "x":
				return ec.fieldContext_Position_x(ctx, field)
			case "y":
				return ec.fieldContext_Position_y(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Position", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_DeckCard_mainOrSide(ctx context.Context, field graphql.CollectedField, obj *model.MtgDeckCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_DeckCard_mainOrSide(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MainOrSide, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.MainOrSide)
	fc.Result = res
	return ec.marshalNMainOrSide2magichelpergraphmodelMainOrSide(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_DeckCard_mainOrSide(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_DeckCard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type MainOrSide does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_DeckCard_deckCardType(ctx context.Context, field graphql.CollectedField, obj *model.MtgDeckCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_DeckCard_deckCardType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeckCardType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.MtgDeckCardType)
	fc.Result = res
	return ec.marshalNMTG_DeckCardType2magichelpergraphmodelMtgDeckCardType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_DeckCard_deckCardType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_DeckCard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type MTG_DeckCardType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_DeckCard_phantoms(ctx context.Context, field graphql.CollectedField, obj *model.MtgDeckCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_DeckCard_phantoms(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Phantoms, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Phantom)
	fc.Result = res
	return ec.marshalNPhantom2magichelpergraphmodelPhantom(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_DeckCard_phantoms(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_DeckCard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "position":
				return ec.fieldContext_Phantom_position(ctx, field)
			case "ID":
				return ec.fieldContext_Phantom_ID(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Phantom", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_DeckCard_Dashboard_card(ctx context.Context, field graphql.CollectedField, obj *model.MtgDeckCardDashboard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_DeckCard_Dashboard_card(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Card, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.MtgCardDashboard)
	fc.Result = res
	return ec.marshalNMTG_Card_Dashboard2magichelpergraphmodelMtgCardDashboard(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_DeckCard_Dashboard_card(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_DeckCard_Dashboard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ID":
				return ec.fieldContext_MTG_Card_Dashboard_ID(ctx, field)
			case "versions":
				return ec.fieldContext_MTG_Card_Dashboard_versions(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MTG_Card_Dashboard", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_DeckCard_Dashboard_selectedVersionID(ctx context.Context, field graphql.CollectedField, obj *model.MtgDeckCardDashboard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_DeckCard_Dashboard_selectedVersionID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SelectedVersionID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_DeckCard_Dashboard_selectedVersionID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_DeckCard_Dashboard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_DeckDashboard_ID(ctx context.Context, field graphql.CollectedField, obj *model.MtgDeckDashboard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_DeckDashboard_ID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_DeckDashboard_ID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_DeckDashboard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_DeckDashboard_name(ctx context.Context, field graphql.CollectedField, obj *model.MtgDeckDashboard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_DeckDashboard_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_DeckDashboard_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_DeckDashboard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_DeckDashboard_cardFrontImage(ctx context.Context, field graphql.CollectedField, obj *model.MtgDeckDashboard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_DeckDashboard_cardFrontImage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CardFrontImage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.MtgDeckCardFrontImage)
	fc.Result = res
	return ec.marshalOMTG_Deck_CardFrontImage2magichelpergraphmodelMtgDeckCardFrontImage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_DeckDashboard_cardFrontImage(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_DeckDashboard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cardID":
				return ec.fieldContext_MTG_Deck_CardFrontImage_cardID(ctx, field)
			case "versionID":
				return ec.fieldContext_MTG_Deck_CardFrontImage_versionID(ctx, field)
			case "image":
				return ec.fieldContext_MTG_Deck_CardFrontImage_image(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MTG_Deck_CardFrontImage", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_DeckDashboard_cards(ctx context.Context, field graphql.CollectedField, obj *model.MtgDeckDashboard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_DeckDashboard_cards(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cards, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.MtgDeckCardDashboard)
	fc.Result = res
	return ec.marshalNMTG_DeckCard_Dashboard2magichelpergraphmodelMtgDeckCardDashboard(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_DeckDashboard_cards(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_DeckDashboard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "card":
				return ec.fieldContext_MTG_DeckCard_Dashboard_card(ctx, field)
			case "selectedVersionID":
				return ec.fieldContext_MTG_DeckCard_Dashboard_selectedVersionID(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MTG_DeckCard_Dashboard", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Deck_CardFrontImage_cardID(ctx context.Context, field graphql.CollectedField, obj *model.MtgDeckCardFrontImage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Deck_CardFrontImage_cardID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CardID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Deck_CardFrontImage_cardID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Deck_CardFrontImage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Deck_CardFrontImage_versionID(ctx context.Context, field graphql.CollectedField, obj *model.MtgDeckCardFrontImage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Deck_CardFrontImage_versionID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.VersionID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Deck_CardFrontImage_versionID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Deck_CardFrontImage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Deck_CardFrontImage_image(ctx context.Context, field graphql.CollectedField, obj *model.MtgDeckCardFrontImage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Deck_CardFrontImage_image(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Image, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Deck_CardFrontImage_image(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Deck_CardFrontImage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Filter_CardTypes_cardType(ctx context.Context, field graphql.CollectedField, obj *model.MtgFilterCardTypes) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Filter_CardTypes_cardType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CardType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Filter_CardTypes_cardType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Filter_CardTypes",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Filter_CardTypes_subtypes(ctx context.Context, field graphql.CollectedField, obj *model.MtgFilterCardTypes) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Filter_CardTypes_subtypes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Subtypes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Filter_CardTypes_subtypes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Filter_CardTypes",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Filter_Entries_types(ctx context.Context, field graphql.CollectedField, obj *model.MtgFilterEntries) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Filter_Entries_types(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.MtgFilterCardTypes)
	fc.Result = res
	return ec.marshalNMTG_Filter_CardTypes2magichelpergraphmodelMtgFilterCardTypes(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Filter_Entries_types(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Filter_Entries",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cardType":
				return ec.fieldContext_MTG_Filter_CardTypes_cardType(ctx, field)
			case "subtypes":
				return ec.fieldContext_MTG_Filter_CardTypes_subtypes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MTG_Filter_CardTypes", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Filter_Entries_expansions(ctx context.Context, field graphql.CollectedField, obj *model.MtgFilterEntries) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Filter_Entries_expansions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Expansions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.MtgFilterExpansion)
	fc.Result = res
	return ec.marshalNMTG_Filter_Expansion2magichelpergraphmodelMtgFilterExpansion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Filter_Entries_expansions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Filter_Entries",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "set":
				return ec.fieldContext_MTG_Filter_Expansion_set(ctx, field)
			case "setName":
				return ec.fieldContext_MTG_Filter_Expansion_setName(ctx, field)
			case "releasedAt":
				return ec.fieldContext_MTG_Filter_Expansion_releasedAt(ctx, field)
			case "imageURL":
				return ec.fieldContext_MTG_Filter_Expansion_imageURL(ctx, field)
			case "setType":
				return ec.fieldContext_MTG_Filter_Expansion_setType(ctx, field)
			case "games":
				return ec.fieldContext_MTG_Filter_Expansion_games(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MTG_Filter_Expansion", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Filter_Entries_legality(ctx context.Context, field graphql.CollectedField, obj *model.MtgFilterEntries) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Filter_Entries_legality(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Legality, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.MtgFilterLegality)
	fc.Result = res
	return ec.marshalNMTG_Filter_Legality2magichelpergraphmodelMtgFilterLegality(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Filter_Entries_legality(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Filter_Entries",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "formats":
				return ec.fieldContext_MTG_Filter_Legality_formats(ctx, field)
			case "legalityValues":
				return ec.fieldContext_MTG_Filter_Legality_legalityValues(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MTG_Filter_Legality", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Filter_Entries_layouts(ctx context.Context, field graphql.CollectedField, obj *model.MtgFilterEntries) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Filter_Entries_layouts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Layouts, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.MtgLayout)
	fc.Result = res
	return ec.marshalNMTG_Layout2magichelpergraphmodelMtgLayout(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Filter_Entries_layouts(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Filter_Entries",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type MTG_Layout does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Filter_Expansion_set(ctx context.Context, field graphql.CollectedField, obj *model.MtgFilterExpansion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Filter_Expansion_set(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Set, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Filter_Expansion_set(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Filter_Expansion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Filter_Expansion_setName(ctx context.Context, field graphql.CollectedField, obj *model.MtgFilterExpansion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Filter_Expansion_setName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SetName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Filter_Expansion_setName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Filter_Expansion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Filter_Expansion_releasedAt(ctx context.Context, field graphql.CollectedField, obj *model.MtgFilterExpansion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Filter_Expansion_releasedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ReleasedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Filter_Expansion_releasedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Filter_Expansion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Filter_Expansion_imageURL(ctx context.Context, field graphql.CollectedField, obj *model.MtgFilterExpansion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Filter_Expansion_imageURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ImageURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Filter_Expansion_imageURL(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Filter_Expansion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Filter_Expansion_setType(ctx context.Context, field graphql.CollectedField, obj *model.MtgFilterExpansion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Filter_Expansion_setType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SetType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Filter_Expansion_setType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Filter_Expansion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Filter_Expansion_games(ctx context.Context, field graphql.CollectedField, obj *model.MtgFilterExpansion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Filter_Expansion_games(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Games, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.MtgGame)
	fc.Result = res
	return ec.marshalNMTG_Game2magichelpergraphmodelMtgGame(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Filter_Expansion_games(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Filter_Expansion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type MTG_Game does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Filter_Legality_formats(ctx context.Context, field graphql.CollectedField, obj *model.MtgFilterLegality) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Filter_Legality_formats(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Formats, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Filter_Legality_formats(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Filter_Legality",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Filter_Legality_legalityValues(ctx context.Context, field graphql.CollectedField, obj *model.MtgFilterLegality) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Filter_Legality_legalityValues(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LegalityValues, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Filter_Legality_legalityValues(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Filter_Legality",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Filter_Search_pagedCards(ctx context.Context, field graphql.CollectedField, obj *model.MtgFilterSearch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Filter_Search_pagedCards(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PagedCards, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.MtgCard)
	fc.Result = res
	return ec.marshalNMTG_Card2magichelpergraphmodelMtgCard(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Filter_Search_pagedCards(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Filter_Search",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ID":
				return ec.fieldContext_MTG_Card_ID(ctx, field)
			case "layout":
				return ec.fieldContext_MTG_Card_layout(ctx, field)
			case "CMC":
				return ec.fieldContext_MTG_Card_CMC(ctx, field)
			case "colorIdentity":
				return ec.fieldContext_MTG_Card_colorIdentity(ctx, field)
			case "colorIndicator":
				return ec.fieldContext_MTG_Card_colorIndicator(ctx, field)
			case "colors":
				return ec.fieldContext_MTG_Card_colors(ctx, field)
			case "EDHRecRank":
				return ec.fieldContext_MTG_Card_EDHRecRank(ctx, field)
			case "keywords":
				return ec.fieldContext_MTG_Card_keywords(ctx, field)
			case "loyalty":
				return ec.fieldContext_MTG_Card_loyalty(ctx, field)
			case "manaCost":
				return ec.fieldContext_MTG_Card_manaCost(ctx, field)
			case "name":
				return ec.fieldContext_MTG_Card_name(ctx, field)
			case "oracleText":
				return ec.fieldContext_MTG_Card_oracleText(ctx, field)
			case "power":
				return ec.fieldContext_MTG_Card_power(ctx, field)
			case "producedMana":
				return ec.fieldContext_MTG_Card_producedMana(ctx, field)
			case "toughness":
				return ec.fieldContext_MTG_Card_toughness(ctx, field)
			case "typeLine":
				return ec.fieldContext_MTG_Card_typeLine(ctx, field)
			case "versions":
				return ec.fieldContext_MTG_Card_versions(ctx, field)
			case "myRating":
				return ec.fieldContext_MTG_Card_myRating(ctx, field)
			case "cardTags":
				return ec.fieldContext_MTG_Card_cardTags(ctx, field)
			case "deckTags":
				return ec.fieldContext_MTG_Card_deckTags(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MTG_Card", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Filter_Search_totalCount(ctx context.Context, field graphql.CollectedField, obj *model.MtgFilterSearch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Filter_Search_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Filter_Search_totalCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Filter_Search",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Image_artCrop(ctx context.Context, field graphql.CollectedField, obj *model.MtgImage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Image_artCrop(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ArtCrop, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Image_artCrop(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Image",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Image_borderCrop(ctx context.Context, field graphql.CollectedField, obj *model.MtgImage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Image_borderCrop(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BorderCrop, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Image_borderCrop(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Image",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Image_large(ctx context.Context, field graphql.CollectedField, obj *model.MtgImage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Image_large(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Large, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Image_large(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Image",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Image_normal(ctx context.Context, field graphql.CollectedField, obj *model.MtgImage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Image_normal(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Normal, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Image_normal(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Image",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Image_PNG(ctx context.Context, field graphql.CollectedField, obj *model.MtgImage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Image_PNG(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Png, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Image_PNG(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Image",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Image_small(ctx context.Context, field graphql.CollectedField, obj *model.MtgImage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Image_small(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Small, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Image_small(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Image",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createMTGDeck(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createMTGDeck(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateMTGDeck(rctx, fc.Args["input"].(model.MtgCreateDeckInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Response)
	fc.Result = res
	return ec.marshalNResponse2magichelpergraphmodelResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createMTGDeck(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "status":
				return ec.fieldContext_Response_status(ctx, field)
			case "message":
				return ec.fieldContext_Response_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Response", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createMTGDeck_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteMTGDeck(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteMTGDeck(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteMTGDeck(rctx, fc.Args["input"].(model.MtgDeleteDeckInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Response)
	fc.Result = res
	return ec.marshalNResponse2magichelpergraphmodelResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteMTGDeck(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "status":
				return ec.fieldContext_Response_status(ctx, field)
			case "message":
				return ec.fieldContext_Response_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Response", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteMTGDeck_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateMTGDeck(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateMTGDeck(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateMTGDeck(rctx, fc.Args["input"].(model.MtgUpdateDeckInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Response)
	fc.Result = res
	return ec.marshalNResponse2magichelpergraphmodelResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateMTGDeck(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "status":
				return ec.fieldContext_Response_status(ctx, field)
			case "message":
				return ec.fieldContext_Response_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Response", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateMTGDeck_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_saveMTGDeckAsCopy(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_saveMTGDeckAsCopy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().SaveMTGDeckAsCopy(rctx, fc.Args["input"].(model.MtgUpdateDeckInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Response)
	fc.Result = res
	return ec.marshalNResponse2magichelpergraphmodelResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_saveMTGDeckAsCopy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "status":
				return ec.fieldContext_Response_status(ctx, field)
			case "message":
				return ec.fieldContext_Response_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Response", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_saveMTGDeckAsCopy_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createMTGCardPackage(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createMTGCardPackage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateMTGCardPackage(rctx, fc.Args["input"].(model.MtgCreateCardPackageInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Response)
	fc.Result = res
	return ec.marshalNResponse2magichelpergraphmodelResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createMTGCardPackage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "status":
				return ec.fieldContext_Response_status(ctx, field)
			case "message":
				return ec.fieldContext_Response_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Response", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createMTGCardPackage_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteMTGCardPackage(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteMTGCardPackage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteMTGCardPackage(rctx, fc.Args["input"].(model.MtgDeleteCardPackageInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Response)
	fc.Result = res
	return ec.marshalNResponse2magichelpergraphmodelResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteMTGCardPackage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "status":
				return ec.fieldContext_Response_status(ctx, field)
			case "message":
				return ec.fieldContext_Response_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Response", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteMTGCardPackage_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_editMTGCardPackageName(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_editMTGCardPackageName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().EditMTGCardPackageName(rctx, fc.Args["input"].(model.MtgEditCardPackageNameInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Response)
	fc.Result = res
	return ec.marshalNResponse2magichelpergraphmodelResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_editMTGCardPackageName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "status":
				return ec.fieldContext_Response_status(ctx, field)
			case "message":
				return ec.fieldContext_Response_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Response", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_editMTGCardPackageName_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_editMTGCardPackageVisibility(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_editMTGCardPackageVisibility(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().EditMTGCardPackageVisibility(rctx, fc.Args["input"].(model.MtgEditCardPackageVisibilityInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Response)
	fc.Result = res
	return ec.marshalNResponse2magichelpergraphmodelResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_editMTGCardPackageVisibility(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "status":
				return ec.fieldContext_Response_status(ctx, field)
			case "message":
				return ec.fieldContext_Response_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Response", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_editMTGCardPackageVisibility_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_addMTGCardToCardPackage(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_addMTGCardToCardPackage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().AddMTGCardToCardPackage(rctx, fc.Args["input"].(model.MtgAddCardToCardPackageInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Response)
	fc.Result = res
	return ec.marshalNResponse2magichelpergraphmodelResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_addMTGCardToCardPackage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "status":
				return ec.fieldContext_Response_status(ctx, field)
			case "message":
				return ec.fieldContext_Response_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Response", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_addMTGCardToCardPackage_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_removeMTGCardFromCardPackage(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_removeMTGCardFromCardPackage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().RemoveMTGCardFromCardPackage(rctx, fc.Args["input"].(model.MtgRemoveCardFromCardPackageInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Response)
	fc.Result = res
	return ec.marshalNResponse2magichelpergraphmodelResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_removeMTGCardFromCardPackage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "status":
				return ec.fieldContext_Response_status(ctx, field)
			case "message":
				return ec.fieldContext_Response_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Response", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_removeMTGCardFromCardPackage_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createTag(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createTag(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateTag(rctx, fc.Args["input"].(model.CreateTagInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Response)
	fc.Result = res
	return ec.marshalNResponse2magichelpergraphmodelResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createTag(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "status":
				return ec.fieldContext_Response_status(ctx, field)
			case "message":
				return ec.fieldContext_Response_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Response", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createTag_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateTag(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateTag(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateTag(rctx, fc.Args["input"].(model.UpdateTagInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Response)
	fc.Result = res
	return ec.marshalNResponse2magichelpergraphmodelResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateTag(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "status":
				return ec.fieldContext_Response_status(ctx, field)
			case "message":
				return ec.fieldContext_Response_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Response", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateTag_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteTag(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteTag(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteTag(rctx, fc.Args["tagID"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Response)
	fc.Result = res
	return ec.marshalNResponse2magichelpergraphmodelResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteTag(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "status":
				return ec.fieldContext_Response_status(ctx, field)
			case "message":
				return ec.fieldContext_Response_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Response", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteTag_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_assignTag(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_assignTag(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().AssignTag(rctx, fc.Args["input"].(model.AssignTagInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Response)
	fc.Result = res
	return ec.marshalNResponse2magichelpergraphmodelResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_assignTag(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "status":
				return ec.fieldContext_Response_status(ctx, field)
			case "message":
				return ec.fieldContext_Response_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Response", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_assignTag_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_unassignTag(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_unassignTag(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UnassignTag(rctx, fc.Args["input"].(model.UnassignTagInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Response)
	fc.Result = res
	return ec.marshalNResponse2magichelpergraphmodelResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_unassignTag(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "status":
				return ec.fieldContext_Response_status(ctx, field)
			case "message":
				return ec.fieldContext_Response_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Response", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_unassignTag_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_rate(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_rate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().Rate(rctx, fc.Args["input"].(model.RateInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Response)
	fc.Result = res
	return ec.marshalNResponse2magichelpergraphmodelResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_rate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "status":
				return ec.fieldContext_Response_status(ctx, field)
			case "message":
				return ec.fieldContext_Response_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Response", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_rate_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_addIgnoredCard(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_addIgnoredCard(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().AddIgnoredCard(rctx, fc.Args["input"].(model.AddIgnoredCardInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Response)
	fc.Result = res
	return ec.marshalNResponse2magichelpergraphmodelResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_addIgnoredCard(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "status":
				return ec.fieldContext_Response_status(ctx, field)
			case "message":
				return ec.fieldContext_Response_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Response", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_addIgnoredCard_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_removeIgnoredCard(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_removeIgnoredCard(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().RemoveIgnoredCard(rctx, fc.Args["input"].(model.RemoveIgnoredCardInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Response)
	fc.Result = res
	return ec.marshalNResponse2magichelpergraphmodelResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_removeIgnoredCard(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "status":
				return ec.fieldContext_Response_status(ctx, field)
			case "message":
				return ec.fieldContext_Response_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Response", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_removeIgnoredCard_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_adminRetryImport(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_adminRetryImport(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().AdminRetryImport(rctx, fc.Args["input"].(model.AdminImportActionInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Response)
	fc.Result = res
	return ec.marshalNResponse2magichelpergraphmodelResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_adminRetryImport(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "status":
				return ec.fieldContext_Response_status(ctx, field)
			case "message":
				return ec.fieldContext_Response_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Response", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_adminRetryImport_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_adminBackfillImport(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_adminBackfillImport(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().AdminBackfillImport(rctx, fc.Args["input"].(model.AdminImportActionInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Response)
	fc.Result = res
	return ec.marshalNResponse2magichelpergraphmodelResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_adminBackfillImport(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "status":
				return ec.fieldContext_Response_status(ctx, field)
			case "message":
				return ec.fieldContext_Response_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Response", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_adminBackfillImport_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Phantom_position(ctx context.Context, field graphql.CollectedField, obj *model.Phantom) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Phantom_position(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Position, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Position)
	fc.Result = res
	return ec.marshalNPosition2magichelpergraphmodelPosition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Phantom_position(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Phantom",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "x":
				return ec.fieldContext_Position_x(ctx, field)
			case "y":
				return ec.fieldContext_Position_y(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Position", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Phantom_ID(ctx context.Context, field graphql.CollectedField, obj *model.Phantom) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Phantom_ID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Phantom_ID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Phantom",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Position_x(ctx context.Context, field graphql.CollectedField, obj *model.Position) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Position_x(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.X, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Position_x(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Position",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Position_y(ctx context.Context, field graphql.CollectedField, obj *model.Position) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Position_y(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Y, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Position_y(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Position",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_getMTGCards(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getMTGCards(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GetMTGCards(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.MtgCard)
	fc.Result = res
	return ec.marshalNMTG_Card2magichelpergraphmodelMtgCard(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getMTGCards(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ID":
				return ec.fieldContext_MTG_Card_ID(ctx, field)
			case "layout":
				return ec.fieldContext_MTG_Card_layout(ctx, field)
			case "CMC":
				return ec.fieldContext_MTG_Card_CMC(ctx, field)
			case "colorIdentity":
				return ec.fieldContext_MTG_Card_colorIdentity(ctx, field)
			case "colorIndicator":
				return ec.fieldContext_MTG_Card_colorIndicator(ctx, field)
			case "colors":
				return ec.fieldContext_MTG_Card_colors(ctx, field)
			case "EDHRecRank":
				return ec.fieldContext_MTG_Card_EDHRecRank(ctx, field)
			case "keywords":
				return ec.fieldContext_MTG_Card_keywords(ctx, field)
			case "loyalty":
				return ec.fieldContext_MTG_Card_loyalty(ctx, field)
			case "manaCost":
				return ec.fieldContext_MTG_Card_manaCost(ctx, field)
			case "name":
				return ec.fieldContext_MTG_Card_name(ctx, field)
			case "oracleText":
				return ec.fieldContext_MTG_Card_oracleText(ctx, field)
			case "power":
				return ec.fieldContext_MTG_Card_power(ctx, field)
			case "producedMana":
				return ec.fieldContext_MTG_Card_producedMana(ctx, field)
			case "toughness":
				return ec.fieldContext_MTG_Card_toughness(ctx, field)
			case "typeLine":
				return ec.fieldContext_MTG_Card_typeLine(ctx, field)
			case "versions":
				return ec.fieldContext_MTG_Card_versions(ctx, field)
			case "myRating":
				return ec.fieldContext_MTG_Card_myRating(ctx, field)
			case "cardTags":
				return ec.fieldContext_MTG_Card_cardTags(ctx, field)
			case "deckTags":
				return ec.fieldContext_MTG_Card_deckTags(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MTG_Card", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_getMTGCardsFiltered(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getMTGCardsFiltered(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GetMTGCardsFiltered(rctx, fc.Args["filter"].(model.MtgFilterSearchInput), fc.Args["pagination"].(model.MtgFilterPaginationInput), fc.Args["sort"].([]*model.MtgFilterSortInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.MtgFilterSearch)
	fc.Result = res
	return ec.marshalNMTG_Filter_Search2magichelpergraphmodelMtgFilterSearch(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getMTGCardsFiltered(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pagedCards":
				return ec.fieldContext_MTG_Filter_Search_pagedCards(ctx, field)
			case "totalCount":
				return ec.fieldContext_MTG_Filter_Search_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MTG_Filter_Search", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getMTGCardsFiltered_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_getMTGFilters(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getMTGFilters(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GetMTGFilters(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.MtgFilterEntries)
	fc.Result = res
	return ec.marshalNMTG_Filter_Entries2magichelpergraphmodelMtgFilterEntries(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getMTGFilters(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "types":
				return ec.fieldContext_MTG_Filter_Entries_types(ctx, field)
			case "expansions":
				return ec.fieldContext_MTG_Filter_Entries_expansions(ctx, field)
			case "legality":
				return ec.fieldContext_MTG_Filter_Entries_legality(ctx, field)
			case "layouts":
				return ec.fieldContext_MTG_Filter_Entries_layouts(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MTG_Filter_Entries", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_getMTGDecks(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getMTGDecks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GetMTGDecks(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.MtgDeckDashboard)
	fc.Result = res
	return ec.marshalNMTG_DeckDashboard2magichelpergraphmodelMtgDeckDashboard(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getMTGDecks(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ID":
				return ec.fieldContext_MTG_DeckDashboard_ID(ctx, field)
			case "name":
				return ec.fieldContext_MTG_DeckDashboard_name(ctx, field)
			case "cardFrontImage":
				return ec.fieldContext_MTG_DeckDashboard_cardFrontImage(ctx, field)
			case "cards":
				return ec.fieldContext_MTG_DeckDashboard_cards(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MTG_DeckDashboard", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_getMTGDeck(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getMTGDeck(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GetMTGDeck(rctx, fc.Args["deckID"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.MtgDeck)
	fc.Result = res
	return ec.marshalNMTG_Deck2magichelpergraphmodelMtgDeck(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getMTGDeck(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ID":
				return ec.fieldContext_MTG_Deck_ID(ctx, field)
			case "name":
				return ec.fieldContext_MTG_Deck_name(ctx, field)
			case "cardFrontImage":
				return ec.fieldContext_MTG_Deck_cardFrontImage(ctx, field)
			case "cards":
				return ec.fieldContext_MTG_Deck_cards(ctx, field)
			case "zones":
				return ec.fieldContext_MTG_Deck_zones(ctx, field)
			case "ignoredCards":
				return ec.fieldContext_MTG_Deck_ignoredCards(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MTG_Deck", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getMTGDeck_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_getMTGCardPackages(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getMTGCardPackages(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GetMTGCardPackages(rctx, fc.Args["cardPackageID"].(*string), fc.Args["includePublic"].(*bool))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.MtgCardPackage)
	fc.Result = res
	return ec.marshalNMTG_CardPackage2magichelpergraphmodelMtgCardPackage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getMTGCardPackages(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ID":
				return ec.fieldContext_MTG_CardPackage_ID(ctx, field)
			case "name":
				return ec.fieldContext_MTG_CardPackage_name(ctx, field)
			case "isPublic":
				return ec.fieldContext_MTG_CardPackage_isPublic(ctx, field)
			case "ownerID":
				return ec.fieldContext_MTG_CardPackage_ownerID(ctx, field)
			case "cards":
				return ec.fieldContext_MTG_CardPackage_cards(ctx, field)
			case "zones":
				return ec.fieldContext_MTG_CardPackage_zones(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MTG_CardPackage", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getMTGCardPackages_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_tags(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_tags(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Tags(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.Tag)
	fc.Result = res
	return ec.marshalNTag2magichelpergraphmodelTag(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_tags(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_cardTags(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_cardTags(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().CardTags(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.CardTag)
	fc.Result = res
	return ec.marshalNCardTag2magichelpergraphmodelCardTag(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_cardTags(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ID":
				return ec.fieldContext_CardTag_ID(ctx, field)
			case "name":
				return ec.fieldContext_CardTag_name(ctx, field)
			case "description":
				return ec.fieldContext_CardTag_description(ctx, field)
			case "myRating":
				return ec.fieldContext_CardTag_myRating(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CardTag", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_deckTags(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_deckTags(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().DeckTags(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.DeckTag)
	fc.Result = res
	return ec.marshalNDeckTag2magichelpergraphmodelDeckTag(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_deckTags(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ID":
				return ec.fieldContext_DeckTag_ID(ctx, field)
			case "name":
				return ec.fieldContext_DeckTag_name(ctx, field)
			case "description":
				return ec.fieldContext_DeckTag_description(ctx, field)
			case "myRating":
				return ec.fieldContext_DeckTag_myRating(ctx, field)
			case "colors":
				return ec.fieldContext_DeckTag_colors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DeckTag", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_tag(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_tag(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Tag(rctx, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.Tag)
	fc.Result = res
	return ec.marshalOTag2magichelpergraphmodelTag(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_tag(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_tag_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_adminDashboard(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_adminDashboard(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().AdminDashboard(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.AdminDashboard)
	fc.Result = res
	return ec.marshalNAdminDashboard2magichelpergraphmodelAdminDashboard(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_adminDashboard(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "imports":
				return ec.fieldContext_AdminDashboard_imports(ctx, field)
			case "latestLegalitiesDiff":
				return ec.fieldContext_AdminDashboard_latestLegalitiesDiff(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AdminDashboard", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_adminLegalitiesDiff(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_adminLegalitiesDiff(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().AdminLegalitiesDiff(rctx, fc.Args["importId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.AdminLegalitiesDiff)
	fc.Result = res
	return ec.marshalOAdminLegalitiesDiff2magichelpergraphmodelAdminLegalitiesDiff(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_adminLegalitiesDiff(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "importId":
				return ec.fieldContext_AdminLegalitiesDiff_importId(ctx, field)
			case "jobName":
				return ec.fieldContext_AdminLegalitiesDiff_jobName(ctx, field)
			case "entries":
				return ec.fieldContext_AdminLegalitiesDiff_entries(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AdminLegalitiesDiff", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_adminLegalitiesDiff_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_adminImportReports(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_adminImportReports(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().AdminImportReports(rctx, fc.Args["job"].(model.AdminJob), fc.Args["limit"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.AdminImportReport)
	fc.Result = res
	return ec.marshalNAdminImportReport2magichelpergraphmodelAdminImportReport(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_adminImportReports(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_AdminImportReport_id(ctx, field)
			case "jobName":
				return ec.fieldContext_AdminImportReport_jobName(ctx, field)
			case "status":
				return ec.fieldContext_AdminImportReport_status(ctx, field)
			case "startedAt":
				return ec.fieldContext_AdminImportReport_startedAt(ctx, field)
			case "completedAt":
				return ec.fieldContext_AdminImportReport_completedAt(ctx, field)
			case "durationMs":
				return ec.fieldContext_AdminImportReport_durationMs(ctx, field)
			case "recordsProcessed":
				return ec.fieldContext_AdminImportReport_recordsProcessed(ctx, field)
			case "errorMessage":
				return ec.fieldContext_AdminImportReport_errorMessage(ctx, field)
			case "metadata":
				return ec.fieldContext_AdminImportReport_metadata(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AdminImportReport", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_adminImportReports_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(fc.Args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query___type_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___schema(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	fc.Result = res
	return ec.marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___schema(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "description":
				return ec.fieldContext___Schema_description(ctx, field)
			case "types":
				return ec.fieldContext___Schema_types(ctx, field)
			case "queryType":
				return ec.fieldContext___Schema_queryType(ctx, field)
			case "mutationType":
				return ec.fieldContext___Schema_mutationType(ctx, field)
			case "subscriptionType":
				return ec.fieldContext___Schema_subscriptionType(ctx, field)
			case "directives":
				return ec.fieldContext___Schema_directives(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Schema", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Response_status(ctx context.Context, field graphql.CollectedField, obj *model.Response) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Response_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Response_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Response",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Response_message(ctx context.Context, field graphql.CollectedField, obj *model.Response) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Response_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Response_message(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Response",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_ID(ctx context.Context, field graphql.CollectedField, obj *model.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_ID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_ID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_roles(ctx context.Context, field graphql.CollectedField, obj *model.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_roles(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Roles, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.UserRole)
	fc.Result = res
	return ec.marshalNUserRole2magichelpergraphmodelUserRole(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_roles(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type UserRole does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserRating_user(ctx context.Context, field graphql.CollectedField, obj *model.UserRating) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserRating_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.User, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.User)
	fc.Result = res
	return ec.marshalNUser2magichelpergraphmodelUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserRating_user(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserRating",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ID":
				return ec.fieldContext_User_ID(ctx, field)
			case "roles":
				return ec.fieldContext_User_roles(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserRating_value(ctx context.Context, field graphql.CollectedField, obj *model.UserRating) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserRating_value(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Value, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserRating_value(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserRating",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_locations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalN__DirectiveLocation2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_locations(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __DirectiveLocation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___InputValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___InputValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Directive_args_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_isRepeatable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRepeatable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_isRepeatable(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_isDeprecated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_deprecationReason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___InputValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___InputValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Field_args_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_isDeprecated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_deprecationReason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_defaultValue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_defaultValue(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_isDeprecated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_deprecationReason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_types(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_types(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_queryType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_queryType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_mutationType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_mutationType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_subscriptionType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_subscriptionType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_directives(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	fc.Result = res
	return ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_directives(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Directive_name(ctx, field)
			case "description":
				return ec.fieldContext___Directive_description(ctx, field)
			case "locations":
				return ec.fieldContext___Directive_locations(ctx, field)
			case "args":
				return ec.fieldContext___Directive_args(ctx, field)
			case "isRepeatable":
				return ec.fieldContext___Directive_isRepeatable(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Directive", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_kind(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalN__TypeKind2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_kind(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __TypeKind does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_fields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	fc.Result = res
	return ec.marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_fields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Field_name(ctx, field)
			case "description":
				return ec.fieldContext___Field_description(ctx, field)
			case "args":
				return ec.fieldContext___Field_args(ctx, field)
			case "type":
				return ec.fieldContext___Field_type(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___Field_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___Field_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Field", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_fields_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_interfaces(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_interfaces(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_possibleTypes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_possibleTypes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_enumValues(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	fc.Result = res
	return ec.marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_enumValues(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___EnumValue_name(ctx, field)
			case "description":
				return ec.fieldContext___EnumValue_description(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___EnumValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___EnumValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __EnumValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_enumValues_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_inputFields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_inputFields(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___InputValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___InputValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_ofType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_ofType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_specifiedByURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpecifiedByURL(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_specifiedByURL(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_isOneOf(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_isOneOf(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsOneOf(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_isOneOf(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputAddIgnoredCardInput(ctx context.Context, obj any) (model.AddIgnoredCardInput, error) {
	var it model.AddIgnoredCardInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"cardID", "deckID"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "cardID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cardID"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CardID = data
		case "deckID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deckID"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeckID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputAdminImportActionInput(ctx context.Context, obj any) (model.AdminImportActionInput, error) {
	var it model.AdminImportActionInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	if _, present := asMap["force"]; !present {
		asMap["force"] = false
	}

	fieldsInOrder := [...]string{"job", "force"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "job":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("job"))
			data, err := ec.unmarshalNAdminJob2magichelpergraphmodelAdminJob(ctx, v)
			if err != nil {
				return it, err
			}
			it.Job = data
		case "force":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("force"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Force = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputAssignTagInput(ctx context.Context, obj any) (model.AssignTagInput, error) {
	var it model.AssignTagInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"tagID", "cardID"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "tagID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tagID"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TagID = data
		case "cardID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cardID"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CardID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateTagInput(ctx context.Context, obj any) (model.CreateTagInput, error) {
	var it model.CreateTagInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"type", "name", "description", "colors", "cardID"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalNTagType2magichelpergraphmodelTagType(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "colors":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("colors"))
			data, err := ec.unmarshalOMTG_Color2magichelpergraphmodelMtgColor(ctx, v)
			if err != nil {
				return it, err
			}
			it.Colors = data
		case "cardID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cardID"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CardID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputFlowZoneInput(ctx context.Context, obj any) (model.FlowZoneInput, error) {
	var it model.FlowZoneInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"ID", "name", "position", "width", "height", "cardChildren", "zoneChildren"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "ID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ID"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "position":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("position"))
			data, err := ec.unmarshalNPositionInput2magichelpergraphmodelPositionInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Position = data
		case "width":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("width"))
			data, err := ec.unmarshalNFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Width = data
		case "height":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("height"))
			data, err := ec.unmarshalNFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Height = data
		case "cardChildren":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cardChildren"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CardChildren = data
		case "zoneChildren":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("zoneChildren"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ZoneChildren = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMTG_AddCardToCardPackageInput(ctx context.Context, obj any) (model.MtgAddCardToCardPackageInput, error) {
	var it model.MtgAddCardToCardPackageInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"cardPackageID", "card", "count"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "cardPackageID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cardPackageID"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CardPackageID = data
		case "card":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("card"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Card = data
		case "count":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("count"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Count = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMTG_CardPackageCardInput(ctx context.Context, obj any) (model.MtgCardPackageCardInput, error) {
	var it model.MtgCardPackageCardInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"card", "selectedVersionID", "count", "mainOrSide"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "card":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("card"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Card = data
		case "selectedVersionID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("selectedVersionID"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SelectedVersionID = data
		case "count":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("count"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Count = data
		case "mainOrSide":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("mainOrSide"))
			data, err := ec.unmarshalNMainOrSide2magichelpergraphmodelMainOrSide(ctx, v)
			if err != nil {
				return it, err
			}
			it.MainOrSide = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMTG_CreateCardPackageInput(ctx context.Context, obj any) (model.MtgCreateCardPackageInput, error) {
	var it model.MtgCreateCardPackageInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	if _, present := asMap["isPublic"]; !present {
		asMap["isPublic"] = false
	}

	fieldsInOrder := [...]string{"name", "isPublic"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "isPublic":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isPublic"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsPublic = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMTG_CreateDeckInput(ctx context.Context, obj any) (model.MtgCreateDeckInput, error) {
	var it model.MtgCreateDeckInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMTG_DeckCardFrontImageInput(ctx context.Context, obj any) (model.MtgDeckCardFrontImageInput, error) {
	var it model.MtgDeckCardFrontImageInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"cardID", "versionID"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "cardID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cardID"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CardID = data
		case "versionID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("versionID"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.VersionID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMTG_DeckCardInput(ctx context.Context, obj any) (model.MtgDeckCardInput, error) {
	var it model.MtgDeckCardInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"ID", "card", "selectedVersionID", "count", "position", "mainOrSide", "deckCardType", "phantoms"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "ID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ID"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "card":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("card"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Card = data
		case "selectedVersionID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("selectedVersionID"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SelectedVersionID = data
		case "count":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("count"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Count = data
		case "position":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("position"))
			data, err := ec.unmarshalNPositionInput2magichelpergraphmodelPositionInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Position = data
		case "mainOrSide":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("mainOrSide"))
			data, err := ec.unmarshalNMainOrSide2magichelpergraphmodelMainOrSide(ctx, v)
			if err != nil {
				return it, err
			}
			it.MainOrSide = data
		case "deckCardType":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deckCardType"))
			data, err := ec.unmarshalNMTG_DeckCardType2magichelpergraphmodelMtgDeckCardType(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeckCardType = data
		case "phantoms":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("phantoms"))
			data, err := ec.unmarshalNPhantomInput2magichelpergraphmodelPhantomInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Phantoms = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMTG_DeleteCardPackageInput(ctx context.Context, obj any) (model.MtgDeleteCardPackageInput, error) {
	var it model.MtgDeleteCardPackageInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"cardPackageID"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "cardPackageID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cardPackageID"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CardPackageID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMTG_DeleteDeckInput(ctx context.Context, obj any) (model.MtgDeleteDeckInput, error) {
	var it model.MtgDeleteDeckInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"deckID"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "deckID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deckID"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeckID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMTG_EditCardPackageNameInput(ctx context.Context, obj any) (model.MtgEditCardPackageNameInput, error) {
	var it model.MtgEditCardPackageNameInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"cardPackageID", "name"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "cardPackageID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cardPackageID"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CardPackageID = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMTG_EditCardPackageVisibilityInput(ctx context.Context, obj any) (model.MtgEditCardPackageVisibilityInput, error) {
	var it model.MtgEditCardPackageVisibilityInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"cardPackageID", "isPublic"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "cardPackageID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cardPackageID"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CardPackageID = data
		case "isPublic":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isPublic"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsPublic = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMTG_Filter_CardTypeInput(ctx context.Context, obj any) (model.MtgFilterCardTypeInput, error) {
	var it model.MtgFilterCardTypeInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"cardType", "value"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "cardType":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cardType"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CardType = data
		case "value":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalNTernaryBoolean2magichelpergraphmodelTernaryBoolean(ctx, v)
			if err != nil {
				return it, err
			}
			it.Value = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMTG_Filter_ColorInput(ctx context.Context, obj any) (model.MtgFilterColorInput, error) {
	var it model.MtgFilterColorInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"color", "value"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "color":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("color"))
			data, err := ec.unmarshalNMTG_Color2magichelpergraphmodelMtgColor(ctx, v)
			if err != nil {
				return it, err
			}
			it.Color = data
		case "value":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalNTernaryBoolean2magichelpergraphmodelTernaryBoolean(ctx, v)
			if err != nil {
				return it, err
			}
			it.Value = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMTG_Filter_GameInput(ctx context.Context, obj any) (model.MtgFilterGameInput, error) {
	var it model.MtgFilterGameInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"game", "value"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "game":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("game"))
			data, err := ec.unmarshalNMTG_Game2magichelpergraphmodelMtgGame(ctx, v)
			if err != nil {
				return it, err
			}
			it.Game = data
		case "value":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalNTernaryBoolean2magichelpergraphmodelTernaryBoolean(ctx, v)
			if err != nil {
				return it, err
			}
			it.Value = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMTG_Filter_LayoutInput(ctx context.Context, obj any) (model.MtgFilterLayoutInput, error) {
	var it model.MtgFilterLayoutInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"layout", "value"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "layout":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("layout"))
			data, err := ec.unmarshalNMTG_Layout2magichelpergraphmodelMtgLayout(ctx, v)
			if err != nil {
				return it, err
			}
			it.Layout = data
		case "value":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalNTernaryBoolean2magichelpergraphmodelTernaryBoolean(ctx, v)
			if err != nil {
				return it, err
			}
			it.Value = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMTG_Filter_LegalityEntryInput(ctx context.Context, obj any) (model.MtgFilterLegalityEntryInput, error) {
	var it model.MtgFilterLegalityEntryInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"legalityValue", "value"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "legalityValue":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("legalityValue"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LegalityValue = data
		case "value":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalNTernaryBoolean2magichelpergraphmodelTernaryBoolean(ctx, v)
			if err != nil {
				return it, err
			}
			it.Value = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMTG_Filter_LegalityInput(ctx context.Context, obj any) (model.MtgFilterLegalityInput, error) {
	var it model.MtgFilterLegalityInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"format", "legalityEntries"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "format":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("format"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Format = data
		case "legalityEntries":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("legalityEntries"))
			data, err := ec.unmarshalNMTG_Filter_LegalityEntryInput2magichelpergraphmodelMtgFilterLegalityEntryInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.LegalityEntries = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMTG_Filter_ManaCostInput(ctx context.Context, obj any) (model.MtgFilterManaCostInput, error) {
	var it model.MtgFilterManaCostInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"manaCost", "value"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "manaCost":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("manaCost"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ManaCost = data
		case "value":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalNTernaryBoolean2magichelpergraphmodelTernaryBoolean(ctx, v)
			if err != nil {
				return it, err
			}
			it.Value = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMTG_Filter_PaginationInput(ctx context.Context, obj any) (model.MtgFilterPaginationInput, error) {
	var it model.MtgFilterPaginationInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"page", "pageSize"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "page":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("page"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Page = data
		case "pageSize":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pageSize"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.PageSize = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMTG_Filter_RarityInput(ctx context.Context, obj any) (model.MtgFilterRarityInput, error) {
	var it model.MtgFilterRarityInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"rarity", "value"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "rarity":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rarity"))
			data, err := ec.unmarshalNMTG_Rarity2magichelpergraphmodelMtgRarity(ctx, v)
			if err != nil {
				return it, err
			}
			it.Rarity = data
		case "value":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalNTernaryBoolean2magichelpergraphmodelTernaryBoolean(ctx, v)
			if err != nil {
				return it, err
			}
			it.Value = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMTG_Filter_RatingInput(ctx context.Context, obj any) (model.MtgFilterRatingInput, error) {
	var it model.MtgFilterRatingInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"min", "max"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "min":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("min"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Min = data
		case "max":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("max"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Max = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMTG_Filter_SearchInput(ctx context.Context, obj any) (model.MtgFilterSearchInput, error) {
	var it model.MtgFilterSearchInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"searchString", "rarity", "color", "multiColor", "manaCosts", "cardTypes", "subtypes", "sets", "legalities", "layouts", "games", "hideIgnored", "tags", "rating", "commander", "deckID", "isSelectingCommander"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "searchString":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("searchString"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SearchString = data
		case "rarity":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rarity"))
			data, err := ec.unmarshalNMTG_Filter_RarityInput2magichelpergraphmodelMtgFilterRarityInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Rarity = data
		case "color":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("color"))
			data, err := ec.unmarshalNMTG_Filter_ColorInput2magichelpergraphmodelMtgFilterColorInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Color = data
		case "multiColor":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("multiColor"))
			data, err := ec.unmarshalNTernaryBoolean2magichelpergraphmodelTernaryBoolean(ctx, v)
			if err != nil {
				return it, err
			}
			it.MultiColor = data
		case "manaCosts":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("manaCosts"))
			data, err := ec.unmarshalNMTG_Filter_ManaCostInput2magichelpergraphmodelMtgFilterManaCostInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.ManaCosts = data
		case "cardTypes":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cardTypes"))
			data, err := ec.unmarshalNMTG_Filter_CardTypeInput2magichelpergraphmodelMtgFilterCardTypeInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.CardTypes = data
		case "subtypes":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subtypes"))
			data, err := ec.unmarshalNMTG_Filter_SubtypeInput2magichelpergraphmodelMtgFilterSubtypeInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Subtypes = data
		case "sets":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sets"))
			data, err := ec.unmarshalNMTG_Filter_SetInput2magichelpergraphmodelMtgFilterSetInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Sets = data
		case "legalities":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("legalities"))
			data, err := ec.unmarshalNMTG_Filter_LegalityInput2magichelpergraphmodelMtgFilterLegalityInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Legalities = data
		case "layouts":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("layouts"))
			data, err := ec.unmarshalNMTG_Filter_LayoutInput2magichelpergraphmodelMtgFilterLayoutInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Layouts = data
		case "games":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("games"))
			data, err := ec.unmarshalNMTG_Filter_GameInput2magichelpergraphmodelMtgFilterGameInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Games = data
		case "hideIgnored":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hideIgnored"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HideIgnored = data
		case "tags":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tags"))
			data, err := ec.unmarshalNMTG_Filter_TagInput2magichelpergraphmodelMtgFilterTagInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Tags = data
		case "rating":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rating"))
			data, err := ec.unmarshalNMTG_Filter_RatingInput2magichelpergraphmodelMtgFilterRatingInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Rating = data
		case "commander":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("commander"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Commander = data
		case "deckID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deckID"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeckID = data
		case "isSelectingCommander":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isSelectingCommander"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsSelectingCommander = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMTG_Filter_SetInput(ctx context.Context, obj any) (model.MtgFilterSetInput, error) {
	var it model.MtgFilterSetInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"set", "value"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "set":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("set"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Set = data
		case "value":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalNTernaryBoolean2magichelpergraphmodelTernaryBoolean(ctx, v)
			if err != nil {
				return it, err
			}
			it.Value = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMTG_Filter_SortInput(ctx context.Context, obj any) (model.MtgFilterSortInput, error) {
	var it model.MtgFilterSortInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"sortBy", "sortDirection", "enabled"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "sortBy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sortBy"))
			data, err := ec.unmarshalNMTG_Filter_SortBy2magichelpergraphmodelMtgFilterSortBy(ctx, v)
			if err != nil {
				return it, err
			}
			it.SortBy = data
		case "sortDirection":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sortDirection"))
			data, err := ec.unmarshalNMTG_Filter_SortDirection2magichelpergraphmodelMtgFilterSortDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.SortDirection = data
		case "enabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("enabled"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Enabled = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMTG_Filter_SubtypeInput(ctx context.Context, obj any) (model.MtgFilterSubtypeInput, error) {
	var it model.MtgFilterSubtypeInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"subtype", "value"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "subtype":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subtype"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Subtype = data
		case "value":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalNTernaryBoolean2magichelpergraphmodelTernaryBoolean(ctx, v)
			if err != nil {
				return it, err
			}
			it.Value = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMTG_Filter_TagInput(ctx context.Context, obj any) (model.MtgFilterTagInput, error) {
	var it model.MtgFilterTagInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"tag", "value"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "tag":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tag"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Tag = data
		case "value":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalNTernaryBoolean2magichelpergraphmodelTernaryBoolean(ctx, v)
			if err != nil {
				return it, err
			}
			it.Value = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMTG_RemoveCardFromCardPackageInput(ctx context.Context, obj any) (model.MtgRemoveCardFromCardPackageInput, error) {
	var it model.MtgRemoveCardFromCardPackageInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"cardPackageID", "card"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "cardPackageID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cardPackageID"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CardPackageID = data
		case "card":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("card"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Card = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMTG_UpdateDeckInput(ctx context.Context, obj any) (model.MtgUpdateDeckInput, error) {
	var it model.MtgUpdateDeckInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"deckID", "name", "cardFrontImage", "cards", "zones"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "deckID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deckID"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeckID = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "cardFrontImage":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cardFrontImage"))
			data, err := ec.unmarshalOMTG_DeckCardFrontImageInput2magichelpergraphmodelMtgDeckCardFrontImageInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.CardFrontImage = data
		case "cards":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cards"))
			data, err := ec.unmarshalNMTG_DeckCardInput2magichelpergraphmodelMtgDeckCardInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Cards = data
		case "zones":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("zones"))
			data, err := ec.unmarshalNFlowZoneInput2magichelpergraphmodelFlowZoneInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Zones = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPhantomInput(ctx context.Context, obj any) (model.PhantomInput, error) {
	var it model.PhantomInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"ID", "position"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "ID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ID"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "position":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("position"))
			data, err := ec.unmarshalNPositionInput2magichelpergraphmodelPositionInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Position = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPositionInput(ctx context.Context, obj any) (model.PositionInput, error) {
	var it model.PositionInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"x", "y"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "x":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("x"))
			data, err := ec.unmarshalNFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.X = data
		case "y":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("y"))
			data, err := ec.unmarshalNFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Y = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRateInput(ctx context.Context, obj any) (model.RateInput, error) {
	var it model.RateInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"entityID", "entityType", "value"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "entityID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("entityID"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.EntityID = data
		case "entityType":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("entityType"))
			data, err := ec.unmarshalNRatableEntityType2magichelpergraphmodelRatableEntityType(ctx, v)
			if err != nil {
				return it, err
			}
			it.EntityType = data
		case "value":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Value = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRemoveIgnoredCardInput(ctx context.Context, obj any) (model.RemoveIgnoredCardInput, error) {
	var it model.RemoveIgnoredCardInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"cardID", "deckID"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "cardID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cardID"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CardID = data
		case "deckID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deckID"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeckID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUnassignTagInput(ctx context.Context, obj any) (model.UnassignTagInput, error) {
	var it model.UnassignTagInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"tagID", "cardID"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "tagID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tagID"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TagID = data
		case "cardID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cardID"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CardID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateTagInput(ctx context.Context, obj any) (model.UpdateTagInput, error) {
	var it model.UpdateTagInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"ID", "name", "description", "colors"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "ID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ID"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "colors":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("colors"))
			data, err := ec.unmarshalOMTG_Color2magichelpergraphmodelMtgColor(ctx, v)
			if err != nil {
				return it, err
			}
			it.Colors = data
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

func (ec *executionContext) _Tag(ctx context.Context, sel ast.SelectionSet, obj model.Tag) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.DeckTag:
		return ec._DeckTag(ctx, sel, &obj)
	case *model.DeckTag:
		if obj == nil {
			return graphql.Null
		}
		return ec._DeckTag(ctx, sel, obj)
	case model.CardTag:
		return ec._CardTag(ctx, sel, &obj)
	case *model.CardTag:
		if obj == nil {
			return graphql.Null
		}
		return ec._CardTag(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var adminDashboardImplementors = []string{"AdminDashboard"}

func (ec *executionContext) _AdminDashboard(ctx context.Context, sel ast.SelectionSet, obj *model.AdminDashboard) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, adminDashboardImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AdminDashboard")
		case "imports":
			out.Values[i] = ec._AdminDashboard_imports(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "latestLegalitiesDiff":
			out.Values[i] = ec._AdminDashboard_latestLegalitiesDiff(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var adminImportReportImplementors = []string{"AdminImportReport"}

func (ec *executionContext) _AdminImportReport(ctx context.Context, sel ast.SelectionSet, obj *model.AdminImportReport) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, adminImportReportImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AdminImportReport")
		case "id":
			out.Values[i] = ec._AdminImportReport_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "jobName":
			out.Values[i] = ec._AdminImportReport_jobName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "status":
			out.Values[i] = ec._AdminImportReport_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "startedAt":
			out.Values[i] = ec._AdminImportReport_startedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "completedAt":
			out.Values[i] = ec._AdminImportReport_completedAt(ctx, field, obj)
		case "durationMs":
			out.Values[i] = ec._AdminImportReport_durationMs(ctx, field, obj)
		case "recordsProcessed":
			out.Values[i] = ec._AdminImportReport_recordsProcessed(ctx, field, obj)
		case "errorMessage":
			out.Values[i] = ec._AdminImportReport_errorMessage(ctx, field, obj)
		case "metadata":
			out.Values[i] = ec._AdminImportReport_metadata(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var adminImportSummaryImplementors = []string{"AdminImportSummary"}

func (ec *executionContext) _AdminImportSummary(ctx context.Context, sel ast.SelectionSet, obj *model.AdminImportSummary) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, adminImportSummaryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AdminImportSummary")
		case "jobName":
			out.Values[i] = ec._AdminImportSummary_jobName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "lastRun":
			out.Values[i] = ec._AdminImportSummary_lastRun(ctx, field, obj)
		case "previousRun":
			out.Values[i] = ec._AdminImportSummary_previousRun(ctx, field, obj)
		case "latency":
			out.Values[i] = ec._AdminImportSummary_latency(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var adminLatencyMetricsImplementors = []string{"AdminLatencyMetrics"}

func (ec *executionContext) _AdminLatencyMetrics(ctx context.Context, sel ast.SelectionSet, obj *model.AdminLatencyMetrics) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, adminLatencyMetricsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AdminLatencyMetrics")
		case "lastDurationMs":
			out.Values[i] = ec._AdminLatencyMetrics_lastDurationMs(ctx, field, obj)
		case "avgDurationMs":
			out.Values[i] = ec._AdminLatencyMetrics_avgDurationMs(ctx, field, obj)
		case "p50DurationMs":
			out.Values[i] = ec._AdminLatencyMetrics_p50DurationMs(ctx, field, obj)
		case "p90DurationMs":
			out.Values[i] = ec._AdminLatencyMetrics_p90DurationMs(ctx, field, obj)
		case "totalRuns":
			out.Values[i] = ec._AdminLatencyMetrics_totalRuns(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "lastStartedAt":
			out.Values[i] = ec._AdminLatencyMetrics_lastStartedAt(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var adminLegalitiesDiffImplementors = []string{"AdminLegalitiesDiff"}

func (ec *executionContext) _AdminLegalitiesDiff(ctx context.Context, sel ast.SelectionSet, obj *model.AdminLegalitiesDiff) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, adminLegalitiesDiffImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AdminLegalitiesDiff")
		case "importId":
			out.Values[i] = ec._AdminLegalitiesDiff_importId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "jobName":
			out.Values[i] = ec._AdminLegalitiesDiff_jobName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "entries":
			out.Values[i] = ec._AdminLegalitiesDiff_entries(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var adminLegalitiesDiffEntryImplementors = []string{"AdminLegalitiesDiffEntry"}

func (ec *executionContext) _AdminLegalitiesDiffEntry(ctx context.Context, sel ast.SelectionSet, obj *model.AdminLegalitiesDiffEntry) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, adminLegalitiesDiffEntryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AdminLegalitiesDiffEntry")
		case "cardID":
			out.Values[i] = ec._AdminLegalitiesDiffEntry_cardID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "cardName":
			out.Values[i] = ec._AdminLegalitiesDiffEntry_cardName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "format":
			out.Values[i] = ec._AdminLegalitiesDiffEntry_format(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "previousStatus":
			out.Values[i] = ec._AdminLegalitiesDiffEntry_previousStatus(ctx, field, obj)
		case "currentStatus":
			out.Values[i] = ec._AdminLegalitiesDiffEntry_currentStatus(ctx, field, obj)
		case "setCode":
			out.Values[i] = ec._AdminLegalitiesDiffEntry_setCode(ctx, field, obj)
		case "setName":
			out.Values[i] = ec._AdminLegalitiesDiffEntry_setName(ctx, field, obj)
		case "changedAt":
			out.Values[i] = ec._AdminLegalitiesDiffEntry_changedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var cardTagImplementors = []string{"CardTag", "Tag"}

func (ec *executionContext) _CardTag(ctx context.Context, sel ast.SelectionSet, obj *model.CardTag) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, cardTagImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CardTag")
		case "ID":
			out.Values[i] = ec._CardTag_ID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._CardTag_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec._CardTag_description(ctx, field, obj)
		case "myRating":
			out.Values[i] = ec._CardTag_myRating(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var deckTagImplementors = []string{"DeckTag", "Tag"}

func (ec *executionContext) _DeckTag(ctx context.Context, sel ast.SelectionSet, obj *model.DeckTag) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, deckTagImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DeckTag")
		case "ID":
			out.Values[i] = ec._DeckTag_ID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._DeckTag_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec._DeckTag_description(ctx, field, obj)
		case "myRating":
			out.Values[i] = ec._DeckTag_myRating(ctx, field, obj)
		case "colors":
			out.Values[i] = ec._DeckTag_colors(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var flowZoneImplementors = []string{"FlowZone"}

func (ec *executionContext) _FlowZone(ctx context.Context, sel ast.SelectionSet, obj *model.FlowZone) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, flowZoneImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FlowZone")
		case "ID":
			out.Values[i] = ec._FlowZone_ID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._FlowZone_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "position":
			out.Values[i] = ec._FlowZone_position(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "width":
			out.Values[i] = ec._FlowZone_width(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "height":
			out.Values[i] = ec._FlowZone_height(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "cardChildren":
			out.Values[i] = ec._FlowZone_cardChildren(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "zoneChildren":
			out.Values[i] = ec._FlowZone_zoneChildren(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mTG_CardImplementors = []string{"MTG_Card"}

func (ec *executionContext) _MTG_Card(ctx context.Context, sel ast.SelectionSet, obj *model.MtgCard) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mTG_CardImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MTG_Card")
		case "ID":
			out.Values[i] = ec._MTG_Card_ID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "layout":
			out.Values[i] = ec._MTG_Card_layout(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "CMC":
			out.Values[i] = ec._MTG_Card_CMC(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "colorIdentity":
			out.Values[i] = ec._MTG_Card_colorIdentity(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "colorIndicator":
			out.Values[i] = ec._MTG_Card_colorIndicator(ctx, field, obj)
		case "colors":
			out.Values[i] = ec._MTG_Card_colors(ctx, field, obj)
		case "EDHRecRank":
			out.Values[i] = ec._MTG_Card_EDHRecRank(ctx, field, obj)
		case "keywords":
			out.Values[i] = ec._MTG_Card_keywords(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "loyalty":
			out.Values[i] = ec._MTG_Card_loyalty(ctx, field, obj)
		case "manaCost":
			out.Values[i] = ec._MTG_Card_manaCost(ctx, field, obj)
		case "name":
			out.Values[i] = ec._MTG_Card_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "oracleText":
			out.Values[i] = ec._MTG_Card_oracleText(ctx, field, obj)
		case "power":
			out.Values[i] = ec._MTG_Card_power(ctx, field, obj)
		case "producedMana":
			out.Values[i] = ec._MTG_Card_producedMana(ctx, field, obj)
		case "toughness":
			out.Values[i] = ec._MTG_Card_toughness(ctx, field, obj)
		case "typeLine":
			out.Values[i] = ec._MTG_Card_typeLine(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "versions":
			out.Values[i] = ec._MTG_Card_versions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "myRating":
			out.Values[i] = ec._MTG_Card_myRating(ctx, field, obj)
		case "cardTags":
			out.Values[i] = ec._MTG_Card_cardTags(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deckTags":
			out.Values[i] = ec._MTG_Card_deckTags(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mTG_CardFaceImplementors = []string{"MTG_CardFace"}

func (ec *executionContext) _MTG_CardFace(ctx context.Context, sel ast.SelectionSet, obj *model.MtgCardFace) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mTG_CardFaceImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MTG_CardFace")
		case "artist":
			out.Values[i] = ec._MTG_CardFace_artist(ctx, field, obj)
		case "CMC":
			out.Values[i] = ec._MTG_CardFace_CMC(ctx, field, obj)
		case "colorIndicator":
			out.Values[i] = ec._MTG_CardFace_colorIndicator(ctx, field, obj)
		case "colors":
			out.Values[i] = ec._MTG_CardFace_colors(ctx, field, obj)
		case "flavorText":
			out.Values[i] = ec._MTG_CardFace_flavorText(ctx, field, obj)
		case "imageUris":
			out.Values[i] = ec._MTG_CardFace_imageUris(ctx, field, obj)
		case "layout":
			out.Values[i] = ec._MTG_CardFace_layout(ctx, field, obj)
		case "loyalty":
			out.Values[i] = ec._MTG_CardFace_loyalty(ctx, field, obj)
		case "manaCost":
			out.Values[i] = ec._MTG_CardFace_manaCost(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._MTG_CardFace_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "oracleText":
			out.Values[i] = ec._MTG_CardFace_oracleText(ctx, field, obj)
		case "power":
			out.Values[i] = ec._MTG_CardFace_power(ctx, field, obj)
		case "toughness":
			out.Values[i] = ec._MTG_CardFace_toughness(ctx, field, obj)
		case "typeLine":
			out.Values[i] = ec._MTG_CardFace_typeLine(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mTG_CardFace_DashboardImplementors = []string{"MTG_CardFace_Dashboard"}

func (ec *executionContext) _MTG_CardFace_Dashboard(ctx context.Context, sel ast.SelectionSet, obj *model.MtgCardFaceDashboard) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mTG_CardFace_DashboardImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MTG_CardFace_Dashboard")
		case "imageUris":
			out.Values[i] = ec._MTG_CardFace_Dashboard_imageUris(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mTG_CardPackageImplementors = []string{"MTG_CardPackage"}

func (ec *executionContext) _MTG_CardPackage(ctx context.Context, sel ast.SelectionSet, obj *model.MtgCardPackage) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mTG_CardPackageImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MTG_CardPackage")
		case "ID":
			out.Values[i] = ec._MTG_CardPackage_ID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._MTG_CardPackage_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isPublic":
			out.Values[i] = ec._MTG_CardPackage_isPublic(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "ownerID":
			out.Values[i] = ec._MTG_CardPackage_ownerID(ctx, field, obj)
		case "cards":
			out.Values[i] = ec._MTG_CardPackage_cards(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "zones":
			out.Values[i] = ec._MTG_CardPackage_zones(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mTG_CardPackageCardImplementors = []string{"MTG_CardPackageCard"}

func (ec *executionContext) _MTG_CardPackageCard(ctx context.Context, sel ast.SelectionSet, obj *model.MtgCardPackageCard) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mTG_CardPackageCardImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MTG_CardPackageCard")
		case "card":
			out.Values[i] = ec._MTG_CardPackageCard_card(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "selectedVersionID":
			out.Values[i] = ec._MTG_CardPackageCard_selectedVersionID(ctx, field, obj)
		case "count":
			out.Values[i] = ec._MTG_CardPackageCard_count(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "mainOrSide":
			out.Values[i] = ec._MTG_CardPackageCard_mainOrSide(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "position":
			out.Values[i] = ec._MTG_CardPackageCard_position(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "phantoms":
			out.Values[i] = ec._MTG_CardPackageCard_phantoms(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mTG_CardVersionImplementors = []string{"MTG_CardVersion"}

func (ec *executionContext) _MTG_CardVersion(ctx context.Context, sel ast.SelectionSet, obj *model.MtgCardVersion) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mTG_CardVersionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MTG_CardVersion")
		case "ID":
			out.Values[i] = ec._MTG_CardVersion_ID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isDefault":
			out.Values[i] = ec._MTG_CardVersion_isDefault(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isAlchemy":
			out.Values[i] = ec._MTG_CardVersion_isAlchemy(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "artist":
			out.Values[i] = ec._MTG_CardVersion_artist(ctx, field, obj)
		case "lang":
			out.Values[i] = ec._MTG_CardVersion_lang(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "flavorName":
			out.Values[i] = ec._MTG_CardVersion_flavorName(ctx, field, obj)
		case "flavorText":
			out.Values[i] = ec._MTG_CardVersion_flavorText(ctx, field, obj)
		case "cardFaces":
			out.Values[i] = ec._MTG_CardVersion_cardFaces(ctx, field, obj)
		case "legalities":
			out.Values[i] = ec._MTG_CardVersion_legalities(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "games":
			out.Values[i] = ec._MTG_CardVersion_games(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "imageUris":
			out.Values[i] = ec._MTG_CardVersion_imageUris(ctx, field, obj)
		case "printedName":
			out.Values[i] = ec._MTG_CardVersion_printedName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "rarity":
			out.Values[i] = ec._MTG_CardVersion_rarity(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "releasedAt":
			out.Values[i] = ec._MTG_CardVersion_releasedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "reprint":
			out.Values[i] = ec._MTG_CardVersion_reprint(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "setName":
			out.Values[i] = ec._MTG_CardVersion_setName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "setType":
			out.Values[i] = ec._MTG_CardVersion_setType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "set":
			out.Values[i] = ec._MTG_CardVersion_set(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "setID":
			out.Values[i] = ec._MTG_CardVersion_setID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "variation":
			out.Values[i] = ec._MTG_CardVersion_variation(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "variationOf":
			out.Values[i] = ec._MTG_CardVersion_variationOf(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mTG_CardVersion_DashboardImplementors = []string{"MTG_CardVersion_Dashboard"}

func (ec *executionContext) _MTG_CardVersion_Dashboard(ctx context.Context, sel ast.SelectionSet, obj *model.MtgCardVersionDashboard) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mTG_CardVersion_DashboardImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MTG_CardVersion_Dashboard")
		case "ID":
			out.Values[i] = ec._MTG_CardVersion_Dashboard_ID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isDefault":
			out.Values[i] = ec._MTG_CardVersion_Dashboard_isDefault(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isAlchemy":
			out.Values[i] = ec._MTG_CardVersion_Dashboard_isAlchemy(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "cardFaces":
			out.Values[i] = ec._MTG_CardVersion_Dashboard_cardFaces(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "imageUris":
			out.Values[i] = ec._MTG_CardVersion_Dashboard_imageUris(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mTG_Card_DashboardImplementors = []string{"MTG_Card_Dashboard"}

func (ec *executionContext) _MTG_Card_Dashboard(ctx context.Context, sel ast.SelectionSet, obj *model.MtgCardDashboard) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mTG_Card_DashboardImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MTG_Card_Dashboard")
		case "ID":
			out.Values[i] = ec._MTG_Card_Dashboard_ID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "versions":
			out.Values[i] = ec._MTG_Card_Dashboard_versions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mTG_DeckImplementors = []string{"MTG_Deck"}

func (ec *executionContext) _MTG_Deck(ctx context.Context, sel ast.SelectionSet, obj *model.MtgDeck) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mTG_DeckImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MTG_Deck")
		case "ID":
			out.Values[i] = ec._MTG_Deck_ID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._MTG_Deck_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "cardFrontImage":
			out.Values[i] = ec._MTG_Deck_cardFrontImage(ctx, field, obj)
		case "cards":
			out.Values[i] = ec._MTG_Deck_cards(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "zones":
			out.Values[i] = ec._MTG_Deck_zones(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "ignoredCards":
			out.Values[i] = ec._MTG_Deck_ignoredCards(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mTG_DeckCardImplementors = []string{"MTG_DeckCard"}

func (ec *executionContext) _MTG_DeckCard(ctx context.Context, sel ast.SelectionSet, obj *model.MtgDeckCard) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mTG_DeckCardImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MTG_DeckCard")
		case "card":
			out.Values[i] = ec._MTG_DeckCard_card(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "selectedVersionID":
			out.Values[i] = ec._MTG_DeckCard_selectedVersionID(ctx, field, obj)
		case "count":
			out.Values[i] = ec._MTG_DeckCard_count(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "position":
			out.Values[i] = ec._MTG_DeckCard_position(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "mainOrSide":
			out.Values[i] = ec._MTG_DeckCard_mainOrSide(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deckCardType":
			out.Values[i] = ec._MTG_DeckCard_deckCardType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "phantoms":
			out.Values[i] = ec._MTG_DeckCard_phantoms(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mTG_DeckCard_DashboardImplementors = []string{"MTG_DeckCard_Dashboard"}

func (ec *executionContext) _MTG_DeckCard_Dashboard(ctx context.Context, sel ast.SelectionSet, obj *model.MtgDeckCardDashboard) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mTG_DeckCard_DashboardImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MTG_DeckCard_Dashboard")
		case "card":
			out.Values[i] = ec._MTG_DeckCard_Dashboard_card(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "selectedVersionID":
			out.Values[i] = ec._MTG_DeckCard_Dashboard_selectedVersionID(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mTG_DeckDashboardImplementors = []string{"MTG_DeckDashboard"}

func (ec *executionContext) _MTG_DeckDashboard(ctx context.Context, sel ast.SelectionSet, obj *model.MtgDeckDashboard) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mTG_DeckDashboardImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MTG_DeckDashboard")
		case "ID":
			out.Values[i] = ec._MTG_DeckDashboard_ID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._MTG_DeckDashboard_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "cardFrontImage":
			out.Values[i] = ec._MTG_DeckDashboard_cardFrontImage(ctx, field, obj)
		case "cards":
			out.Values[i] = ec._MTG_DeckDashboard_cards(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mTG_Deck_CardFrontImageImplementors = []string{"MTG_Deck_CardFrontImage"}

func (ec *executionContext) _MTG_Deck_CardFrontImage(ctx context.Context, sel ast.SelectionSet, obj *model.MtgDeckCardFrontImage) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mTG_Deck_CardFrontImageImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MTG_Deck_CardFrontImage")
		case "cardID":
			out.Values[i] = ec._MTG_Deck_CardFrontImage_cardID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "versionID":
			out.Values[i] = ec._MTG_Deck_CardFrontImage_versionID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "image":
			out.Values[i] = ec._MTG_Deck_CardFrontImage_image(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mTG_Filter_CardTypesImplementors = []string{"MTG_Filter_CardTypes"}

func (ec *executionContext) _MTG_Filter_CardTypes(ctx context.Context, sel ast.SelectionSet, obj *model.MtgFilterCardTypes) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mTG_Filter_CardTypesImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MTG_Filter_CardTypes")
		case "cardType":
			out.Values[i] = ec._MTG_Filter_CardTypes_cardType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "subtypes":
			out.Values[i] = ec._MTG_Filter_CardTypes_subtypes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mTG_Filter_EntriesImplementors = []string{"MTG_Filter_Entries"}

func (ec *executionContext) _MTG_Filter_Entries(ctx context.Context, sel ast.SelectionSet, obj *model.MtgFilterEntries) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mTG_Filter_EntriesImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MTG_Filter_Entries")
		case "types":
			out.Values[i] = ec._MTG_Filter_Entries_types(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "expansions":
			out.Values[i] = ec._MTG_Filter_Entries_expansions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "legality":
			out.Values[i] = ec._MTG_Filter_Entries_legality(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "layouts":
			out.Values[i] = ec._MTG_Filter_Entries_layouts(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mTG_Filter_ExpansionImplementors = []string{"MTG_Filter_Expansion"}

func (ec *executionContext) _MTG_Filter_Expansion(ctx context.Context, sel ast.SelectionSet, obj *model.MtgFilterExpansion) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mTG_Filter_ExpansionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MTG_Filter_Expansion")
		case "set":
			out.Values[i] = ec._MTG_Filter_Expansion_set(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "setName":
			out.Values[i] = ec._MTG_Filter_Expansion_setName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "releasedAt":
			out.Values[i] = ec._MTG_Filter_Expansion_releasedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "imageURL":
			out.Values[i] = ec._MTG_Filter_Expansion_imageURL(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "setType":
			out.Values[i] = ec._MTG_Filter_Expansion_setType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "games":
			out.Values[i] = ec._MTG_Filter_Expansion_games(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mTG_Filter_LegalityImplementors = []string{"MTG_Filter_Legality"}

func (ec *executionContext) _MTG_Filter_Legality(ctx context.Context, sel ast.SelectionSet, obj *model.MtgFilterLegality) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mTG_Filter_LegalityImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MTG_Filter_Legality")
		case "formats":
			out.Values[i] = ec._MTG_Filter_Legality_formats(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "legalityValues":
			out.Values[i] = ec._MTG_Filter_Legality_legalityValues(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mTG_Filter_SearchImplementors = []string{"MTG_Filter_Search"}

func (ec *executionContext) _MTG_Filter_Search(ctx context.Context, sel ast.SelectionSet, obj *model.MtgFilterSearch) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mTG_Filter_SearchImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MTG_Filter_Search")
		case "pagedCards":
			out.Values[i] = ec._MTG_Filter_Search_pagedCards(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._MTG_Filter_Search_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mTG_ImageImplementors = []string{"MTG_Image"}

func (ec *executionContext) _MTG_Image(ctx context.Context, sel ast.SelectionSet, obj *model.MtgImage) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mTG_ImageImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MTG_Image")
		case "artCrop":
			out.Values[i] = ec._MTG_Image_artCrop(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "borderCrop":
			out.Values[i] = ec._MTG_Image_borderCrop(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "large":
			out.Values[i] = ec._MTG_Image_large(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "normal":
			out.Values[i] = ec._MTG_Image_normal(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "PNG":
			out.Values[i] = ec._MTG_Image_PNG(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "small":
			out.Values[i] = ec._MTG_Image_small(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mutationImplementors = []string{"Mutation"}

func (ec *executionContext) _Mutation(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mutationImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Mutation",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mutation")
		case "createMTGDeck":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createMTGDeck(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteMTGDeck":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteMTGDeck(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateMTGDeck":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateMTGDeck(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "saveMTGDeckAsCopy":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_saveMTGDeckAsCopy(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createMTGCardPackage":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createMTGCardPackage(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteMTGCardPackage":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteMTGCardPackage(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "editMTGCardPackageName":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_editMTGCardPackageName(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "editMTGCardPackageVisibility":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_editMTGCardPackageVisibility(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "addMTGCardToCardPackage":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_addMTGCardToCardPackage(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "removeMTGCardFromCardPackage":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_removeMTGCardFromCardPackage(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createTag":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createTag(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateTag":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateTag(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteTag":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteTag(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "assignTag":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_assignTag(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "unassignTag":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_unassignTag(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "rate":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_rate(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "addIgnoredCard":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_addIgnoredCard(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "removeIgnoredCard":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_removeIgnoredCard(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "adminRetryImport":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_adminRetryImport(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "adminBackfillImport":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_adminBackfillImport(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var phantomImplementors = []string{"Phantom"}

func (ec *executionContext) _Phantom(ctx context.Context, sel ast.SelectionSet, obj *model.Phantom) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, phantomImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Phantom")
		case "position":
			out.Values[i] = ec._Phantom_position(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "ID":
			out.Values[i] = ec._Phantom_ID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var positionImplementors = []string{"Position"}

func (ec *executionContext) _Position(ctx context.Context, sel ast.SelectionSet, obj *model.Position) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, positionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Position")
		case "x":
			out.Values[i] = ec._Position_x(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "y":
			out.Values[i] = ec._Position_y(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "getMTGCards":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getMTGCards(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getMTGCardsFiltered":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getMTGCardsFiltered(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getMTGFilters":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getMTGFilters(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getMTGDecks":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getMTGDecks(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getMTGDeck":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getMTGDeck(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getMTGCardPackages":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getMTGCardPackages(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "tags":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_tags(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "cardTags":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_cardTags(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "deckTags":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_deckTags(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "tag":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_tag(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "adminDashboard":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_adminDashboard(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "adminLegalitiesDiff":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_adminLegalitiesDiff(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "adminImportReports":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_adminImportReports(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "__type":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___type(ctx, field)
			})
		case "__schema":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___schema(ctx, field)
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var responseImplementors = []string{"Response"}

func (ec *executionContext) _Response(ctx context.Context, sel ast.SelectionSet, obj *model.Response) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, responseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Response")
		case "status":
			out.Values[i] = ec._Response_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._Response_message(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var userImplementors = []string{"User"}

func (ec *executionContext) _User(ctx context.Context, sel ast.SelectionSet, obj *model.User) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("User")
		case "ID":
			out.Values[i] = ec._User_ID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "roles":
			out.Values[i] = ec._User_roles(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var userRatingImplementors = []string{"UserRating"}

func (ec *executionContext) _UserRating(ctx context.Context, sel ast.SelectionSet, obj *model.UserRating) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userRatingImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UserRating")
		case "user":
			out.Values[i] = ec._UserRating_user(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "value":
			out.Values[i] = ec._UserRating_value(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __DirectiveImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Directive_description(ctx, field, obj)
		case "locations":
			out.Values[i] = ec.___Directive_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "args":
			out.Values[i] = ec.___Directive_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isRepeatable":
			out.Values[i] = ec.___Directive_isRepeatable(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __EnumValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __FieldImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Field_description(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Field_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec.___Field_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __InputValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___InputValue_description(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___InputValue_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___InputValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___InputValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __SchemaImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "description":
			out.Values[i] = ec.___Schema_description(ctx, field, obj)
		case "types":
			out.Values[i] = ec.___Schema_types(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)
		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)
		case "directives":
			out.Values[i] = ec.___Schema_directives(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __TypeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec.___Type_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Type_description(ctx, field, obj)
		case "fields":
			out.Values[i] = ec.___Type_fields(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)
		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)
		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)
		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)
		case "ofType":
			out.Values[i] = ec.___Type_ofType(ctx, field, obj)
		case "specifiedByURL":
			out.Values[i] = ec.___Type_specifiedByURL(ctx, field, obj)
		case "isOneOf":
			out.Values[i] = ec.___Type_isOneOf(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) unmarshalNAddIgnoredCardInput2magichelpergraphmodelAddIgnoredCardInput(ctx context.Context, v any) (model.AddIgnoredCardInput, error) {
	res, err := ec.unmarshalInputAddIgnoredCardInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNAdminDashboard2magichelpergraphmodelAdminDashboard(ctx context.Context, sel ast.SelectionSet, v model.AdminDashboard) graphql.Marshaler {
	return ec._AdminDashboard(ctx, sel, &v)
}

func (ec *executionContext) marshalNAdminDashboard2magichelpergraphmodelAdminDashboard(ctx context.Context, sel ast.SelectionSet, v *model.AdminDashboard) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._AdminDashboard(ctx, sel, v)
}

func (ec *executionContext) unmarshalNAdminImportActionInput2magichelpergraphmodelAdminImportActionInput(ctx context.Context, v any) (model.AdminImportActionInput, error) {
	res, err := ec.unmarshalInputAdminImportActionInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNAdminImportReport2magichelpergraphmodelAdminImportReport(ctx context.Context, sel ast.SelectionSet, v []*model.AdminImportReport) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAdminImportReport2magichelpergraphmodelAdminImportReport(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNAdminImportReport2magichelpergraphmodelAdminImportReport(ctx context.Context, sel ast.SelectionSet, v *model.AdminImportReport) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._AdminImportReport(ctx, sel, v)
}

func (ec *executionContext) unmarshalNAdminImportStatus2magichelpergraphmodelAdminImportStatus(ctx context.Context, v any) (model.AdminImportStatus, error) {
	var res model.AdminImportStatus
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNAdminImportStatus2magichelpergraphmodelAdminImportStatus(ctx context.Context, sel ast.SelectionSet, v model.AdminImportStatus) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNAdminImportSummary2magichelpergraphmodelAdminImportSummary(ctx context.Context, sel ast.SelectionSet, v []*model.AdminImportSummary) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAdminImportSummary2magichelpergraphmodelAdminImportSummary(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNAdminImportSummary2magichelpergraphmodelAdminImportSummary(ctx context.Context, sel ast.SelectionSet, v *model.AdminImportSummary) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._AdminImportSummary(ctx, sel, v)
}

func (ec *executionContext) unmarshalNAdminJob2magichelpergraphmodelAdminJob(ctx context.Context, v any) (model.AdminJob, error) {
	var res model.AdminJob
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNAdminJob2magichelpergraphmodelAdminJob(ctx context.Context, sel ast.SelectionSet, v model.AdminJob) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNAdminLatencyMetrics2magichelpergraphmodelAdminLatencyMetrics(ctx context.Context, sel ast.SelectionSet, v *model.AdminLatencyMetrics) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._AdminLatencyMetrics(ctx, sel, v)
}

func (ec *executionContext) marshalNAdminLegalitiesDiffEntry2magichelpergraphmodelAdminLegalitiesDiffEntry(ctx context.Context, sel ast.SelectionSet, v []*model.AdminLegalitiesDiffEntry) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAdminLegalitiesDiffEntry2magichelpergraphmodelAdminLegalitiesDiffEntry(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNAdminLegalitiesDiffEntry2magichelpergraphmodelAdminLegalitiesDiffEntry(ctx context.Context, sel ast.SelectionSet, v *model.AdminLegalitiesDiffEntry) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._AdminLegalitiesDiffEntry(ctx, sel, v)
}

func (ec *executionContext) unmarshalNAssignTagInput2magichelpergraphmodelAssignTagInput(ctx context.Context, v any) (model.AssignTagInput, error) {
	res, err := ec.unmarshalInputAssignTagInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v any) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNCardTag2magichelpergraphmodelCardTag(ctx context.Context, sel ast.SelectionSet, v []*model.CardTag) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNCardTag2magichelpergraphmodelCardTag(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNCardTag2magichelpergraphmodelCardTag(ctx context.Context, sel ast.SelectionSet, v *model.CardTag) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CardTag(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCreateTagInput2magichelpergraphmodelCreateTagInput(ctx context.Context, v any) (model.CreateTagInput, error) {
	res, err := ec.unmarshalInputCreateTagInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDeckTag2magichelpergraphmodelDeckTag(ctx context.Context, sel ast.SelectionSet, v []*model.DeckTag) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNDeckTag2magichelpergraphmodelDeckTag(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNDeckTag2magichelpergraphmodelDeckTag(ctx context.Context, sel ast.SelectionSet, v *model.DeckTag) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._DeckTag(ctx, sel, v)
}

func (ec *executionContext) unmarshalNFloat2float64(ctx context.Context, v any) (float64, error) {
	res, err := graphql.UnmarshalFloatContext(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFloat2float64(ctx context.Context, sel ast.SelectionSet, v float64) graphql.Marshaler {
	res := graphql.MarshalFloatContext(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return graphql.WrapContextMarshaler(ctx, res)
}

func (ec *executionContext) marshalNFlowZone2magichelpergraphmodelFlowZone(ctx context.Context, sel ast.SelectionSet, v []*model.FlowZone) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNFlowZone2magichelpergraphmodelFlowZone(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNFlowZone2magichelpergraphmodelFlowZone(ctx context.Context, sel ast.SelectionSet, v *model.FlowZone) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._FlowZone(ctx, sel, v)
}

func (ec *executionContext) unmarshalNFlowZoneInput2magichelpergraphmodelFlowZoneInput(ctx context.Context, v any) ([]*model.FlowZoneInput, error) {
	var vSlice []any
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.FlowZoneInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNFlowZoneInput2magichelpergraphmodelFlowZoneInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNFlowZoneInput2magichelpergraphmodelFlowZoneInput(ctx context.Context, v any) (*model.FlowZoneInput, error) {
	res, err := ec.unmarshalInputFlowZoneInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNID2string(ctx context.Context, v any) (string, error) {
	res, err := graphql.UnmarshalID(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNID2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalID(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNID2string(ctx context.Context, v any) ([]string, error) {
	var vSlice []any
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNID2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNID2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNID2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v any) (int, error) {
	res, err := graphql.UnmarshalInt(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	res := graphql.MarshalInt(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNMTG_AddCardToCardPackageInput2magichelpergraphmodelMtgAddCardToCardPackageInput(ctx context.Context, v any) (model.MtgAddCardToCardPackageInput, error) {
	res, err := ec.unmarshalInputMTG_AddCardToCardPackageInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNMTG_Card2magichelpergraphmodelMtgCard(ctx context.Context, sel ast.SelectionSet, v []*model.MtgCard) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMTG_Card2magichelpergraphmodelMtgCard(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNMTG_Card2magichelpergraphmodelMtgCard(ctx context.Context, sel ast.SelectionSet, v *model.MtgCard) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._MTG_Card(ctx, sel, v)
}

func (ec *executionContext) marshalNMTG_CardFace2magichelpergraphmodelMtgCardFace(ctx context.Context, sel ast.SelectionSet, v *model.MtgCardFace) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._MTG_CardFace(ctx, sel, v)
}

func (ec *executionContext) marshalNMTG_CardFace_Dashboard2magichelpergraphmodelMtgCardFaceDashboard(ctx context.Context, sel ast.SelectionSet, v []*model.MtgCardFaceDashboard) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMTG_CardFace_Dashboard2magichelpergraphmodelMtgCardFaceDashboard(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNMTG_CardFace_Dashboard2magichelpergraphmodelMtgCardFaceDashboard(ctx context.Context, sel ast.SelectionSet, v *model.MtgCardFaceDashboard) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._MTG_CardFace_Dashboard(ctx, sel, v)
}

func (ec *executionContext) marshalNMTG_CardPackage2magichelpergraphmodelMtgCardPackage(ctx context.Context, sel ast.SelectionSet, v []*model.MtgCardPackage) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMTG_CardPackage2magichelpergraphmodelMtgCardPackage(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNMTG_CardPackage2magichelpergraphmodelMtgCardPackage(ctx context.Context, sel ast.SelectionSet, v *model.MtgCardPackage) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._MTG_CardPackage(ctx, sel, v)
}

func (ec *executionContext) marshalNMTG_CardPackageCard2magichelpergraphmodelMtgCardPackageCard(ctx context.Context, sel ast.SelectionSet, v []*model.MtgCardPackageCard) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMTG_CardPackageCard2magichelpergraphmodelMtgCardPackageCard(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNMTG_CardPackageCard2magichelpergraphmodelMtgCardPackageCard(ctx context.Context, sel ast.SelectionSet, v *model.MtgCardPackageCard) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._MTG_CardPackageCard(ctx, sel, v)
}

func (ec *executionContext) marshalNMTG_CardVersion2magichelpergraphmodelMtgCardVersion(ctx context.Context, sel ast.SelectionSet, v []*model.MtgCardVersion) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMTG_CardVersion2magichelpergraphmodelMtgCardVersion(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNMTG_CardVersion2magichelpergraphmodelMtgCardVersion(ctx context.Context, sel ast.SelectionSet, v *model.MtgCardVersion) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._MTG_CardVersion(ctx, sel, v)
}

func (ec *executionContext) marshalNMTG_CardVersion_Dashboard2magichelpergraphmodelMtgCardVersionDashboard(ctx context.Context, sel ast.SelectionSet, v []*model.MtgCardVersionDashboard) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMTG_CardVersion_Dashboard2magichelpergraphmodelMtgCardVersionDashboard(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNMTG_CardVersion_Dashboard2magichelpergraphmodelMtgCardVersionDashboard(ctx context.Context, sel ast.SelectionSet, v *model.MtgCardVersionDashboard) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._MTG_CardVersion_Dashboard(ctx, sel, v)
}

func (ec *executionContext) marshalNMTG_Card_Dashboard2magichelpergraphmodelMtgCardDashboard(ctx context.Context, sel ast.SelectionSet, v *model.MtgCardDashboard) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._MTG_Card_Dashboard(ctx, sel, v)
}

func (ec *executionContext) unmarshalNMTG_Color2magichelpergraphmodelMtgColor(ctx context.Context, v any) (model.MtgColor, error) {
	var res model.MtgColor
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNMTG_Color2magichelpergraphmodelMtgColor(ctx context.Context, sel ast.SelectionSet, v model.MtgColor) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNMTG_Color2magichelpergraphmodelMtgColor(ctx context.Context, v any) ([]model.MtgColor, error) {
	var vSlice []any
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]model.MtgColor, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNMTG_Color2magichelpergraphmodelMtgColor(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNMTG_Color2magichelpergraphmodelMtgColor(ctx context.Context, sel ast.SelectionSet, v []model.MtgColor) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMTG_Color2magichelpergraphmodelMtgColor(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNMTG_CreateCardPackageInput2magichelpergraphmodelMtgCreateCardPackageInput(ctx context.Context, v any) (model.MtgCreateCardPackageInput, error) {
	res, err := ec.unmarshalInputMTG_CreateCardPackageInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNMTG_CreateDeckInput2magichelpergraphmodelMtgCreateDeckInput(ctx context.Context, v any) (model.MtgCreateDeckInput, error) {
	res, err := ec.unmarshalInputMTG_CreateDeckInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNMTG_Deck2magichelpergraphmodelMtgDeck(ctx context.Context, sel ast.SelectionSet, v model.MtgDeck) graphql.Marshaler {
	return ec._MTG_Deck(ctx, sel, &v)
}

func (ec *executionContext) marshalNMTG_Deck2magichelpergraphmodelMtgDeck(ctx context.Context, sel ast.SelectionSet, v *model.MtgDeck) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._MTG_Deck(ctx, sel, v)
}

func (ec *executionContext) marshalNMTG_DeckCard2magichelpergraphmodelMtgDeckCard(ctx context.Context, sel ast.SelectionSet, v []*model.MtgDeckCard) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMTG_DeckCard2magichelpergraphmodelMtgDeckCard(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNMTG_DeckCard2magichelpergraphmodelMtgDeckCard(ctx context.Context, sel ast.SelectionSet, v *model.MtgDeckCard) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._MTG_DeckCard(ctx, sel, v)
}

func (ec *executionContext) unmarshalNMTG_DeckCardInput2magichelpergraphmodelMtgDeckCardInput(ctx context.Context, v any) ([]*model.MtgDeckCardInput, error) {
	var vSlice []any
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.MtgDeckCardInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNMTG_DeckCardInput2magichelpergraphmodelMtgDeckCardInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNMTG_DeckCardInput2magichelpergraphmodelMtgDeckCardInput(ctx context.Context, v any) (*model.MtgDeckCardInput, error) {
	res, err := ec.unmarshalInputMTG_DeckCardInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNMTG_DeckCardType2magichelpergraphmodelMtgDeckCardType(ctx context.Context, v any) (model.MtgDeckCardType, error) {
	var res model.MtgDeckCardType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNMTG_DeckCardType2magichelpergraphmodelMtgDeckCardType(ctx context.Context, sel ast.SelectionSet, v model.MtgDeckCardType) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNMTG_DeckCard_Dashboard2magichelpergraphmodelMtgDeckCardDashboard(ctx context.Context, sel ast.SelectionSet, v []*model.MtgDeckCardDashboard) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMTG_DeckCard_Dashboard2magichelpergraphmodelMtgDeckCardDashboard(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNMTG_DeckCard_Dashboard2magichelpergraphmodelMtgDeckCardDashboard(ctx context.Context, sel ast.SelectionSet, v *model.MtgDeckCardDashboard) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._MTG_DeckCard_Dashboard(ctx, sel, v)
}

func (ec *executionContext) marshalNMTG_DeckDashboard2magichelpergraphmodelMtgDeckDashboard(ctx context.Context, sel ast.SelectionSet, v []*model.MtgDeckDashboard) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMTG_DeckDashboard2magichelpergraphmodelMtgDeckDashboard(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNMTG_DeckDashboard2magichelpergraphmodelMtgDeckDashboard(ctx context.Context, sel ast.SelectionSet, v *model.MtgDeckDashboard) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._MTG_DeckDashboard(ctx, sel, v)
}

func (ec *executionContext) unmarshalNMTG_DeleteCardPackageInput2magichelpergraphmodelMtgDeleteCardPackageInput(ctx context.Context, v any) (model.MtgDeleteCardPackageInput, error) {
	res, err := ec.unmarshalInputMTG_DeleteCardPackageInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNMTG_DeleteDeckInput2magichelpergraphmodelMtgDeleteDeckInput(ctx context.Context, v any) (model.MtgDeleteDeckInput, error) {
	res, err := ec.unmarshalInputMTG_DeleteDeckInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNMTG_EditCardPackageNameInput2magichelpergraphmodelMtgEditCardPackageNameInput(ctx context.Context, v any) (model.MtgEditCardPackageNameInput, error) {
	res, err := ec.unmarshalInputMTG_EditCardPackageNameInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNMTG_EditCardPackageVisibilityInput2magichelpergraphmodelMtgEditCardPackageVisibilityInput(ctx context.Context, v any) (model.MtgEditCardPackageVisibilityInput, error) {
	res, err := ec.unmarshalInputMTG_EditCardPackageVisibilityInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNMTG_Filter_CardTypeInput2magichelpergraphmodelMtgFilterCardTypeInput(ctx context.Context, v any) ([]*model.MtgFilterCardTypeInput, error) {
	var vSlice []any
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.MtgFilterCardTypeInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNMTG_Filter_CardTypeInput2magichelpergraphmodelMtgFilterCardTypeInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNMTG_Filter_CardTypeInput2magichelpergraphmodelMtgFilterCardTypeInput(ctx context.Context, v any) (*model.MtgFilterCardTypeInput, error) {
	res, err := ec.unmarshalInputMTG_Filter_CardTypeInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNMTG_Filter_CardTypes2magichelpergraphmodelMtgFilterCardTypes(ctx context.Context, sel ast.SelectionSet, v []*model.MtgFilterCardTypes) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMTG_Filter_CardTypes2magichelpergraphmodelMtgFilterCardTypes(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNMTG_Filter_CardTypes2magichelpergraphmodelMtgFilterCardTypes(ctx context.Context, sel ast.SelectionSet, v *model.MtgFilterCardTypes) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._MTG_Filter_CardTypes(ctx, sel, v)
}

func (ec *executionContext) unmarshalNMTG_Filter_ColorInput2magichelpergraphmodelMtgFilterColorInput(ctx context.Context, v any) ([]*model.MtgFilterColorInput, error) {
	var vSlice []any
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.MtgFilterColorInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNMTG_Filter_ColorInput2magichelpergraphmodelMtgFilterColorInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNMTG_Filter_ColorInput2magichelpergraphmodelMtgFilterColorInput(ctx context.Context, v any) (*model.MtgFilterColorInput, error) {
	res, err := ec.unmarshalInputMTG_Filter_ColorInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNMTG_Filter_Entries2magichelpergraphmodelMtgFilterEntries(ctx context.Context, sel ast.SelectionSet, v model.MtgFilterEntries) graphql.Marshaler {
	return ec._MTG_Filter_Entries(ctx, sel, &v)
}

func (ec *executionContext) marshalNMTG_Filter_Entries2magichelpergraphmodelMtgFilterEntries(ctx context.Context, sel ast.SelectionSet, v *model.MtgFilterEntries) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._MTG_Filter_Entries(ctx, sel, v)
}

func (ec *executionContext) marshalNMTG_Filter_Expansion2magichelpergraphmodelMtgFilterExpansion(ctx context.Context, sel ast.SelectionSet, v []*model.MtgFilterExpansion) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMTG_Filter_Expansion2magichelpergraphmodelMtgFilterExpansion(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNMTG_Filter_Expansion2magichelpergraphmodelMtgFilterExpansion(ctx context.Context, sel ast.SelectionSet, v *model.MtgFilterExpansion) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._MTG_Filter_Expansion(ctx, sel, v)
}

func (ec *executionContext) unmarshalNMTG_Filter_GameInput2magichelpergraphmodelMtgFilterGameInput(ctx context.Context, v any) ([]*model.MtgFilterGameInput, error) {
	var vSlice []any
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.MtgFilterGameInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNMTG_Filter_GameInput2magichelpergraphmodelMtgFilterGameInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNMTG_Filter_GameInput2magichelpergraphmodelMtgFilterGameInput(ctx context.Context, v any) (*model.MtgFilterGameInput, error) {
	res, err := ec.unmarshalInputMTG_Filter_GameInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNMTG_Filter_LayoutInput2magichelpergraphmodelMtgFilterLayoutInput(ctx context.Context, v any) ([]*model.MtgFilterLayoutInput, error) {
	var vSlice []any
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.MtgFilterLayoutInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNMTG_Filter_LayoutInput2magichelpergraphmodelMtgFilterLayoutInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNMTG_Filter_LayoutInput2magichelpergraphmodelMtgFilterLayoutInput(ctx context.Context, v any) (*model.MtgFilterLayoutInput, error) {
	res, err := ec.unmarshalInputMTG_Filter_LayoutInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNMTG_Filter_Legality2magichelpergraphmodelMtgFilterLegality(ctx context.Context, sel ast.SelectionSet, v *model.MtgFilterLegality) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._MTG_Filter_Legality(ctx, sel, v)
}

func (ec *executionContext) unmarshalNMTG_Filter_LegalityEntryInput2magichelpergraphmodelMtgFilterLegalityEntryInput(ctx context.Context, v any) ([]*model.MtgFilterLegalityEntryInput, error) {
	var vSlice []any
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.MtgFilterLegalityEntryInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNMTG_Filter_LegalityEntryInput2magichelpergraphmodelMtgFilterLegalityEntryInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNMTG_Filter_LegalityEntryInput2magichelpergraphmodelMtgFilterLegalityEntryInput(ctx context.Context, v any) (*model.MtgFilterLegalityEntryInput, error) {
	res, err := ec.unmarshalInputMTG_Filter_LegalityEntryInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNMTG_Filter_LegalityInput2magichelpergraphmodelMtgFilterLegalityInput(ctx context.Context, v any) ([]*model.MtgFilterLegalityInput, error) {
	var vSlice []any
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.MtgFilterLegalityInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNMTG_Filter_LegalityInput2magichelpergraphmodelMtgFilterLegalityInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNMTG_Filter_LegalityInput2magichelpergraphmodelMtgFilterLegalityInput(ctx context.Context, v any) (*model.MtgFilterLegalityInput, error) {
	res, err := ec.unmarshalInputMTG_Filter_LegalityInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNMTG_Filter_ManaCostInput2magichelpergraphmodelMtgFilterManaCostInput(ctx context.Context, v any) ([]*model.MtgFilterManaCostInput, error) {
	var vSlice []any
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.MtgFilterManaCostInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNMTG_Filter_ManaCostInput2magichelpergraphmodelMtgFilterManaCostInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNMTG_Filter_ManaCostInput2magichelpergraphmodelMtgFilterManaCostInput(ctx context.Context, v any) (*model.MtgFilterManaCostInput, error) {
	res, err := ec.unmarshalInputMTG_Filter_ManaCostInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNMTG_Filter_PaginationInput2magichelpergraphmodelMtgFilterPaginationInput(ctx context.Context, v any) (model.MtgFilterPaginationInput, error) {
	res, err := ec.unmarshalInputMTG_Filter_PaginationInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNMTG_Filter_RarityInput2magichelpergraphmodelMtgFilterRarityInput(ctx context.Context, v any) ([]*model.MtgFilterRarityInput, error) {
	var vSlice []any
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.MtgFilterRarityInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNMTG_Filter_RarityInput2magichelpergraphmodelMtgFilterRarityInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNMTG_Filter_RarityInput2magichelpergraphmodelMtgFilterRarityInput(ctx context.Context, v any) (*model.MtgFilterRarityInput, error) {
	res, err := ec.unmarshalInputMTG_Filter_RarityInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNMTG_Filter_RatingInput2magichelpergraphmodelMtgFilterRatingInput(ctx context.Context, v any) (*model.MtgFilterRatingInput, error) {
	res, err := ec.unmarshalInputMTG_Filter_RatingInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNMTG_Filter_Search2magichelpergraphmodelMtgFilterSearch(ctx context.Context, sel ast.SelectionSet, v model.MtgFilterSearch) graphql.Marshaler {
	return ec._MTG_Filter_Search(ctx, sel, &v)
}

func (ec *executionContext) marshalNMTG_Filter_Search2magichelpergraphmodelMtgFilterSearch(ctx context.Context, sel ast.SelectionSet, v *model.MtgFilterSearch) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._MTG_Filter_Search(ctx, sel, v)
}

func (ec *executionContext) unmarshalNMTG_Filter_SearchInput2magichelpergraphmodelMtgFilterSearchInput(ctx context.Context, v any) (model.MtgFilterSearchInput, error) {
	res, err := ec.unmarshalInputMTG_Filter_SearchInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNMTG_Filter_SetInput2magichelpergraphmodelMtgFilterSetInput(ctx context.Context, v any) ([]*model.MtgFilterSetInput, error) {
	var vSlice []any
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.MtgFilterSetInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNMTG_Filter_SetInput2magichelpergraphmodelMtgFilterSetInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNMTG_Filter_SetInput2magichelpergraphmodelMtgFilterSetInput(ctx context.Context, v any) (*model.MtgFilterSetInput, error) {
	res, err := ec.unmarshalInputMTG_Filter_SetInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNMTG_Filter_SortBy2magichelpergraphmodelMtgFilterSortBy(ctx context.Context, v any) (model.MtgFilterSortBy, error) {
	var res model.MtgFilterSortBy
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNMTG_Filter_SortBy2magichelpergraphmodelMtgFilterSortBy(ctx context.Context, sel ast.SelectionSet, v model.MtgFilterSortBy) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNMTG_Filter_SortDirection2magichelpergraphmodelMtgFilterSortDirection(ctx context.Context, v any) (model.MtgFilterSortDirection, error) {
	var res model.MtgFilterSortDirection
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNMTG_Filter_SortDirection2magichelpergraphmodelMtgFilterSortDirection(ctx context.Context, sel ast.SelectionSet, v model.MtgFilterSortDirection) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNMTG_Filter_SortInput2magichelpergraphmodelMtgFilterSortInput(ctx context.Context, v any) ([]*model.MtgFilterSortInput, error) {
	var vSlice []any
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.MtgFilterSortInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNMTG_Filter_SortInput2magichelpergraphmodelMtgFilterSortInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNMTG_Filter_SortInput2magichelpergraphmodelMtgFilterSortInput(ctx context.Context, v any) (*model.MtgFilterSortInput, error) {
	res, err := ec.unmarshalInputMTG_Filter_SortInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNMTG_Filter_SubtypeInput2magichelpergraphmodelMtgFilterSubtypeInput(ctx context.Context, v any) ([]*model.MtgFilterSubtypeInput, error) {
	var vSlice []any
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.MtgFilterSubtypeInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNMTG_Filter_SubtypeInput2magichelpergraphmodelMtgFilterSubtypeInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNMTG_Filter_SubtypeInput2magichelpergraphmodelMtgFilterSubtypeInput(ctx context.Context, v any) (*model.MtgFilterSubtypeInput, error) {
	res, err := ec.unmarshalInputMTG_Filter_SubtypeInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNMTG_Filter_TagInput2magichelpergraphmodelMtgFilterTagInput(ctx context.Context, v any) ([]*model.MtgFilterTagInput, error) {
	var vSlice []any
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.MtgFilterTagInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNMTG_Filter_TagInput2magichelpergraphmodelMtgFilterTagInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNMTG_Filter_TagInput2magichelpergraphmodelMtgFilterTagInput(ctx context.Context, v any) (*model.MtgFilterTagInput, error) {
	res, err := ec.unmarshalInputMTG_Filter_TagInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNMTG_Game2magichelpergraphmodelMtgGame(ctx context.Context, v any) (model.MtgGame, error) {
	var res model.MtgGame
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNMTG_Game2magichelpergraphmodelMtgGame(ctx context.Context, sel ast.SelectionSet, v model.MtgGame) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNMTG_Game2magichelpergraphmodelMtgGame(ctx context.Context, v any) ([]model.MtgGame, error) {
	var vSlice []any
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]model.MtgGame, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNMTG_Game2magichelpergraphmodelMtgGame(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNMTG_Game2magichelpergraphmodelMtgGame(ctx context.Context, sel ast.SelectionSet, v []model.MtgGame) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMTG_Game2magichelpergraphmodelMtgGame(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNMTG_Layout2magichelpergraphmodelMtgLayout(ctx context.Context, v any) (model.MtgLayout, error) {
	var res model.MtgLayout
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNMTG_Layout2magichelpergraphmodelMtgLayout(ctx context.Context, sel ast.SelectionSet, v model.MtgLayout) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNMTG_Layout2magichelpergraphmodelMtgLayout(ctx context.Context, v any) ([]model.MtgLayout, error) {
	var vSlice []any
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]model.MtgLayout, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNMTG_Layout2magichelpergraphmodelMtgLayout(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNMTG_Layout2magichelpergraphmodelMtgLayout(ctx context.Context, sel ast.SelectionSet, v []model.MtgLayout) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMTG_Layout2magichelpergraphmodelMtgLayout(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNMTG_Rarity2magichelpergraphmodelMtgRarity(ctx context.Context, v any) (model.MtgRarity, error) {
	var res model.MtgRarity
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNMTG_Rarity2magichelpergraphmodelMtgRarity(ctx context.Context, sel ast.SelectionSet, v model.MtgRarity) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNMTG_RemoveCardFromCardPackageInput2magichelpergraphmodelMtgRemoveCardFromCardPackageInput(ctx context.Context, v any) (model.MtgRemoveCardFromCardPackageInput, error) {
	res, err := ec.unmarshalInputMTG_RemoveCardFromCardPackageInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNMTG_UpdateDeckInput2magichelpergraphmodelMtgUpdateDeckInput(ctx context.Context, v any) (model.MtgUpdateDeckInput, error) {
	res, err := ec.unmarshalInputMTG_UpdateDeckInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNMainOrSide2magichelpergraphmodelMainOrSide(ctx context.Context, v any) (model.MainOrSide, error) {
	var res model.MainOrSide
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNMainOrSide2magichelpergraphmodelMainOrSide(ctx context.Context, sel ast.SelectionSet, v model.MainOrSide) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNMap2map(ctx context.Context, v any) (map[string]any, error) {
	res, err := graphql.UnmarshalMap(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNMap2map(ctx context.Context, sel ast.SelectionSet, v map[string]any) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	res := graphql.MarshalMap(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNPhantom2magichelpergraphmodelPhantom(ctx context.Context, sel ast.SelectionSet, v []*model.Phantom) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPhantom2magichelpergraphmodelPhantom(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNPhantom2magichelpergraphmodelPhantom(ctx context.Context, sel ast.SelectionSet, v *model.Phantom) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Phantom(ctx, sel, v)
}

func (ec *executionContext) unmarshalNPhantomInput2magichelpergraphmodelPhantomInput(ctx context.Context, v any) ([]*model.PhantomInput, error) {
	var vSlice []any
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.PhantomInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNPhantomInput2magichelpergraphmodelPhantomInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNPhantomInput2magichelpergraphmodelPhantomInput(ctx context.Context, v any) (*model.PhantomInput, error) {
	res, err := ec.unmarshalInputPhantomInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNPosition2magichelpergraphmodelPosition(ctx context.Context, sel ast.SelectionSet, v *model.Position) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Position(ctx, sel, v)
}

func (ec *executionContext) unmarshalNPositionInput2magichelpergraphmodelPositionInput(ctx context.Context, v any) (*model.PositionInput, error) {
	res, err := ec.unmarshalInputPositionInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNRatableEntityType2magichelpergraphmodelRatableEntityType(ctx context.Context, v any) (model.RatableEntityType, error) {
	var res model.RatableEntityType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNRatableEntityType2magichelpergraphmodelRatableEntityType(ctx context.Context, sel ast.SelectionSet, v model.RatableEntityType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNRateInput2magichelpergraphmodelRateInput(ctx context.Context, v any) (model.RateInput, error) {
	res, err := ec.unmarshalInputRateInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNRemoveIgnoredCardInput2magichelpergraphmodelRemoveIgnoredCardInput(ctx context.Context, v any) (model.RemoveIgnoredCardInput, error) {
	res, err := ec.unmarshalInputRemoveIgnoredCardInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNResponse2magichelpergraphmodelResponse(ctx context.Context, sel ast.SelectionSet, v model.Response) graphql.Marshaler {
	return ec._Response(ctx, sel, &v)
}

func (ec *executionContext) marshalNResponse2magichelpergraphmodelResponse(ctx context.Context, sel ast.SelectionSet, v *model.Response) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Response(ctx, sel, v)
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v any) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v any) ([]string, error) {
	var vSlice []any
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNTag2magichelpergraphmodelTag(ctx context.Context, sel ast.SelectionSet, v model.Tag) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Tag(ctx, sel, v)
}

func (ec *executionContext) marshalNTag2magichelpergraphmodelTag(ctx context.Context, sel ast.SelectionSet, v []model.Tag) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTag2magichelpergraphmodelTag(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNTagType2magichelpergraphmodelTagType(ctx context.Context, v any) (model.TagType, error) {
	var res model.TagType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTagType2magichelpergraphmodelTagType(ctx context.Context, sel ast.SelectionSet, v model.TagType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNTernaryBoolean2magichelpergraphmodelTernaryBoolean(ctx context.Context, v any) (model.TernaryBoolean, error) {
	var res model.TernaryBoolean
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTernaryBoolean2magichelpergraphmodelTernaryBoolean(ctx context.Context, sel ast.SelectionSet, v model.TernaryBoolean) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNUnassignTagInput2magichelpergraphmodelUnassignTagInput(ctx context.Context, v any) (model.UnassignTagInput, error) {
	res, err := ec.unmarshalInputUnassignTagInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateTagInput2magichelpergraphmodelUpdateTagInput(ctx context.Context, v any) (model.UpdateTagInput, error) {
	res, err := ec.unmarshalInputUpdateTagInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUser2magichelpergraphmodelUser(ctx context.Context, sel ast.SelectionSet, v *model.User) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._User(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUserRole2magichelpergraphmodelUserRole(ctx context.Context, v any) (model.UserRole, error) {
	var res model.UserRole
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUserRole2magichelpergraphmodelUserRole(ctx context.Context, sel ast.SelectionSet, v model.UserRole) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNUserRole2magichelpergraphmodelUserRole(ctx context.Context, v any) ([]model.UserRole, error) {
	var vSlice []any
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]model.UserRole, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNUserRole2magichelpergraphmodelUserRole(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNUserRole2magichelpergraphmodelUserRole(ctx context.Context, sel ast.SelectionSet, v []model.UserRole) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNUserRole2magichelpergraphmodelUserRole(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v any) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v any) ([]string, error) {
	var vSlice []any
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v any) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalOAdminImportReport2magichelpergraphmodelAdminImportReport(ctx context.Context, sel ast.SelectionSet, v *model.AdminImportReport) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._AdminImportReport(ctx, sel, v)
}

func (ec *executionContext) marshalOAdminLegalitiesDiff2magichelpergraphmodelAdminLegalitiesDiff(ctx context.Context, sel ast.SelectionSet, v *model.AdminLegalitiesDiff) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._AdminLegalitiesDiff(ctx, sel, v)
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v any) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	return res
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v any) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalBoolean(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalBoolean(*v)
	return res
}

func (ec *executionContext) unmarshalOFloat2float64(ctx context.Context, v any) (*float64, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalFloatContext(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOFloat2float64(ctx context.Context, sel ast.SelectionSet, v *float64) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalFloatContext(*v)
	return graphql.WrapContextMarshaler(ctx, res)
}

func (ec *executionContext) unmarshalOID2string(ctx context.Context, v any) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalID(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOID2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalID(*v)
	return res
}

func (ec *executionContext) unmarshalOInt2int(ctx context.Context, v any) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalInt(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2int(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalInt(*v)
	return res
}

func (ec *executionContext) marshalOMTG_CardFace2magichelpergraphmodelMtgCardFace(ctx context.Context, sel ast.SelectionSet, v []*model.MtgCardFace) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMTG_CardFace2magichelpergraphmodelMtgCardFace(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOMTG_Color2magichelpergraphmodelMtgColor(ctx context.Context, v any) ([]model.MtgColor, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]model.MtgColor, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNMTG_Color2magichelpergraphmodelMtgColor(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOMTG_Color2magichelpergraphmodelMtgColor(ctx context.Context, sel ast.SelectionSet, v []model.MtgColor) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMTG_Color2magichelpergraphmodelMtgColor(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOMTG_DeckCardFrontImageInput2magichelpergraphmodelMtgDeckCardFrontImageInput(ctx context.Context, v any) (*model.MtgDeckCardFrontImageInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputMTG_DeckCardFrontImageInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOMTG_Deck_CardFrontImage2magichelpergraphmodelMtgDeckCardFrontImage(ctx context.Context, sel ast.SelectionSet, v *model.MtgDeckCardFrontImage) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._MTG_Deck_CardFrontImage(ctx, sel, v)
}

func (ec *executionContext) marshalOMTG_Image2magichelpergraphmodelMtgImage(ctx context.Context, sel ast.SelectionSet, v *model.MtgImage) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._MTG_Image(ctx, sel, v)
}

func (ec *executionContext) unmarshalOMTG_Layout2magichelpergraphmodelMtgLayout(ctx context.Context, v any) (*model.MtgLayout, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.MtgLayout)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOMTG_Layout2magichelpergraphmodelMtgLayout(ctx context.Context, sel ast.SelectionSet, v *model.MtgLayout) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOMap2map(ctx context.Context, v any) (map[string]any, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalMap(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOMap2map(ctx context.Context, sel ast.SelectionSet, v map[string]any) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalMap(v)
	return res
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v any) ([]string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v any) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalString(*v)
	return res
}

func (ec *executionContext) marshalOTag2magichelpergraphmodelTag(ctx context.Context, sel ast.SelectionSet, v model.Tag) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Tag(ctx, sel, v)
}

func (ec *executionContext) marshalOUserRating2magichelpergraphmodelUserRating(ctx context.Context, sel ast.SelectionSet, v *model.UserRating) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._UserRating(ctx, sel, v)
}

func (ec *executionContext) marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************
