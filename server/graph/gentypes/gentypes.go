// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package gentypes

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"magic-helper/graph/model"
	"strconv"
	"sync"
	"sync/atomic"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Mutation() MutationResolver
	Query() QueryResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	CardTag struct {
		Description func(childComplexity int) int
		ID          func(childComplexity int) int
		MyRating    func(childComplexity int) int
		Name        func(childComplexity int) int
	}

	DeckTag struct {
		Colors      func(childComplexity int) int
		Description func(childComplexity int) int
		ID          func(childComplexity int) int
		MyRating    func(childComplexity int) int
		Name        func(childComplexity int) int
	}

	FlowZone struct {
		CardChildren func(childComplexity int) int
		Height       func(childComplexity int) int
		ID           func(childComplexity int) int
		Name         func(childComplexity int) int
		Position     func(childComplexity int) int
		Width        func(childComplexity int) int
		ZoneChildren func(childComplexity int) int
	}

	MTG_Card struct {
		CardTags       func(childComplexity int) int
		Cmc            func(childComplexity int) int
		ColorIdentity  func(childComplexity int) int
		ColorIndicator func(childComplexity int) int
		Colors         func(childComplexity int) int
		DeckTags       func(childComplexity int) int
		EDHRecRank     func(childComplexity int) int
		ID             func(childComplexity int) int
		Keywords       func(childComplexity int) int
		Layout         func(childComplexity int) int
		Loyalty        func(childComplexity int) int
		ManaCost       func(childComplexity int) int
		MyRating       func(childComplexity int) int
		Name           func(childComplexity int) int
		OracleText     func(childComplexity int) int
		Power          func(childComplexity int) int
		ProducedMana   func(childComplexity int) int
		Toughness      func(childComplexity int) int
		TypeLine       func(childComplexity int) int
		Versions       func(childComplexity int) int
	}

	MTG_CardFace struct {
		Artist         func(childComplexity int) int
		Cmc            func(childComplexity int) int
		ColorIndicator func(childComplexity int) int
		Colors         func(childComplexity int) int
		FlavorText     func(childComplexity int) int
		ImageUris      func(childComplexity int) int
		Layout         func(childComplexity int) int
		Loyalty        func(childComplexity int) int
		ManaCost       func(childComplexity int) int
		Name           func(childComplexity int) int
		OracleText     func(childComplexity int) int
		Power          func(childComplexity int) int
		Toughness      func(childComplexity int) int
		TypeLine       func(childComplexity int) int
	}

	MTG_CardFace_Dashboard struct {
		ImageUris func(childComplexity int) int
	}

	MTG_CardPackage struct {
		Cards func(childComplexity int) int
		ID    func(childComplexity int) int
		Name  func(childComplexity int) int
	}

	MTG_CardPackageCard struct {
		Card              func(childComplexity int) int
		Count             func(childComplexity int) int
		MainOrSide        func(childComplexity int) int
		SelectedVersionID func(childComplexity int) int
	}

	MTG_CardVersion struct {
		Artist      func(childComplexity int) int
		CardFaces   func(childComplexity int) int
		FlavorName  func(childComplexity int) int
		FlavorText  func(childComplexity int) int
		Games       func(childComplexity int) int
		ID          func(childComplexity int) int
		ImageUris   func(childComplexity int) int
		IsAlchemy   func(childComplexity int) int
		IsDefault   func(childComplexity int) int
		Lang        func(childComplexity int) int
		Legalities  func(childComplexity int) int
		Rarity      func(childComplexity int) int
		ReleasedAt  func(childComplexity int) int
		Reprint     func(childComplexity int) int
		Set         func(childComplexity int) int
		SetID       func(childComplexity int) int
		SetName     func(childComplexity int) int
		SetType     func(childComplexity int) int
		Variation   func(childComplexity int) int
		VariationOf func(childComplexity int) int
	}

	MTG_CardVersion_Dashboard struct {
		CardFaces func(childComplexity int) int
		ID        func(childComplexity int) int
		ImageUris func(childComplexity int) int
		IsAlchemy func(childComplexity int) int
		IsDefault func(childComplexity int) int
	}

	MTG_Card_Dashboard struct {
		ID       func(childComplexity int) int
		Versions func(childComplexity int) int
	}

	MTG_Deck struct {
		CardFrontImage func(childComplexity int) int
		Cards          func(childComplexity int) int
		ID             func(childComplexity int) int
		IgnoredCards   func(childComplexity int) int
		Name           func(childComplexity int) int
		Zones          func(childComplexity int) int
	}

	MTG_DeckCard struct {
		Card              func(childComplexity int) int
		Count             func(childComplexity int) int
		DeckCardType      func(childComplexity int) int
		MainOrSide        func(childComplexity int) int
		Phantoms          func(childComplexity int) int
		Position          func(childComplexity int) int
		SelectedVersionID func(childComplexity int) int
	}

	MTG_DeckCard_Dashboard struct {
		Card              func(childComplexity int) int
		SelectedVersionID func(childComplexity int) int
	}

	MTG_DeckDashboard struct {
		CardFrontImage func(childComplexity int) int
		Cards          func(childComplexity int) int
		ID             func(childComplexity int) int
		Name           func(childComplexity int) int
	}

	MTG_Deck_CardFrontImage struct {
		CardID    func(childComplexity int) int
		Image     func(childComplexity int) int
		VersionID func(childComplexity int) int
	}

	MTG_Filter_CardTypes struct {
		CardType func(childComplexity int) int
		Subtypes func(childComplexity int) int
	}

	MTG_Filter_Entries struct {
		Expansions func(childComplexity int) int
		Layouts    func(childComplexity int) int
		Legality   func(childComplexity int) int
		Types      func(childComplexity int) int
	}

	MTG_Filter_Expansion struct {
		Games      func(childComplexity int) int
		ImageURL   func(childComplexity int) int
		ReleasedAt func(childComplexity int) int
		Set        func(childComplexity int) int
		SetName    func(childComplexity int) int
		SetType    func(childComplexity int) int
	}

	MTG_Filter_Legality struct {
		Formats        func(childComplexity int) int
		LegalityValues func(childComplexity int) int
	}

	MTG_Filter_Search struct {
		PagedCards func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	MTG_Image struct {
		ArtCrop    func(childComplexity int) int
		BorderCrop func(childComplexity int) int
		Large      func(childComplexity int) int
		Normal     func(childComplexity int) int
		Png        func(childComplexity int) int
		Small      func(childComplexity int) int
	}

	Mutation struct {
		AddIgnoredCard               func(childComplexity int, input model.AddIgnoredCardInput) int
		AddMTGCardToCardPackage      func(childComplexity int, input model.MtgAddCardToCardPackageInput) int
		AssignTag                    func(childComplexity int, input model.AssignTagInput) int
		CreateMTGCardPackage         func(childComplexity int, input model.MtgCreateCardPackageInput) int
		CreateMTGDeck                func(childComplexity int, input model.MtgCreateDeckInput) int
		CreateTag                    func(childComplexity int, input model.CreateTagInput) int
		DeleteMTGCardPackage         func(childComplexity int, input model.MtgDeleteCardPackageInput) int
		DeleteMTGDeck                func(childComplexity int, input model.MtgDeleteDeckInput) int
		DeleteTag                    func(childComplexity int, tagID string) int
		Rate                         func(childComplexity int, input model.RateInput) int
		RemoveIgnoredCard            func(childComplexity int, input model.RemoveIgnoredCardInput) int
		RemoveMTGCardFromCardPackage func(childComplexity int, input model.MtgRemoveCardFromCardPackageInput) int
		SaveMTGDeckAsCopy            func(childComplexity int, input model.MtgUpdateDeckInput) int
		UnassignTag                  func(childComplexity int, input model.UnassignTagInput) int
		UpdateMTGDeck                func(childComplexity int, input model.MtgUpdateDeckInput) int
		UpdateTag                    func(childComplexity int, input model.UpdateTagInput) int
	}

	Phantom struct {
		ID       func(childComplexity int) int
		Position func(childComplexity int) int
	}

	Position struct {
		X func(childComplexity int) int
		Y func(childComplexity int) int
	}

	Query struct {
		CardTags            func(childComplexity int) int
		DeckTags            func(childComplexity int) int
		GetMTGCardPackages  func(childComplexity int, cardPackageID *string) int
		GetMTGCards         func(childComplexity int) int
		GetMTGCardsFiltered func(childComplexity int, filter model.MtgFilterSearchInput, pagination model.MtgFilterPaginationInput, sort []*model.MtgFilterSortInput) int
		GetMTGDeck          func(childComplexity int, deckID string) int
		GetMTGDecks         func(childComplexity int) int
		GetMTGFilters       func(childComplexity int) int
		Tag                 func(childComplexity int, id string) int
		Tags                func(childComplexity int) int
	}

	Response struct {
		Message func(childComplexity int) int
		Status  func(childComplexity int) int
	}

	User struct {
		ID func(childComplexity int) int
	}

	UserRating struct {
		User  func(childComplexity int) int
		Value func(childComplexity int) int
	}
}

type MutationResolver interface {
	CreateMTGDeck(ctx context.Context, input model.MtgCreateDeckInput) (*model.Response, error)
	DeleteMTGDeck(ctx context.Context, input model.MtgDeleteDeckInput) (*model.Response, error)
	UpdateMTGDeck(ctx context.Context, input model.MtgUpdateDeckInput) (*model.Response, error)
	SaveMTGDeckAsCopy(ctx context.Context, input model.MtgUpdateDeckInput) (*model.Response, error)
	CreateMTGCardPackage(ctx context.Context, input model.MtgCreateCardPackageInput) (*model.Response, error)
	DeleteMTGCardPackage(ctx context.Context, input model.MtgDeleteCardPackageInput) (*model.Response, error)
	AddMTGCardToCardPackage(ctx context.Context, input model.MtgAddCardToCardPackageInput) (*model.Response, error)
	RemoveMTGCardFromCardPackage(ctx context.Context, input model.MtgRemoveCardFromCardPackageInput) (*model.Response, error)
	CreateTag(ctx context.Context, input model.CreateTagInput) (*model.Response, error)
	UpdateTag(ctx context.Context, input model.UpdateTagInput) (*model.Response, error)
	DeleteTag(ctx context.Context, tagID string) (*model.Response, error)
	AssignTag(ctx context.Context, input model.AssignTagInput) (*model.Response, error)
	UnassignTag(ctx context.Context, input model.UnassignTagInput) (*model.Response, error)
	Rate(ctx context.Context, input model.RateInput) (*model.Response, error)
	AddIgnoredCard(ctx context.Context, input model.AddIgnoredCardInput) (*model.Response, error)
	RemoveIgnoredCard(ctx context.Context, input model.RemoveIgnoredCardInput) (*model.Response, error)
}
type QueryResolver interface {
	GetMTGCards(ctx context.Context) ([]*model.MtgCard, error)
	GetMTGCardsFiltered(ctx context.Context, filter model.MtgFilterSearchInput, pagination model.MtgFilterPaginationInput, sort []*model.MtgFilterSortInput) (*model.MtgFilterSearch, error)
	GetMTGFilters(ctx context.Context) (*model.MtgFilterEntries, error)
	GetMTGDecks(ctx context.Context) ([]*model.MtgDeckDashboard, error)
	GetMTGDeck(ctx context.Context, deckID string) (*model.MtgDeck, error)
	GetMTGCardPackages(ctx context.Context, cardPackageID *string) ([]*model.MtgCardPackage, error)
	Tags(ctx context.Context) ([]model.Tag, error)
	CardTags(ctx context.Context) ([]*model.CardTag, error)
	DeckTags(ctx context.Context) ([]*model.DeckTag, error)
	Tag(ctx context.Context, id string) (model.Tag, error)
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]any) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "CardTag.description":
		if e.complexity.CardTag.Description == nil {
			break
		}

		return e.complexity.CardTag.Description(childComplexity), true

	case "CardTag.ID":
		if e.complexity.CardTag.ID == nil {
			break
		}

		return e.complexity.CardTag.ID(childComplexity), true

	case "CardTag.myRating":
		if e.complexity.CardTag.MyRating == nil {
			break
		}

		return e.complexity.CardTag.MyRating(childComplexity), true

	case "CardTag.name":
		if e.complexity.CardTag.Name == nil {
			break
		}

		return e.complexity.CardTag.Name(childComplexity), true

	case "DeckTag.colors":
		if e.complexity.DeckTag.Colors == nil {
			break
		}

		return e.complexity.DeckTag.Colors(childComplexity), true

	case "DeckTag.description":
		if e.complexity.DeckTag.Description == nil {
			break
		}

		return e.complexity.DeckTag.Description(childComplexity), true

	case "DeckTag.ID":
		if e.complexity.DeckTag.ID == nil {
			break
		}

		return e.complexity.DeckTag.ID(childComplexity), true

	case "DeckTag.myRating":
		if e.complexity.DeckTag.MyRating == nil {
			break
		}

		return e.complexity.DeckTag.MyRating(childComplexity), true

	case "DeckTag.name":
		if e.complexity.DeckTag.Name == nil {
			break
		}

		return e.complexity.DeckTag.Name(childComplexity), true

	case "FlowZone.cardChildren":
		if e.complexity.FlowZone.CardChildren == nil {
			break
		}

		return e.complexity.FlowZone.CardChildren(childComplexity), true

	case "FlowZone.height":
		if e.complexity.FlowZone.Height == nil {
			break
		}

		return e.complexity.FlowZone.Height(childComplexity), true

	case "FlowZone.ID":
		if e.complexity.FlowZone.ID == nil {
			break
		}

		return e.complexity.FlowZone.ID(childComplexity), true

	case "FlowZone.name":
		if e.complexity.FlowZone.Name == nil {
			break
		}

		return e.complexity.FlowZone.Name(childComplexity), true

	case "FlowZone.position":
		if e.complexity.FlowZone.Position == nil {
			break
		}

		return e.complexity.FlowZone.Position(childComplexity), true

	case "FlowZone.width":
		if e.complexity.FlowZone.Width == nil {
			break
		}

		return e.complexity.FlowZone.Width(childComplexity), true

	case "FlowZone.zoneChildren":
		if e.complexity.FlowZone.ZoneChildren == nil {
			break
		}

		return e.complexity.FlowZone.ZoneChildren(childComplexity), true

	case "MTG_Card.cardTags":
		if e.complexity.MTG_Card.CardTags == nil {
			break
		}

		return e.complexity.MTG_Card.CardTags(childComplexity), true

	case "MTG_Card.CMC":
		if e.complexity.MTG_Card.Cmc == nil {
			break
		}

		return e.complexity.MTG_Card.Cmc(childComplexity), true

	case "MTG_Card.colorIdentity":
		if e.complexity.MTG_Card.ColorIdentity == nil {
			break
		}

		return e.complexity.MTG_Card.ColorIdentity(childComplexity), true

	case "MTG_Card.colorIndicator":
		if e.complexity.MTG_Card.ColorIndicator == nil {
			break
		}

		return e.complexity.MTG_Card.ColorIndicator(childComplexity), true

	case "MTG_Card.colors":
		if e.complexity.MTG_Card.Colors == nil {
			break
		}

		return e.complexity.MTG_Card.Colors(childComplexity), true

	case "MTG_Card.deckTags":
		if e.complexity.MTG_Card.DeckTags == nil {
			break
		}

		return e.complexity.MTG_Card.DeckTags(childComplexity), true

	case "MTG_Card.EDHRecRank":
		if e.complexity.MTG_Card.EDHRecRank == nil {
			break
		}

		return e.complexity.MTG_Card.EDHRecRank(childComplexity), true

	case "MTG_Card.ID":
		if e.complexity.MTG_Card.ID == nil {
			break
		}

		return e.complexity.MTG_Card.ID(childComplexity), true

	case "MTG_Card.keywords":
		if e.complexity.MTG_Card.Keywords == nil {
			break
		}

		return e.complexity.MTG_Card.Keywords(childComplexity), true

	case "MTG_Card.layout":
		if e.complexity.MTG_Card.Layout == nil {
			break
		}

		return e.complexity.MTG_Card.Layout(childComplexity), true

	case "MTG_Card.loyalty":
		if e.complexity.MTG_Card.Loyalty == nil {
			break
		}

		return e.complexity.MTG_Card.Loyalty(childComplexity), true

	case "MTG_Card.manaCost":
		if e.complexity.MTG_Card.ManaCost == nil {
			break
		}

		return e.complexity.MTG_Card.ManaCost(childComplexity), true

	case "MTG_Card.myRating":
		if e.complexity.MTG_Card.MyRating == nil {
			break
		}

		return e.complexity.MTG_Card.MyRating(childComplexity), true

	case "MTG_Card.name":
		if e.complexity.MTG_Card.Name == nil {
			break
		}

		return e.complexity.MTG_Card.Name(childComplexity), true

	case "MTG_Card.oracleText":
		if e.complexity.MTG_Card.OracleText == nil {
			break
		}

		return e.complexity.MTG_Card.OracleText(childComplexity), true

	case "MTG_Card.power":
		if e.complexity.MTG_Card.Power == nil {
			break
		}

		return e.complexity.MTG_Card.Power(childComplexity), true

	case "MTG_Card.producedMana":
		if e.complexity.MTG_Card.ProducedMana == nil {
			break
		}

		return e.complexity.MTG_Card.ProducedMana(childComplexity), true

	case "MTG_Card.toughness":
		if e.complexity.MTG_Card.Toughness == nil {
			break
		}

		return e.complexity.MTG_Card.Toughness(childComplexity), true

	case "MTG_Card.typeLine":
		if e.complexity.MTG_Card.TypeLine == nil {
			break
		}

		return e.complexity.MTG_Card.TypeLine(childComplexity), true

	case "MTG_Card.versions":
		if e.complexity.MTG_Card.Versions == nil {
			break
		}

		return e.complexity.MTG_Card.Versions(childComplexity), true

	case "MTG_CardFace.artist":
		if e.complexity.MTG_CardFace.Artist == nil {
			break
		}

		return e.complexity.MTG_CardFace.Artist(childComplexity), true

	case "MTG_CardFace.CMC":
		if e.complexity.MTG_CardFace.Cmc == nil {
			break
		}

		return e.complexity.MTG_CardFace.Cmc(childComplexity), true

	case "MTG_CardFace.colorIndicator":
		if e.complexity.MTG_CardFace.ColorIndicator == nil {
			break
		}

		return e.complexity.MTG_CardFace.ColorIndicator(childComplexity), true

	case "MTG_CardFace.colors":
		if e.complexity.MTG_CardFace.Colors == nil {
			break
		}

		return e.complexity.MTG_CardFace.Colors(childComplexity), true

	case "MTG_CardFace.flavorText":
		if e.complexity.MTG_CardFace.FlavorText == nil {
			break
		}

		return e.complexity.MTG_CardFace.FlavorText(childComplexity), true

	case "MTG_CardFace.imageUris":
		if e.complexity.MTG_CardFace.ImageUris == nil {
			break
		}

		return e.complexity.MTG_CardFace.ImageUris(childComplexity), true

	case "MTG_CardFace.layout":
		if e.complexity.MTG_CardFace.Layout == nil {
			break
		}

		return e.complexity.MTG_CardFace.Layout(childComplexity), true

	case "MTG_CardFace.loyalty":
		if e.complexity.MTG_CardFace.Loyalty == nil {
			break
		}

		return e.complexity.MTG_CardFace.Loyalty(childComplexity), true

	case "MTG_CardFace.manaCost":
		if e.complexity.MTG_CardFace.ManaCost == nil {
			break
		}

		return e.complexity.MTG_CardFace.ManaCost(childComplexity), true

	case "MTG_CardFace.name":
		if e.complexity.MTG_CardFace.Name == nil {
			break
		}

		return e.complexity.MTG_CardFace.Name(childComplexity), true

	case "MTG_CardFace.oracleText":
		if e.complexity.MTG_CardFace.OracleText == nil {
			break
		}

		return e.complexity.MTG_CardFace.OracleText(childComplexity), true

	case "MTG_CardFace.power":
		if e.complexity.MTG_CardFace.Power == nil {
			break
		}

		return e.complexity.MTG_CardFace.Power(childComplexity), true

	case "MTG_CardFace.toughness":
		if e.complexity.MTG_CardFace.Toughness == nil {
			break
		}

		return e.complexity.MTG_CardFace.Toughness(childComplexity), true

	case "MTG_CardFace.typeLine":
		if e.complexity.MTG_CardFace.TypeLine == nil {
			break
		}

		return e.complexity.MTG_CardFace.TypeLine(childComplexity), true

	case "MTG_CardFace_Dashboard.imageUris":
		if e.complexity.MTG_CardFace_Dashboard.ImageUris == nil {
			break
		}

		return e.complexity.MTG_CardFace_Dashboard.ImageUris(childComplexity), true

	case "MTG_CardPackage.cards":
		if e.complexity.MTG_CardPackage.Cards == nil {
			break
		}

		return e.complexity.MTG_CardPackage.Cards(childComplexity), true

	case "MTG_CardPackage.ID":
		if e.complexity.MTG_CardPackage.ID == nil {
			break
		}

		return e.complexity.MTG_CardPackage.ID(childComplexity), true

	case "MTG_CardPackage.name":
		if e.complexity.MTG_CardPackage.Name == nil {
			break
		}

		return e.complexity.MTG_CardPackage.Name(childComplexity), true

	case "MTG_CardPackageCard.card":
		if e.complexity.MTG_CardPackageCard.Card == nil {
			break
		}

		return e.complexity.MTG_CardPackageCard.Card(childComplexity), true

	case "MTG_CardPackageCard.count":
		if e.complexity.MTG_CardPackageCard.Count == nil {
			break
		}

		return e.complexity.MTG_CardPackageCard.Count(childComplexity), true

	case "MTG_CardPackageCard.mainOrSide":
		if e.complexity.MTG_CardPackageCard.MainOrSide == nil {
			break
		}

		return e.complexity.MTG_CardPackageCard.MainOrSide(childComplexity), true

	case "MTG_CardPackageCard.selectedVersionID":
		if e.complexity.MTG_CardPackageCard.SelectedVersionID == nil {
			break
		}

		return e.complexity.MTG_CardPackageCard.SelectedVersionID(childComplexity), true

	case "MTG_CardVersion.artist":
		if e.complexity.MTG_CardVersion.Artist == nil {
			break
		}

		return e.complexity.MTG_CardVersion.Artist(childComplexity), true

	case "MTG_CardVersion.cardFaces":
		if e.complexity.MTG_CardVersion.CardFaces == nil {
			break
		}

		return e.complexity.MTG_CardVersion.CardFaces(childComplexity), true

	case "MTG_CardVersion.flavorName":
		if e.complexity.MTG_CardVersion.FlavorName == nil {
			break
		}

		return e.complexity.MTG_CardVersion.FlavorName(childComplexity), true

	case "MTG_CardVersion.flavorText":
		if e.complexity.MTG_CardVersion.FlavorText == nil {
			break
		}

		return e.complexity.MTG_CardVersion.FlavorText(childComplexity), true

	case "MTG_CardVersion.games":
		if e.complexity.MTG_CardVersion.Games == nil {
			break
		}

		return e.complexity.MTG_CardVersion.Games(childComplexity), true

	case "MTG_CardVersion.ID":
		if e.complexity.MTG_CardVersion.ID == nil {
			break
		}

		return e.complexity.MTG_CardVersion.ID(childComplexity), true

	case "MTG_CardVersion.imageUris":
		if e.complexity.MTG_CardVersion.ImageUris == nil {
			break
		}

		return e.complexity.MTG_CardVersion.ImageUris(childComplexity), true

	case "MTG_CardVersion.isAlchemy":
		if e.complexity.MTG_CardVersion.IsAlchemy == nil {
			break
		}

		return e.complexity.MTG_CardVersion.IsAlchemy(childComplexity), true

	case "MTG_CardVersion.isDefault":
		if e.complexity.MTG_CardVersion.IsDefault == nil {
			break
		}

		return e.complexity.MTG_CardVersion.IsDefault(childComplexity), true

	case "MTG_CardVersion.lang":
		if e.complexity.MTG_CardVersion.Lang == nil {
			break
		}

		return e.complexity.MTG_CardVersion.Lang(childComplexity), true

	case "MTG_CardVersion.legalities":
		if e.complexity.MTG_CardVersion.Legalities == nil {
			break
		}

		return e.complexity.MTG_CardVersion.Legalities(childComplexity), true

	case "MTG_CardVersion.rarity":
		if e.complexity.MTG_CardVersion.Rarity == nil {
			break
		}

		return e.complexity.MTG_CardVersion.Rarity(childComplexity), true

	case "MTG_CardVersion.releasedAt":
		if e.complexity.MTG_CardVersion.ReleasedAt == nil {
			break
		}

		return e.complexity.MTG_CardVersion.ReleasedAt(childComplexity), true

	case "MTG_CardVersion.reprint":
		if e.complexity.MTG_CardVersion.Reprint == nil {
			break
		}

		return e.complexity.MTG_CardVersion.Reprint(childComplexity), true

	case "MTG_CardVersion.set":
		if e.complexity.MTG_CardVersion.Set == nil {
			break
		}

		return e.complexity.MTG_CardVersion.Set(childComplexity), true

	case "MTG_CardVersion.setID":
		if e.complexity.MTG_CardVersion.SetID == nil {
			break
		}

		return e.complexity.MTG_CardVersion.SetID(childComplexity), true

	case "MTG_CardVersion.setName":
		if e.complexity.MTG_CardVersion.SetName == nil {
			break
		}

		return e.complexity.MTG_CardVersion.SetName(childComplexity), true

	case "MTG_CardVersion.setType":
		if e.complexity.MTG_CardVersion.SetType == nil {
			break
		}

		return e.complexity.MTG_CardVersion.SetType(childComplexity), true

	case "MTG_CardVersion.variation":
		if e.complexity.MTG_CardVersion.Variation == nil {
			break
		}

		return e.complexity.MTG_CardVersion.Variation(childComplexity), true

	case "MTG_CardVersion.variationOf":
		if e.complexity.MTG_CardVersion.VariationOf == nil {
			break
		}

		return e.complexity.MTG_CardVersion.VariationOf(childComplexity), true

	case "MTG_CardVersion_Dashboard.cardFaces":
		if e.complexity.MTG_CardVersion_Dashboard.CardFaces == nil {
			break
		}

		return e.complexity.MTG_CardVersion_Dashboard.CardFaces(childComplexity), true

	case "MTG_CardVersion_Dashboard.ID":
		if e.complexity.MTG_CardVersion_Dashboard.ID == nil {
			break
		}

		return e.complexity.MTG_CardVersion_Dashboard.ID(childComplexity), true

	case "MTG_CardVersion_Dashboard.imageUris":
		if e.complexity.MTG_CardVersion_Dashboard.ImageUris == nil {
			break
		}

		return e.complexity.MTG_CardVersion_Dashboard.ImageUris(childComplexity), true

	case "MTG_CardVersion_Dashboard.isAlchemy":
		if e.complexity.MTG_CardVersion_Dashboard.IsAlchemy == nil {
			break
		}

		return e.complexity.MTG_CardVersion_Dashboard.IsAlchemy(childComplexity), true

	case "MTG_CardVersion_Dashboard.isDefault":
		if e.complexity.MTG_CardVersion_Dashboard.IsDefault == nil {
			break
		}

		return e.complexity.MTG_CardVersion_Dashboard.IsDefault(childComplexity), true

	case "MTG_Card_Dashboard.ID":
		if e.complexity.MTG_Card_Dashboard.ID == nil {
			break
		}

		return e.complexity.MTG_Card_Dashboard.ID(childComplexity), true

	case "MTG_Card_Dashboard.versions":
		if e.complexity.MTG_Card_Dashboard.Versions == nil {
			break
		}

		return e.complexity.MTG_Card_Dashboard.Versions(childComplexity), true

	case "MTG_Deck.cardFrontImage":
		if e.complexity.MTG_Deck.CardFrontImage == nil {
			break
		}

		return e.complexity.MTG_Deck.CardFrontImage(childComplexity), true

	case "MTG_Deck.cards":
		if e.complexity.MTG_Deck.Cards == nil {
			break
		}

		return e.complexity.MTG_Deck.Cards(childComplexity), true

	case "MTG_Deck.ID":
		if e.complexity.MTG_Deck.ID == nil {
			break
		}

		return e.complexity.MTG_Deck.ID(childComplexity), true

	case "MTG_Deck.ignoredCards":
		if e.complexity.MTG_Deck.IgnoredCards == nil {
			break
		}

		return e.complexity.MTG_Deck.IgnoredCards(childComplexity), true

	case "MTG_Deck.name":
		if e.complexity.MTG_Deck.Name == nil {
			break
		}

		return e.complexity.MTG_Deck.Name(childComplexity), true

	case "MTG_Deck.zones":
		if e.complexity.MTG_Deck.Zones == nil {
			break
		}

		return e.complexity.MTG_Deck.Zones(childComplexity), true

	case "MTG_DeckCard.card":
		if e.complexity.MTG_DeckCard.Card == nil {
			break
		}

		return e.complexity.MTG_DeckCard.Card(childComplexity), true

	case "MTG_DeckCard.count":
		if e.complexity.MTG_DeckCard.Count == nil {
			break
		}

		return e.complexity.MTG_DeckCard.Count(childComplexity), true

	case "MTG_DeckCard.deckCardType":
		if e.complexity.MTG_DeckCard.DeckCardType == nil {
			break
		}

		return e.complexity.MTG_DeckCard.DeckCardType(childComplexity), true

	case "MTG_DeckCard.mainOrSide":
		if e.complexity.MTG_DeckCard.MainOrSide == nil {
			break
		}

		return e.complexity.MTG_DeckCard.MainOrSide(childComplexity), true

	case "MTG_DeckCard.phantoms":
		if e.complexity.MTG_DeckCard.Phantoms == nil {
			break
		}

		return e.complexity.MTG_DeckCard.Phantoms(childComplexity), true

	case "MTG_DeckCard.position":
		if e.complexity.MTG_DeckCard.Position == nil {
			break
		}

		return e.complexity.MTG_DeckCard.Position(childComplexity), true

	case "MTG_DeckCard.selectedVersionID":
		if e.complexity.MTG_DeckCard.SelectedVersionID == nil {
			break
		}

		return e.complexity.MTG_DeckCard.SelectedVersionID(childComplexity), true

	case "MTG_DeckCard_Dashboard.card":
		if e.complexity.MTG_DeckCard_Dashboard.Card == nil {
			break
		}

		return e.complexity.MTG_DeckCard_Dashboard.Card(childComplexity), true

	case "MTG_DeckCard_Dashboard.selectedVersionID":
		if e.complexity.MTG_DeckCard_Dashboard.SelectedVersionID == nil {
			break
		}

		return e.complexity.MTG_DeckCard_Dashboard.SelectedVersionID(childComplexity), true

	case "MTG_DeckDashboard.cardFrontImage":
		if e.complexity.MTG_DeckDashboard.CardFrontImage == nil {
			break
		}

		return e.complexity.MTG_DeckDashboard.CardFrontImage(childComplexity), true

	case "MTG_DeckDashboard.cards":
		if e.complexity.MTG_DeckDashboard.Cards == nil {
			break
		}

		return e.complexity.MTG_DeckDashboard.Cards(childComplexity), true

	case "MTG_DeckDashboard.ID":
		if e.complexity.MTG_DeckDashboard.ID == nil {
			break
		}

		return e.complexity.MTG_DeckDashboard.ID(childComplexity), true

	case "MTG_DeckDashboard.name":
		if e.complexity.MTG_DeckDashboard.Name == nil {
			break
		}

		return e.complexity.MTG_DeckDashboard.Name(childComplexity), true

	case "MTG_Deck_CardFrontImage.cardID":
		if e.complexity.MTG_Deck_CardFrontImage.CardID == nil {
			break
		}

		return e.complexity.MTG_Deck_CardFrontImage.CardID(childComplexity), true

	case "MTG_Deck_CardFrontImage.image":
		if e.complexity.MTG_Deck_CardFrontImage.Image == nil {
			break
		}

		return e.complexity.MTG_Deck_CardFrontImage.Image(childComplexity), true

	case "MTG_Deck_CardFrontImage.versionID":
		if e.complexity.MTG_Deck_CardFrontImage.VersionID == nil {
			break
		}

		return e.complexity.MTG_Deck_CardFrontImage.VersionID(childComplexity), true

	case "MTG_Filter_CardTypes.cardType":
		if e.complexity.MTG_Filter_CardTypes.CardType == nil {
			break
		}

		return e.complexity.MTG_Filter_CardTypes.CardType(childComplexity), true

	case "MTG_Filter_CardTypes.subtypes":
		if e.complexity.MTG_Filter_CardTypes.Subtypes == nil {
			break
		}

		return e.complexity.MTG_Filter_CardTypes.Subtypes(childComplexity), true

	case "MTG_Filter_Entries.expansions":
		if e.complexity.MTG_Filter_Entries.Expansions == nil {
			break
		}

		return e.complexity.MTG_Filter_Entries.Expansions(childComplexity), true

	case "MTG_Filter_Entries.layouts":
		if e.complexity.MTG_Filter_Entries.Layouts == nil {
			break
		}

		return e.complexity.MTG_Filter_Entries.Layouts(childComplexity), true

	case "MTG_Filter_Entries.legality":
		if e.complexity.MTG_Filter_Entries.Legality == nil {
			break
		}

		return e.complexity.MTG_Filter_Entries.Legality(childComplexity), true

	case "MTG_Filter_Entries.types":
		if e.complexity.MTG_Filter_Entries.Types == nil {
			break
		}

		return e.complexity.MTG_Filter_Entries.Types(childComplexity), true

	case "MTG_Filter_Expansion.games":
		if e.complexity.MTG_Filter_Expansion.Games == nil {
			break
		}

		return e.complexity.MTG_Filter_Expansion.Games(childComplexity), true

	case "MTG_Filter_Expansion.imageURL":
		if e.complexity.MTG_Filter_Expansion.ImageURL == nil {
			break
		}

		return e.complexity.MTG_Filter_Expansion.ImageURL(childComplexity), true

	case "MTG_Filter_Expansion.releasedAt":
		if e.complexity.MTG_Filter_Expansion.ReleasedAt == nil {
			break
		}

		return e.complexity.MTG_Filter_Expansion.ReleasedAt(childComplexity), true

	case "MTG_Filter_Expansion.set":
		if e.complexity.MTG_Filter_Expansion.Set == nil {
			break
		}

		return e.complexity.MTG_Filter_Expansion.Set(childComplexity), true

	case "MTG_Filter_Expansion.setName":
		if e.complexity.MTG_Filter_Expansion.SetName == nil {
			break
		}

		return e.complexity.MTG_Filter_Expansion.SetName(childComplexity), true

	case "MTG_Filter_Expansion.setType":
		if e.complexity.MTG_Filter_Expansion.SetType == nil {
			break
		}

		return e.complexity.MTG_Filter_Expansion.SetType(childComplexity), true

	case "MTG_Filter_Legality.formats":
		if e.complexity.MTG_Filter_Legality.Formats == nil {
			break
		}

		return e.complexity.MTG_Filter_Legality.Formats(childComplexity), true

	case "MTG_Filter_Legality.legalityValues":
		if e.complexity.MTG_Filter_Legality.LegalityValues == nil {
			break
		}

		return e.complexity.MTG_Filter_Legality.LegalityValues(childComplexity), true

	case "MTG_Filter_Search.pagedCards":
		if e.complexity.MTG_Filter_Search.PagedCards == nil {
			break
		}

		return e.complexity.MTG_Filter_Search.PagedCards(childComplexity), true

	case "MTG_Filter_Search.totalCount":
		if e.complexity.MTG_Filter_Search.TotalCount == nil {
			break
		}

		return e.complexity.MTG_Filter_Search.TotalCount(childComplexity), true

	case "MTG_Image.artCrop":
		if e.complexity.MTG_Image.ArtCrop == nil {
			break
		}

		return e.complexity.MTG_Image.ArtCrop(childComplexity), true

	case "MTG_Image.borderCrop":
		if e.complexity.MTG_Image.BorderCrop == nil {
			break
		}

		return e.complexity.MTG_Image.BorderCrop(childComplexity), true

	case "MTG_Image.large":
		if e.complexity.MTG_Image.Large == nil {
			break
		}

		return e.complexity.MTG_Image.Large(childComplexity), true

	case "MTG_Image.normal":
		if e.complexity.MTG_Image.Normal == nil {
			break
		}

		return e.complexity.MTG_Image.Normal(childComplexity), true

	case "MTG_Image.PNG":
		if e.complexity.MTG_Image.Png == nil {
			break
		}

		return e.complexity.MTG_Image.Png(childComplexity), true

	case "MTG_Image.small":
		if e.complexity.MTG_Image.Small == nil {
			break
		}

		return e.complexity.MTG_Image.Small(childComplexity), true

	case "Mutation.addIgnoredCard":
		if e.complexity.Mutation.AddIgnoredCard == nil {
			break
		}

		args, err := ec.field_Mutation_addIgnoredCard_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddIgnoredCard(childComplexity, args["input"].(model.AddIgnoredCardInput)), true

	case "Mutation.addMTGCardToCardPackage":
		if e.complexity.Mutation.AddMTGCardToCardPackage == nil {
			break
		}

		args, err := ec.field_Mutation_addMTGCardToCardPackage_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddMTGCardToCardPackage(childComplexity, args["input"].(model.MtgAddCardToCardPackageInput)), true

	case "Mutation.assignTag":
		if e.complexity.Mutation.AssignTag == nil {
			break
		}

		args, err := ec.field_Mutation_assignTag_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AssignTag(childComplexity, args["input"].(model.AssignTagInput)), true

	case "Mutation.createMTGCardPackage":
		if e.complexity.Mutation.CreateMTGCardPackage == nil {
			break
		}

		args, err := ec.field_Mutation_createMTGCardPackage_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateMTGCardPackage(childComplexity, args["input"].(model.MtgCreateCardPackageInput)), true

	case "Mutation.createMTGDeck":
		if e.complexity.Mutation.CreateMTGDeck == nil {
			break
		}

		args, err := ec.field_Mutation_createMTGDeck_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateMTGDeck(childComplexity, args["input"].(model.MtgCreateDeckInput)), true

	case "Mutation.createTag":
		if e.complexity.Mutation.CreateTag == nil {
			break
		}

		args, err := ec.field_Mutation_createTag_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateTag(childComplexity, args["input"].(model.CreateTagInput)), true

	case "Mutation.deleteMTGCardPackage":
		if e.complexity.Mutation.DeleteMTGCardPackage == nil {
			break
		}

		args, err := ec.field_Mutation_deleteMTGCardPackage_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteMTGCardPackage(childComplexity, args["input"].(model.MtgDeleteCardPackageInput)), true

	case "Mutation.deleteMTGDeck":
		if e.complexity.Mutation.DeleteMTGDeck == nil {
			break
		}

		args, err := ec.field_Mutation_deleteMTGDeck_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteMTGDeck(childComplexity, args["input"].(model.MtgDeleteDeckInput)), true

	case "Mutation.deleteTag":
		if e.complexity.Mutation.DeleteTag == nil {
			break
		}

		args, err := ec.field_Mutation_deleteTag_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteTag(childComplexity, args["tagID"].(string)), true

	case "Mutation.rate":
		if e.complexity.Mutation.Rate == nil {
			break
		}

		args, err := ec.field_Mutation_rate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.Rate(childComplexity, args["input"].(model.RateInput)), true

	case "Mutation.removeIgnoredCard":
		if e.complexity.Mutation.RemoveIgnoredCard == nil {
			break
		}

		args, err := ec.field_Mutation_removeIgnoredCard_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RemoveIgnoredCard(childComplexity, args["input"].(model.RemoveIgnoredCardInput)), true

	case "Mutation.removeMTGCardFromCardPackage":
		if e.complexity.Mutation.RemoveMTGCardFromCardPackage == nil {
			break
		}

		args, err := ec.field_Mutation_removeMTGCardFromCardPackage_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RemoveMTGCardFromCardPackage(childComplexity, args["input"].(model.MtgRemoveCardFromCardPackageInput)), true

	case "Mutation.saveMTGDeckAsCopy":
		if e.complexity.Mutation.SaveMTGDeckAsCopy == nil {
			break
		}

		args, err := ec.field_Mutation_saveMTGDeckAsCopy_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SaveMTGDeckAsCopy(childComplexity, args["input"].(model.MtgUpdateDeckInput)), true

	case "Mutation.unassignTag":
		if e.complexity.Mutation.UnassignTag == nil {
			break
		}

		args, err := ec.field_Mutation_unassignTag_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UnassignTag(childComplexity, args["input"].(model.UnassignTagInput)), true

	case "Mutation.updateMTGDeck":
		if e.complexity.Mutation.UpdateMTGDeck == nil {
			break
		}

		args, err := ec.field_Mutation_updateMTGDeck_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateMTGDeck(childComplexity, args["input"].(model.MtgUpdateDeckInput)), true

	case "Mutation.updateTag":
		if e.complexity.Mutation.UpdateTag == nil {
			break
		}

		args, err := ec.field_Mutation_updateTag_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateTag(childComplexity, args["input"].(model.UpdateTagInput)), true

	case "Phantom.ID":
		if e.complexity.Phantom.ID == nil {
			break
		}

		return e.complexity.Phantom.ID(childComplexity), true

	case "Phantom.position":
		if e.complexity.Phantom.Position == nil {
			break
		}

		return e.complexity.Phantom.Position(childComplexity), true

	case "Position.x":
		if e.complexity.Position.X == nil {
			break
		}

		return e.complexity.Position.X(childComplexity), true

	case "Position.y":
		if e.complexity.Position.Y == nil {
			break
		}

		return e.complexity.Position.Y(childComplexity), true

	case "Query.cardTags":
		if e.complexity.Query.CardTags == nil {
			break
		}

		return e.complexity.Query.CardTags(childComplexity), true

	case "Query.deckTags":
		if e.complexity.Query.DeckTags == nil {
			break
		}

		return e.complexity.Query.DeckTags(childComplexity), true

	case "Query.getMTGCardPackages":
		if e.complexity.Query.GetMTGCardPackages == nil {
			break
		}

		args, err := ec.field_Query_getMTGCardPackages_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetMTGCardPackages(childComplexity, args["cardPackageID"].(*string)), true

	case "Query.getMTGCards":
		if e.complexity.Query.GetMTGCards == nil {
			break
		}

		return e.complexity.Query.GetMTGCards(childComplexity), true

	case "Query.getMTGCardsFiltered":
		if e.complexity.Query.GetMTGCardsFiltered == nil {
			break
		}

		args, err := ec.field_Query_getMTGCardsFiltered_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetMTGCardsFiltered(childComplexity, args["filter"].(model.MtgFilterSearchInput), args["pagination"].(model.MtgFilterPaginationInput), args["sort"].([]*model.MtgFilterSortInput)), true

	case "Query.getMTGDeck":
		if e.complexity.Query.GetMTGDeck == nil {
			break
		}

		args, err := ec.field_Query_getMTGDeck_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetMTGDeck(childComplexity, args["deckID"].(string)), true

	case "Query.getMTGDecks":
		if e.complexity.Query.GetMTGDecks == nil {
			break
		}

		return e.complexity.Query.GetMTGDecks(childComplexity), true

	case "Query.getMTGFilters":
		if e.complexity.Query.GetMTGFilters == nil {
			break
		}

		return e.complexity.Query.GetMTGFilters(childComplexity), true

	case "Query.tag":
		if e.complexity.Query.Tag == nil {
			break
		}

		args, err := ec.field_Query_tag_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Tag(childComplexity, args["id"].(string)), true

	case "Query.tags":
		if e.complexity.Query.Tags == nil {
			break
		}

		return e.complexity.Query.Tags(childComplexity), true

	case "Response.message":
		if e.complexity.Response.Message == nil {
			break
		}

		return e.complexity.Response.Message(childComplexity), true

	case "Response.status":
		if e.complexity.Response.Status == nil {
			break
		}

		return e.complexity.Response.Status(childComplexity), true

	case "User.ID":
		if e.complexity.User.ID == nil {
			break
		}

		return e.complexity.User.ID(childComplexity), true

	case "UserRating.user":
		if e.complexity.UserRating.User == nil {
			break
		}

		return e.complexity.UserRating.User(childComplexity), true

	case "UserRating.value":
		if e.complexity.UserRating.Value == nil {
			break
		}

		return e.complexity.UserRating.Value(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	opCtx := graphql.GetOperationContext(ctx)
	ec := executionContext{opCtx, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputAddIgnoredCardInput,
		ec.unmarshalInputAssignTagInput,
		ec.unmarshalInputCreateTagInput,
		ec.unmarshalInputFlowZoneInput,
		ec.unmarshalInputMTG_AddCardToCardPackageInput,
		ec.unmarshalInputMTG_CardPackageCardInput,
		ec.unmarshalInputMTG_CreateCardPackageInput,
		ec.unmarshalInputMTG_CreateDeckInput,
		ec.unmarshalInputMTG_DeckCardFrontImageInput,
		ec.unmarshalInputMTG_DeckCardInput,
		ec.unmarshalInputMTG_DeleteCardPackageInput,
		ec.unmarshalInputMTG_DeleteDeckInput,
		ec.unmarshalInputMTG_Filter_CardTypeInput,
		ec.unmarshalInputMTG_Filter_ColorInput,
		ec.unmarshalInputMTG_Filter_GameInput,
		ec.unmarshalInputMTG_Filter_LayoutInput,
		ec.unmarshalInputMTG_Filter_LegalityEntryInput,
		ec.unmarshalInputMTG_Filter_LegalityInput,
		ec.unmarshalInputMTG_Filter_ManaCostInput,
		ec.unmarshalInputMTG_Filter_PaginationInput,
		ec.unmarshalInputMTG_Filter_RarityInput,
		ec.unmarshalInputMTG_Filter_RatingInput,
		ec.unmarshalInputMTG_Filter_SearchInput,
		ec.unmarshalInputMTG_Filter_SetInput,
		ec.unmarshalInputMTG_Filter_SortInput,
		ec.unmarshalInputMTG_Filter_SubtypeInput,
		ec.unmarshalInputMTG_Filter_TagInput,
		ec.unmarshalInputMTG_RemoveCardFromCardPackageInput,
		ec.unmarshalInputMTG_UpdateDeckInput,
		ec.unmarshalInputPhantomInput,
		ec.unmarshalInputPositionInput,
		ec.unmarshalInputRateInput,
		ec.unmarshalInputRemoveIgnoredCardInput,
		ec.unmarshalInputUnassignTagInput,
		ec.unmarshalInputUpdateTagInput,
	)
	first := true

	switch opCtx.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, opCtx.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, opCtx.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../../../graphql/Flow/input.graphqls", Input: `input FlowZoneInput {
    ID: ID!
    name: String!
    position: PositionInput!
    width: Float!
    height: Float!
    cardChildren: [ID!]!
    zoneChildren: [ID!]!
}

input PositionInput {
    x: Float!
    y: Float!
}
`, BuiltIn: false},
	{Name: "../../../graphql/Flow/type.graphqls", Input: `type FlowZone {
    ID: ID!
    name: String!
    position: Position!
    width: Float!
    height: Float!
    cardChildren: [ID!]!
    zoneChildren: [ID!]!
}

type Position {
    x: Float!
    y: Float!
}
`, BuiltIn: false},
	{Name: "../../../graphql/MTG/Card/enum.graphqls", Input: `enum MTG_Color {
    C
    W
    U
    B
    R
    G
}

enum MTG_Rarity {
    common
    uncommon
    rare
    mythic
}

enum MTG_Layout {
    normal
    split
    flip
    transform
    modal_dfc
    meld
    leveler
    class
    case
    saga
    adventure
    mutate
    prototype
    battle
    planar
    scheme
    vanguard
    token
    double_faced_token
    emblem
    augment
    host
    art_series
    reversible_card
}

enum MTG_Game {
    paper
    mtgo
    arena
}
`, BuiltIn: false},
	{Name: "../../../graphql/MTG/Card/type.graphqls", Input: `type MTG_Card {
    ID: ID! @goTag(key: "json", value: "_key")
    layout: MTG_Layout!
    CMC: Float!
    colorIdentity: [MTG_Color!]!
    colorIndicator: [String!]
    colors: [MTG_Color!]
    EDHRecRank: Int
    keywords: [String!]!
    loyalty: String
    manaCost: String
    name: String!
    oracleText: String
    power: String
    producedMana: [MTG_Color!]
    toughness: String
    typeLine: String!
    versions: [MTG_CardVersion!]!
    myRating: UserRating
    cardTags: [CardTag!]!
    deckTags: [DeckTag!]!
}

type MTG_CardVersion {
    ID: ID!
    isDefault: Boolean!
    isAlchemy: Boolean!
    artist: String
    lang: String!
    flavorName: String
    flavorText: String
    cardFaces: [MTG_CardFace!]
    legalities: Map!
    games: [MTG_Game!]!
    imageUris: MTG_Image
    rarity: MTG_Rarity!
    releasedAt: String!
    reprint: Boolean!
    setName: String!
    setType: String!
    set: String!
    setID: String!
    variation: Boolean!
    variationOf: String
}

type MTG_CardFace {
    artist: String
    CMC: Float
    colorIndicator: [String!]
    colors: [MTG_Color!]
    flavorText: String
    imageUris: MTG_Image
    layout: MTG_Layout
    loyalty: String
    manaCost: String!
    name: String!
    oracleText: String
    power: String
    toughness: String
    typeLine: String
}

type MTG_Image {
    artCrop: String!
    borderCrop: String!
    large: String!
    normal: String!
    PNG: String!
    small: String!
}

type MTG_Card_Dashboard {
    ID: ID! @goTag(key: "json", value: "_key")
    versions: [MTG_CardVersion_Dashboard!]!
}

type MTG_CardVersion_Dashboard {
    ID: ID!
    isDefault: Boolean!
    isAlchemy: Boolean!
    cardFaces: [MTG_CardFace_Dashboard!]!
    imageUris: MTG_Image
}

type MTG_CardFace_Dashboard {
    imageUris: MTG_Image
}
`, BuiltIn: false},
	{Name: "../../../graphql/MTG/CardPackage/input.graphqls", Input: `input MTG_CreateCardPackageInput {
    name: String!
}

input MTG_DeleteCardPackageInput {
    cardPackageID: ID!
}

input MTG_AddCardToCardPackageInput {
    cardPackageID: ID!
    card: ID!
    count: Int!
}

input MTG_RemoveCardFromCardPackageInput {
    cardPackageID: ID!
    card: ID!
}

input MTG_CardPackageCardInput {
    card: ID!
    selectedVersionID: String
    count: Int!
    mainOrSide: MainOrSide!
}
`, BuiltIn: false},
	{Name: "../../../graphql/MTG/CardPackage/type.graphqls", Input: `type MTG_CardPackage {
    ID: ID! @goTag(key: "json", value: "_key")
    name: String!
    cards: [MTG_CardPackageCard!]!
    # zones: [FlowZone!]! TODO: Add zones to card package in the future
}

type MTG_CardPackageCard {
    card: MTG_Card!
    selectedVersionID: String
    count: Int!
    mainOrSide: MainOrSide!
}
`, BuiltIn: false},
	{Name: "../../../graphql/MTG/Deck/enum.graphqls", Input: `enum DeckType {
    # STANDARD
    BRAWL_60
    BRAWL_100
}

enum MainOrSide {
    MAIN
    SIDEBOARD
}

enum MTG_DeckCardType {
    NORMAL
    COMMANDER
}
`, BuiltIn: false},
	{Name: "../../../graphql/MTG/Deck/input.graphqls", Input: `input MTG_CreateDeckInput {
    name: String!
}

input MTG_DeleteDeckInput {
    deckID: ID!
}

input MTG_UpdateDeckInput {
    deckID: ID!
    name: String!
    cardFrontImage: MTG_DeckCardFrontImageInput
    cards: [MTG_DeckCardInput!]!
    zones: [FlowZoneInput!]!
}

input MTG_DeckCardFrontImageInput {
    cardID: ID!
    versionID: ID!
}

input MTG_DeckCardInput {
    ID: ID!
    card: ID!
    selectedVersionID: String
    count: Int!
    position: PositionInput!
    mainOrSide: MainOrSide!
    deckCardType: MTG_DeckCardType!
    phantoms: [PhantomInput!]!
}

input PhantomInput {
    ID: ID!
    position: PositionInput!
}
`, BuiltIn: false},
	{Name: "../../../graphql/MTG/Deck/type.graphqls", Input: `type MTG_Deck {
    ID: ID! @goTag(key: "json", value: "_key")
    name: String!
    cardFrontImage: MTG_Deck_CardFrontImage
    cards: [MTG_DeckCard!]!
    zones: [FlowZone!]!
    ignoredCards: [String!]!
}

type MTG_DeckCard {
    card: MTG_Card!
    selectedVersionID: String
    count: Int!
    position: Position!
    mainOrSide: MainOrSide!
    deckCardType: MTG_DeckCardType!
    phantoms: [Phantom!]!
}

type Phantom {
    position: Position!
    ID: ID!
}

type MTG_DeckDashboard {
    ID: ID! @goTag(key: "json", value: "_key")
    name: String!
    cardFrontImage: MTG_Deck_CardFrontImage
    cards: [MTG_DeckCard_Dashboard!]!
}

type MTG_Deck_CardFrontImage {
    cardID: ID!
    versionID: ID!
    image: String!
}

type MTG_DeckCard_Dashboard {
    card: MTG_Card_Dashboard!
    selectedVersionID: String
}
`, BuiltIn: false},
	{Name: "../../../graphql/MTG/Filter/enum.graphqls", Input: `enum TernaryBoolean {
    TRUE
    FALSE
    UNSET
}

enum MTG_Filter_SortBy {
    NAME
    CMC
    RARITY
    COLOR
    TYPE
    SET
    RELEASED_AT
}

enum MTG_Filter_SortDirection {
    ASC
    DESC
}
`, BuiltIn: false},
	{Name: "../../../graphql/MTG/Filter/input.graphqls", Input: `input MTG_Filter_SearchInput {
    searchString: String
    rarity: [MTG_Filter_RarityInput!]!
    color: [MTG_Filter_ColorInput!]!
    multiColor: TernaryBoolean!
    manaCosts: [MTG_Filter_ManaCostInput!]!
    cardTypes: [MTG_Filter_CardTypeInput!]!
    subtypes: [MTG_Filter_SubtypeInput!]!
    sets: [MTG_Filter_SetInput!]!
    legalities: [MTG_Filter_LegalityInput!]!
    layouts: [MTG_Filter_LayoutInput!]!
    games: [MTG_Filter_GameInput!]!
    hideIgnored: Boolean!
    tags: [MTG_Filter_TagInput!]!
    rating: MTG_Filter_RatingInput!
    commander: ID
    deckID: ID
    isSelectingCommander: Boolean!
}

input MTG_Filter_RarityInput {
    rarity: MTG_Rarity!
    value: TernaryBoolean!
}

input MTG_Filter_ColorInput {
    color: MTG_Color!
    value: TernaryBoolean!
}

input MTG_Filter_ManaCostInput {
    manaCost: String!
    value: TernaryBoolean!
}

input MTG_Filter_CardTypeInput {
    cardType: String!
    value: TernaryBoolean!
}

input MTG_Filter_SubtypeInput {
    subtype: String!
    value: TernaryBoolean!
}

input MTG_Filter_SetInput {
    set: String!
    value: TernaryBoolean!
}

input MTG_Filter_LegalityEntryInput {
    legalityValue: String!
    value: TernaryBoolean!
}

input MTG_Filter_LegalityInput {
    format: String!
    legalityEntries: [MTG_Filter_LegalityEntryInput!]!
}

input MTG_Filter_LayoutInput {
    layout: MTG_Layout!
    value: TernaryBoolean!
}

input MTG_Filter_GameInput {
    game: MTG_Game!
    value: TernaryBoolean!
}

input MTG_Filter_TagInput {
    tag: String!
    value: TernaryBoolean!
}

input MTG_Filter_RatingInput {
    min: Int
    max: Int
}

input MTG_Filter_PaginationInput {
    page: Int!
    pageSize: Int!
}

input MTG_Filter_SortInput {
    sortBy: MTG_Filter_SortBy!
    sortDirection: MTG_Filter_SortDirection!
    enabled: Boolean!
}
`, BuiltIn: false},
	{Name: "../../../graphql/MTG/Filter/type.graphqls", Input: `type MTG_Filter_Entries {
    types: [MTG_Filter_CardTypes!]!
    expansions: [MTG_Filter_Expansion!]!
    legality: MTG_Filter_Legality!
    layouts: [MTG_Layout!]!
}

type MTG_Filter_CardTypes {
    cardType: String!
    subtypes: [String!]!
}

type MTG_Filter_Legality {
    formats: [String!]!
    legalityValues: [String!]!
}

type MTG_Filter_Expansion {
    set: String!
    setName: String!
    releasedAt: Int!
    imageURL: String!
    setType: String!
    games: [MTG_Game!]!
}

type MTG_Filter_Search {
    pagedCards: [MTG_Card!]!
    totalCount: Int!
}
`, BuiltIn: false},
	{Name: "../../../graphql/MTG/IgnoredCard/input.graphqls", Input: `input AddIgnoredCardInput {
    cardID: ID!
    deckID: ID!
}

input RemoveIgnoredCardInput {
    cardID: ID!
    deckID: ID!
}
`, BuiltIn: false},
	{Name: "../../../graphql/MTG/Tag/type.graphqls", Input: `type DeckTag implements Tag {
    ID: ID! @goTag(key: "json", value: "_key")
    name: String!
    description: String
    # aggregatedRating: AggregatedRating!
    # ratings: [UserRating!]!
    myRating: UserRating
    colors: [MTG_Color!]!
}
`, BuiltIn: false},
	{Name: "../../../graphql/mutation.graphqls", Input: `type Mutation {
    # Decks
    createMTGDeck(input: MTG_CreateDeckInput!): Response!
    deleteMTGDeck(input: MTG_DeleteDeckInput!): Response!
    updateMTGDeck(input: MTG_UpdateDeckInput!): Response!
    saveMTGDeckAsCopy(input: MTG_UpdateDeckInput!): Response!
    # Card Packages
    createMTGCardPackage(input: MTG_CreateCardPackageInput!): Response!
    deleteMTGCardPackage(input: MTG_DeleteCardPackageInput!): Response!
    addMTGCardToCardPackage(input: MTG_AddCardToCardPackageInput!): Response!
    removeMTGCardFromCardPackage(input: MTG_RemoveCardFromCardPackageInput!): Response!
    # Tags
    createTag(input: CreateTagInput!): Response!
    updateTag(input: UpdateTagInput!): Response!
    deleteTag(tagID: ID!): Response!
    assignTag(input: AssignTagInput!): Response!
    unassignTag(input: UnassignTagInput!): Response!
    # Ratings
    rate(input: RateInput!): Response!
    # Ignored Cards
    addIgnoredCard(input: AddIgnoredCardInput!): Response!
    removeIgnoredCard(input: RemoveIgnoredCardInput!): Response!
}
`, BuiltIn: false},
	{Name: "../../../graphql/query.graphqls", Input: `type Query {
    # Cards
    getMTGCards: [MTG_Card!]!
    getMTGCardsFiltered(
        filter: MTG_Filter_SearchInput!
        pagination: MTG_Filter_PaginationInput!
        sort: [MTG_Filter_SortInput!]!
    ): MTG_Filter_Search!
    getMTGFilters: MTG_Filter_Entries!
    # Decks
    getMTGDecks: [MTG_DeckDashboard!]!
    getMTGDeck(deckID: ID!): MTG_Deck!
    # Card Packages
    getMTGCardPackages(cardPackageID: ID): [MTG_CardPackage!]!
    # Tags
    tags: [Tag!]!
    cardTags: [CardTag!]!
    deckTags: [DeckTag!]!
    tag(id: ID!): Tag
}
`, BuiltIn: false},
	{Name: "../../../graphql/Rating/enum.graphqls", Input: `enum RatableEntityType {
    CARD
    TAG
}
`, BuiltIn: false},
	{Name: "../../../graphql/Rating/input.graphqls", Input: `input RateInput {
    entityID: ID!
    entityType: RatableEntityType!
    value: Int!
}
`, BuiltIn: false},
	{Name: "../../../graphql/Rating/type.graphqls", Input: `type UserRating {
    user: User!
    value: Int!
}
`, BuiltIn: false},
	{Name: "../../../graphql/Tag/enum.graphqls", Input: `enum TagType {
    CardTag
    DeckTag
}
`, BuiltIn: false},
	{Name: "../../../graphql/Tag/input.graphqls", Input: `input CreateTagInput {
    type: TagType!
    name: String!
    description: String
    colors: [MTG_Color!]
    cardID: ID
}

input UpdateTagInput {
    ID: ID!
    name: String
    description: String
    colors: [MTG_Color!]
}

input AssignTagInput {
    tagID: ID!
    cardID: ID!
}

input UnassignTagInput {
    tagID: ID!
    cardID: ID!
}
`, BuiltIn: false},
	{Name: "../../../graphql/Tag/type.graphqls", Input: `interface Tag {
    ID: ID! @goTag(key: "json", value: "_key")
    name: String!
    description: String
    myRating: UserRating
}

type CardTag implements Tag {
    ID: ID! @goTag(key: "json", value: "_key")
    name: String!
    description: String
    myRating: UserRating
}
`, BuiltIn: false},
	{Name: "../../../graphql/type.base.graphqls", Input: `directive @goTag(key: String!, value: String) on INPUT_FIELD_DEFINITION | FIELD_DEFINITION
scalar Map

type Response {
    status: Boolean!
    message: String
}
`, BuiltIn: false},
	{Name: "../../../graphql/User/type.graphqls", Input: `type User {
    ID: ID! @goTag(key: "json", value: "_key")
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) field_Mutation_addIgnoredCard_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_addIgnoredCard_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_addIgnoredCard_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.AddIgnoredCardInput, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal model.AddIgnoredCardInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNAddIgnoredCardInput2magicᚑhelperᚋgraphᚋmodelᚐAddIgnoredCardInput(ctx, tmp)
	}

	var zeroVal model.AddIgnoredCardInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_addMTGCardToCardPackage_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_addMTGCardToCardPackage_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_addMTGCardToCardPackage_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.MtgAddCardToCardPackageInput, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal model.MtgAddCardToCardPackageInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNMTG_AddCardToCardPackageInput2magicᚑhelperᚋgraphᚋmodelᚐMtgAddCardToCardPackageInput(ctx, tmp)
	}

	var zeroVal model.MtgAddCardToCardPackageInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_assignTag_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_assignTag_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_assignTag_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.AssignTagInput, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal model.AssignTagInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNAssignTagInput2magicᚑhelperᚋgraphᚋmodelᚐAssignTagInput(ctx, tmp)
	}

	var zeroVal model.AssignTagInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_createMTGCardPackage_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_createMTGCardPackage_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_createMTGCardPackage_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.MtgCreateCardPackageInput, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal model.MtgCreateCardPackageInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNMTG_CreateCardPackageInput2magicᚑhelperᚋgraphᚋmodelᚐMtgCreateCardPackageInput(ctx, tmp)
	}

	var zeroVal model.MtgCreateCardPackageInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_createMTGDeck_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_createMTGDeck_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_createMTGDeck_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.MtgCreateDeckInput, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal model.MtgCreateDeckInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNMTG_CreateDeckInput2magicᚑhelperᚋgraphᚋmodelᚐMtgCreateDeckInput(ctx, tmp)
	}

	var zeroVal model.MtgCreateDeckInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_createTag_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_createTag_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_createTag_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.CreateTagInput, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal model.CreateTagInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNCreateTagInput2magicᚑhelperᚋgraphᚋmodelᚐCreateTagInput(ctx, tmp)
	}

	var zeroVal model.CreateTagInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_deleteMTGCardPackage_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_deleteMTGCardPackage_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_deleteMTGCardPackage_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.MtgDeleteCardPackageInput, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal model.MtgDeleteCardPackageInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNMTG_DeleteCardPackageInput2magicᚑhelperᚋgraphᚋmodelᚐMtgDeleteCardPackageInput(ctx, tmp)
	}

	var zeroVal model.MtgDeleteCardPackageInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_deleteMTGDeck_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_deleteMTGDeck_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_deleteMTGDeck_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.MtgDeleteDeckInput, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal model.MtgDeleteDeckInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNMTG_DeleteDeckInput2magicᚑhelperᚋgraphᚋmodelᚐMtgDeleteDeckInput(ctx, tmp)
	}

	var zeroVal model.MtgDeleteDeckInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_deleteTag_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_deleteTag_argsTagID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["tagID"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_deleteTag_argsTagID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["tagID"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("tagID"))
	if tmp, ok := rawArgs["tagID"]; ok {
		return ec.unmarshalNID2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_rate_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_rate_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_rate_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.RateInput, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal model.RateInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNRateInput2magicᚑhelperᚋgraphᚋmodelᚐRateInput(ctx, tmp)
	}

	var zeroVal model.RateInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_removeIgnoredCard_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_removeIgnoredCard_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_removeIgnoredCard_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.RemoveIgnoredCardInput, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal model.RemoveIgnoredCardInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNRemoveIgnoredCardInput2magicᚑhelperᚋgraphᚋmodelᚐRemoveIgnoredCardInput(ctx, tmp)
	}

	var zeroVal model.RemoveIgnoredCardInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_removeMTGCardFromCardPackage_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_removeMTGCardFromCardPackage_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_removeMTGCardFromCardPackage_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.MtgRemoveCardFromCardPackageInput, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal model.MtgRemoveCardFromCardPackageInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNMTG_RemoveCardFromCardPackageInput2magicᚑhelperᚋgraphᚋmodelᚐMtgRemoveCardFromCardPackageInput(ctx, tmp)
	}

	var zeroVal model.MtgRemoveCardFromCardPackageInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_saveMTGDeckAsCopy_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_saveMTGDeckAsCopy_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_saveMTGDeckAsCopy_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.MtgUpdateDeckInput, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal model.MtgUpdateDeckInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNMTG_UpdateDeckInput2magicᚑhelperᚋgraphᚋmodelᚐMtgUpdateDeckInput(ctx, tmp)
	}

	var zeroVal model.MtgUpdateDeckInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_unassignTag_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_unassignTag_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_unassignTag_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.UnassignTagInput, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal model.UnassignTagInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNUnassignTagInput2magicᚑhelperᚋgraphᚋmodelᚐUnassignTagInput(ctx, tmp)
	}

	var zeroVal model.UnassignTagInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_updateMTGDeck_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_updateMTGDeck_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_updateMTGDeck_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.MtgUpdateDeckInput, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal model.MtgUpdateDeckInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNMTG_UpdateDeckInput2magicᚑhelperᚋgraphᚋmodelᚐMtgUpdateDeckInput(ctx, tmp)
	}

	var zeroVal model.MtgUpdateDeckInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_updateTag_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_updateTag_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_updateTag_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.UpdateTagInput, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal model.UpdateTagInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNUpdateTagInput2magicᚑhelperᚋgraphᚋmodelᚐUpdateTagInput(ctx, tmp)
	}

	var zeroVal model.UpdateTagInput
	return zeroVal, nil
}

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query___type_argsName(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["name"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query___type_argsName(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["name"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
	if tmp, ok := rawArgs["name"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getMTGCardPackages_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_getMTGCardPackages_argsCardPackageID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["cardPackageID"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_getMTGCardPackages_argsCardPackageID(
	ctx context.Context,
	rawArgs map[string]any,
) (*string, error) {
	if _, ok := rawArgs["cardPackageID"]; !ok {
		var zeroVal *string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("cardPackageID"))
	if tmp, ok := rawArgs["cardPackageID"]; ok {
		return ec.unmarshalOID2ᚖstring(ctx, tmp)
	}

	var zeroVal *string
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getMTGCardsFiltered_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_getMTGCardsFiltered_argsFilter(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["filter"] = arg0
	arg1, err := ec.field_Query_getMTGCardsFiltered_argsPagination(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["pagination"] = arg1
	arg2, err := ec.field_Query_getMTGCardsFiltered_argsSort(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["sort"] = arg2
	return args, nil
}
func (ec *executionContext) field_Query_getMTGCardsFiltered_argsFilter(
	ctx context.Context,
	rawArgs map[string]any,
) (model.MtgFilterSearchInput, error) {
	if _, ok := rawArgs["filter"]; !ok {
		var zeroVal model.MtgFilterSearchInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
	if tmp, ok := rawArgs["filter"]; ok {
		return ec.unmarshalNMTG_Filter_SearchInput2magicᚑhelperᚋgraphᚋmodelᚐMtgFilterSearchInput(ctx, tmp)
	}

	var zeroVal model.MtgFilterSearchInput
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getMTGCardsFiltered_argsPagination(
	ctx context.Context,
	rawArgs map[string]any,
) (model.MtgFilterPaginationInput, error) {
	if _, ok := rawArgs["pagination"]; !ok {
		var zeroVal model.MtgFilterPaginationInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
	if tmp, ok := rawArgs["pagination"]; ok {
		return ec.unmarshalNMTG_Filter_PaginationInput2magicᚑhelperᚋgraphᚋmodelᚐMtgFilterPaginationInput(ctx, tmp)
	}

	var zeroVal model.MtgFilterPaginationInput
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getMTGCardsFiltered_argsSort(
	ctx context.Context,
	rawArgs map[string]any,
) ([]*model.MtgFilterSortInput, error) {
	if _, ok := rawArgs["sort"]; !ok {
		var zeroVal []*model.MtgFilterSortInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("sort"))
	if tmp, ok := rawArgs["sort"]; ok {
		return ec.unmarshalNMTG_Filter_SortInput2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterSortInputᚄ(ctx, tmp)
	}

	var zeroVal []*model.MtgFilterSortInput
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getMTGDeck_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_getMTGDeck_argsDeckID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["deckID"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_getMTGDeck_argsDeckID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["deckID"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("deckID"))
	if tmp, ok := rawArgs["deckID"]; ok {
		return ec.unmarshalNID2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Query_tag_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_tag_argsID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_tag_argsID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["id"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
	if tmp, ok := rawArgs["id"]; ok {
		return ec.unmarshalNID2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field___Directive_args_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field___Directive_args_argsIncludeDeprecated(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}
func (ec *executionContext) field___Directive_args_argsIncludeDeprecated(
	ctx context.Context,
	rawArgs map[string]any,
) (*bool, error) {
	if _, ok := rawArgs["includeDeprecated"]; !ok {
		var zeroVal *bool
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		return ec.unmarshalOBoolean2ᚖbool(ctx, tmp)
	}

	var zeroVal *bool
	return zeroVal, nil
}

func (ec *executionContext) field___Field_args_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field___Field_args_argsIncludeDeprecated(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}
func (ec *executionContext) field___Field_args_argsIncludeDeprecated(
	ctx context.Context,
	rawArgs map[string]any,
) (*bool, error) {
	if _, ok := rawArgs["includeDeprecated"]; !ok {
		var zeroVal *bool
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		return ec.unmarshalOBoolean2ᚖbool(ctx, tmp)
	}

	var zeroVal *bool
	return zeroVal, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field___Type_enumValues_argsIncludeDeprecated(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}
func (ec *executionContext) field___Type_enumValues_argsIncludeDeprecated(
	ctx context.Context,
	rawArgs map[string]any,
) (bool, error) {
	if _, ok := rawArgs["includeDeprecated"]; !ok {
		var zeroVal bool
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		return ec.unmarshalOBoolean2bool(ctx, tmp)
	}

	var zeroVal bool
	return zeroVal, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field___Type_fields_argsIncludeDeprecated(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}
func (ec *executionContext) field___Type_fields_argsIncludeDeprecated(
	ctx context.Context,
	rawArgs map[string]any,
) (bool, error) {
	if _, ok := rawArgs["includeDeprecated"]; !ok {
		var zeroVal bool
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		return ec.unmarshalOBoolean2bool(ctx, tmp)
	}

	var zeroVal bool
	return zeroVal, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _CardTag_ID(ctx context.Context, field graphql.CollectedField, obj *model.CardTag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CardTag_ID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CardTag_ID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CardTag",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CardTag_name(ctx context.Context, field graphql.CollectedField, obj *model.CardTag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CardTag_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CardTag_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CardTag",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CardTag_description(ctx context.Context, field graphql.CollectedField, obj *model.CardTag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CardTag_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CardTag_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CardTag",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CardTag_myRating(ctx context.Context, field graphql.CollectedField, obj *model.CardTag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CardTag_myRating(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MyRating, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.UserRating)
	fc.Result = res
	return ec.marshalOUserRating2ᚖmagicᚑhelperᚋgraphᚋmodelᚐUserRating(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CardTag_myRating(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CardTag",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "user":
				return ec.fieldContext_UserRating_user(ctx, field)
			case "value":
				return ec.fieldContext_UserRating_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserRating", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeckTag_ID(ctx context.Context, field graphql.CollectedField, obj *model.DeckTag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeckTag_ID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeckTag_ID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeckTag",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeckTag_name(ctx context.Context, field graphql.CollectedField, obj *model.DeckTag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeckTag_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeckTag_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeckTag",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeckTag_description(ctx context.Context, field graphql.CollectedField, obj *model.DeckTag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeckTag_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeckTag_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeckTag",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeckTag_myRating(ctx context.Context, field graphql.CollectedField, obj *model.DeckTag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeckTag_myRating(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MyRating, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.UserRating)
	fc.Result = res
	return ec.marshalOUserRating2ᚖmagicᚑhelperᚋgraphᚋmodelᚐUserRating(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeckTag_myRating(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeckTag",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "user":
				return ec.fieldContext_UserRating_user(ctx, field)
			case "value":
				return ec.fieldContext_UserRating_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserRating", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeckTag_colors(ctx context.Context, field graphql.CollectedField, obj *model.DeckTag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeckTag_colors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Colors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.MtgColor)
	fc.Result = res
	return ec.marshalNMTG_Color2ᚕmagicᚑhelperᚋgraphᚋmodelᚐMtgColorᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeckTag_colors(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeckTag",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type MTG_Color does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FlowZone_ID(ctx context.Context, field graphql.CollectedField, obj *model.FlowZone) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FlowZone_ID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FlowZone_ID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FlowZone",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FlowZone_name(ctx context.Context, field graphql.CollectedField, obj *model.FlowZone) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FlowZone_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FlowZone_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FlowZone",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FlowZone_position(ctx context.Context, field graphql.CollectedField, obj *model.FlowZone) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FlowZone_position(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Position, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Position)
	fc.Result = res
	return ec.marshalNPosition2ᚖmagicᚑhelperᚋgraphᚋmodelᚐPosition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FlowZone_position(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FlowZone",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "x":
				return ec.fieldContext_Position_x(ctx, field)
			case "y":
				return ec.fieldContext_Position_y(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Position", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FlowZone_width(ctx context.Context, field graphql.CollectedField, obj *model.FlowZone) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FlowZone_width(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Width, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FlowZone_width(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FlowZone",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FlowZone_height(ctx context.Context, field graphql.CollectedField, obj *model.FlowZone) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FlowZone_height(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Height, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FlowZone_height(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FlowZone",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FlowZone_cardChildren(ctx context.Context, field graphql.CollectedField, obj *model.FlowZone) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FlowZone_cardChildren(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CardChildren, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNID2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FlowZone_cardChildren(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FlowZone",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FlowZone_zoneChildren(ctx context.Context, field graphql.CollectedField, obj *model.FlowZone) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FlowZone_zoneChildren(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ZoneChildren, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNID2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FlowZone_zoneChildren(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FlowZone",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Card_ID(ctx context.Context, field graphql.CollectedField, obj *model.MtgCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Card_ID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Card_ID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Card",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Card_layout(ctx context.Context, field graphql.CollectedField, obj *model.MtgCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Card_layout(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Layout, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.MtgLayout)
	fc.Result = res
	return ec.marshalNMTG_Layout2magicᚑhelperᚋgraphᚋmodelᚐMtgLayout(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Card_layout(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Card",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type MTG_Layout does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Card_CMC(ctx context.Context, field graphql.CollectedField, obj *model.MtgCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Card_CMC(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cmc, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Card_CMC(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Card",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Card_colorIdentity(ctx context.Context, field graphql.CollectedField, obj *model.MtgCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Card_colorIdentity(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ColorIdentity, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.MtgColor)
	fc.Result = res
	return ec.marshalNMTG_Color2ᚕmagicᚑhelperᚋgraphᚋmodelᚐMtgColorᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Card_colorIdentity(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Card",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type MTG_Color does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Card_colorIndicator(ctx context.Context, field graphql.CollectedField, obj *model.MtgCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Card_colorIndicator(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ColorIndicator, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Card_colorIndicator(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Card",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Card_colors(ctx context.Context, field graphql.CollectedField, obj *model.MtgCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Card_colors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Colors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.MtgColor)
	fc.Result = res
	return ec.marshalOMTG_Color2ᚕmagicᚑhelperᚋgraphᚋmodelᚐMtgColorᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Card_colors(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Card",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type MTG_Color does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Card_EDHRecRank(ctx context.Context, field graphql.CollectedField, obj *model.MtgCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Card_EDHRecRank(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EDHRecRank, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Card_EDHRecRank(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Card",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Card_keywords(ctx context.Context, field graphql.CollectedField, obj *model.MtgCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Card_keywords(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Keywords, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Card_keywords(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Card",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Card_loyalty(ctx context.Context, field graphql.CollectedField, obj *model.MtgCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Card_loyalty(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Loyalty, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Card_loyalty(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Card",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Card_manaCost(ctx context.Context, field graphql.CollectedField, obj *model.MtgCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Card_manaCost(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ManaCost, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Card_manaCost(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Card",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Card_name(ctx context.Context, field graphql.CollectedField, obj *model.MtgCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Card_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Card_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Card",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Card_oracleText(ctx context.Context, field graphql.CollectedField, obj *model.MtgCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Card_oracleText(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OracleText, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Card_oracleText(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Card",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Card_power(ctx context.Context, field graphql.CollectedField, obj *model.MtgCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Card_power(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Power, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Card_power(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Card",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Card_producedMana(ctx context.Context, field graphql.CollectedField, obj *model.MtgCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Card_producedMana(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProducedMana, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.MtgColor)
	fc.Result = res
	return ec.marshalOMTG_Color2ᚕmagicᚑhelperᚋgraphᚋmodelᚐMtgColorᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Card_producedMana(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Card",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type MTG_Color does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Card_toughness(ctx context.Context, field graphql.CollectedField, obj *model.MtgCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Card_toughness(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Toughness, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Card_toughness(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Card",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Card_typeLine(ctx context.Context, field graphql.CollectedField, obj *model.MtgCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Card_typeLine(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TypeLine, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Card_typeLine(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Card",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Card_versions(ctx context.Context, field graphql.CollectedField, obj *model.MtgCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Card_versions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Versions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.MtgCardVersion)
	fc.Result = res
	return ec.marshalNMTG_CardVersion2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgCardVersionᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Card_versions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Card",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ID":
				return ec.fieldContext_MTG_CardVersion_ID(ctx, field)
			case "isDefault":
				return ec.fieldContext_MTG_CardVersion_isDefault(ctx, field)
			case "isAlchemy":
				return ec.fieldContext_MTG_CardVersion_isAlchemy(ctx, field)
			case "artist":
				return ec.fieldContext_MTG_CardVersion_artist(ctx, field)
			case "lang":
				return ec.fieldContext_MTG_CardVersion_lang(ctx, field)
			case "flavorName":
				return ec.fieldContext_MTG_CardVersion_flavorName(ctx, field)
			case "flavorText":
				return ec.fieldContext_MTG_CardVersion_flavorText(ctx, field)
			case "cardFaces":
				return ec.fieldContext_MTG_CardVersion_cardFaces(ctx, field)
			case "legalities":
				return ec.fieldContext_MTG_CardVersion_legalities(ctx, field)
			case "games":
				return ec.fieldContext_MTG_CardVersion_games(ctx, field)
			case "imageUris":
				return ec.fieldContext_MTG_CardVersion_imageUris(ctx, field)
			case "rarity":
				return ec.fieldContext_MTG_CardVersion_rarity(ctx, field)
			case "releasedAt":
				return ec.fieldContext_MTG_CardVersion_releasedAt(ctx, field)
			case "reprint":
				return ec.fieldContext_MTG_CardVersion_reprint(ctx, field)
			case "setName":
				return ec.fieldContext_MTG_CardVersion_setName(ctx, field)
			case "setType":
				return ec.fieldContext_MTG_CardVersion_setType(ctx, field)
			case "set":
				return ec.fieldContext_MTG_CardVersion_set(ctx, field)
			case "setID":
				return ec.fieldContext_MTG_CardVersion_setID(ctx, field)
			case "variation":
				return ec.fieldContext_MTG_CardVersion_variation(ctx, field)
			case "variationOf":
				return ec.fieldContext_MTG_CardVersion_variationOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MTG_CardVersion", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Card_myRating(ctx context.Context, field graphql.CollectedField, obj *model.MtgCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Card_myRating(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MyRating, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.UserRating)
	fc.Result = res
	return ec.marshalOUserRating2ᚖmagicᚑhelperᚋgraphᚋmodelᚐUserRating(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Card_myRating(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Card",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "user":
				return ec.fieldContext_UserRating_user(ctx, field)
			case "value":
				return ec.fieldContext_UserRating_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserRating", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Card_cardTags(ctx context.Context, field graphql.CollectedField, obj *model.MtgCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Card_cardTags(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CardTags, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.CardTag)
	fc.Result = res
	return ec.marshalNCardTag2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐCardTagᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Card_cardTags(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Card",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ID":
				return ec.fieldContext_CardTag_ID(ctx, field)
			case "name":
				return ec.fieldContext_CardTag_name(ctx, field)
			case "description":
				return ec.fieldContext_CardTag_description(ctx, field)
			case "myRating":
				return ec.fieldContext_CardTag_myRating(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CardTag", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Card_deckTags(ctx context.Context, field graphql.CollectedField, obj *model.MtgCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Card_deckTags(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeckTags, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.DeckTag)
	fc.Result = res
	return ec.marshalNDeckTag2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐDeckTagᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Card_deckTags(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Card",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ID":
				return ec.fieldContext_DeckTag_ID(ctx, field)
			case "name":
				return ec.fieldContext_DeckTag_name(ctx, field)
			case "description":
				return ec.fieldContext_DeckTag_description(ctx, field)
			case "myRating":
				return ec.fieldContext_DeckTag_myRating(ctx, field)
			case "colors":
				return ec.fieldContext_DeckTag_colors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DeckTag", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardFace_artist(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardFace) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardFace_artist(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Artist, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardFace_artist(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardFace",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardFace_CMC(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardFace) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardFace_CMC(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cmc, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*float64)
	fc.Result = res
	return ec.marshalOFloat2ᚖfloat64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardFace_CMC(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardFace",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardFace_colorIndicator(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardFace) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardFace_colorIndicator(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ColorIndicator, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardFace_colorIndicator(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardFace",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardFace_colors(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardFace) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardFace_colors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Colors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.MtgColor)
	fc.Result = res
	return ec.marshalOMTG_Color2ᚕmagicᚑhelperᚋgraphᚋmodelᚐMtgColorᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardFace_colors(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardFace",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type MTG_Color does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardFace_flavorText(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardFace) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardFace_flavorText(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FlavorText, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardFace_flavorText(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardFace",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardFace_imageUris(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardFace) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardFace_imageUris(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ImageUris, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.MtgImage)
	fc.Result = res
	return ec.marshalOMTG_Image2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgImage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardFace_imageUris(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardFace",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "artCrop":
				return ec.fieldContext_MTG_Image_artCrop(ctx, field)
			case "borderCrop":
				return ec.fieldContext_MTG_Image_borderCrop(ctx, field)
			case "large":
				return ec.fieldContext_MTG_Image_large(ctx, field)
			case "normal":
				return ec.fieldContext_MTG_Image_normal(ctx, field)
			case "PNG":
				return ec.fieldContext_MTG_Image_PNG(ctx, field)
			case "small":
				return ec.fieldContext_MTG_Image_small(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MTG_Image", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardFace_layout(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardFace) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardFace_layout(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Layout, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.MtgLayout)
	fc.Result = res
	return ec.marshalOMTG_Layout2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgLayout(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardFace_layout(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardFace",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type MTG_Layout does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardFace_loyalty(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardFace) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardFace_loyalty(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Loyalty, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardFace_loyalty(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardFace",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardFace_manaCost(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardFace) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardFace_manaCost(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ManaCost, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardFace_manaCost(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardFace",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardFace_name(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardFace) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardFace_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardFace_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardFace",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardFace_oracleText(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardFace) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardFace_oracleText(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OracleText, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardFace_oracleText(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardFace",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardFace_power(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardFace) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardFace_power(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Power, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardFace_power(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardFace",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardFace_toughness(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardFace) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardFace_toughness(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Toughness, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardFace_toughness(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardFace",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardFace_typeLine(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardFace) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardFace_typeLine(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TypeLine, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardFace_typeLine(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardFace",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardFace_Dashboard_imageUris(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardFaceDashboard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardFace_Dashboard_imageUris(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ImageUris, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.MtgImage)
	fc.Result = res
	return ec.marshalOMTG_Image2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgImage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardFace_Dashboard_imageUris(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardFace_Dashboard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "artCrop":
				return ec.fieldContext_MTG_Image_artCrop(ctx, field)
			case "borderCrop":
				return ec.fieldContext_MTG_Image_borderCrop(ctx, field)
			case "large":
				return ec.fieldContext_MTG_Image_large(ctx, field)
			case "normal":
				return ec.fieldContext_MTG_Image_normal(ctx, field)
			case "PNG":
				return ec.fieldContext_MTG_Image_PNG(ctx, field)
			case "small":
				return ec.fieldContext_MTG_Image_small(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MTG_Image", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardPackage_ID(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardPackage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardPackage_ID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardPackage_ID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardPackage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardPackage_name(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardPackage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardPackage_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardPackage_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardPackage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardPackage_cards(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardPackage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardPackage_cards(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cards, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.MtgCardPackageCard)
	fc.Result = res
	return ec.marshalNMTG_CardPackageCard2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgCardPackageCardᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardPackage_cards(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardPackage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "card":
				return ec.fieldContext_MTG_CardPackageCard_card(ctx, field)
			case "selectedVersionID":
				return ec.fieldContext_MTG_CardPackageCard_selectedVersionID(ctx, field)
			case "count":
				return ec.fieldContext_MTG_CardPackageCard_count(ctx, field)
			case "mainOrSide":
				return ec.fieldContext_MTG_CardPackageCard_mainOrSide(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MTG_CardPackageCard", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardPackageCard_card(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardPackageCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardPackageCard_card(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Card, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.MtgCard)
	fc.Result = res
	return ec.marshalNMTG_Card2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgCard(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardPackageCard_card(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardPackageCard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ID":
				return ec.fieldContext_MTG_Card_ID(ctx, field)
			case "layout":
				return ec.fieldContext_MTG_Card_layout(ctx, field)
			case "CMC":
				return ec.fieldContext_MTG_Card_CMC(ctx, field)
			case "colorIdentity":
				return ec.fieldContext_MTG_Card_colorIdentity(ctx, field)
			case "colorIndicator":
				return ec.fieldContext_MTG_Card_colorIndicator(ctx, field)
			case "colors":
				return ec.fieldContext_MTG_Card_colors(ctx, field)
			case "EDHRecRank":
				return ec.fieldContext_MTG_Card_EDHRecRank(ctx, field)
			case "keywords":
				return ec.fieldContext_MTG_Card_keywords(ctx, field)
			case "loyalty":
				return ec.fieldContext_MTG_Card_loyalty(ctx, field)
			case "manaCost":
				return ec.fieldContext_MTG_Card_manaCost(ctx, field)
			case "name":
				return ec.fieldContext_MTG_Card_name(ctx, field)
			case "oracleText":
				return ec.fieldContext_MTG_Card_oracleText(ctx, field)
			case "power":
				return ec.fieldContext_MTG_Card_power(ctx, field)
			case "producedMana":
				return ec.fieldContext_MTG_Card_producedMana(ctx, field)
			case "toughness":
				return ec.fieldContext_MTG_Card_toughness(ctx, field)
			case "typeLine":
				return ec.fieldContext_MTG_Card_typeLine(ctx, field)
			case "versions":
				return ec.fieldContext_MTG_Card_versions(ctx, field)
			case "myRating":
				return ec.fieldContext_MTG_Card_myRating(ctx, field)
			case "cardTags":
				return ec.fieldContext_MTG_Card_cardTags(ctx, field)
			case "deckTags":
				return ec.fieldContext_MTG_Card_deckTags(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MTG_Card", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardPackageCard_selectedVersionID(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardPackageCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardPackageCard_selectedVersionID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SelectedVersionID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardPackageCard_selectedVersionID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardPackageCard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardPackageCard_count(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardPackageCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardPackageCard_count(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardPackageCard_count(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardPackageCard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardPackageCard_mainOrSide(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardPackageCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardPackageCard_mainOrSide(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MainOrSide, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.MainOrSide)
	fc.Result = res
	return ec.marshalNMainOrSide2magicᚑhelperᚋgraphᚋmodelᚐMainOrSide(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardPackageCard_mainOrSide(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardPackageCard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type MainOrSide does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardVersion_ID(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardVersion_ID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardVersion_ID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardVersion_isDefault(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardVersion_isDefault(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDefault, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardVersion_isDefault(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardVersion_isAlchemy(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardVersion_isAlchemy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsAlchemy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardVersion_isAlchemy(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardVersion_artist(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardVersion_artist(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Artist, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardVersion_artist(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardVersion_lang(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardVersion_lang(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Lang, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardVersion_lang(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardVersion_flavorName(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardVersion_flavorName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FlavorName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardVersion_flavorName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardVersion_flavorText(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardVersion_flavorText(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FlavorText, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardVersion_flavorText(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardVersion_cardFaces(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardVersion_cardFaces(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CardFaces, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.MtgCardFace)
	fc.Result = res
	return ec.marshalOMTG_CardFace2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgCardFaceᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardVersion_cardFaces(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "artist":
				return ec.fieldContext_MTG_CardFace_artist(ctx, field)
			case "CMC":
				return ec.fieldContext_MTG_CardFace_CMC(ctx, field)
			case "colorIndicator":
				return ec.fieldContext_MTG_CardFace_colorIndicator(ctx, field)
			case "colors":
				return ec.fieldContext_MTG_CardFace_colors(ctx, field)
			case "flavorText":
				return ec.fieldContext_MTG_CardFace_flavorText(ctx, field)
			case "imageUris":
				return ec.fieldContext_MTG_CardFace_imageUris(ctx, field)
			case "layout":
				return ec.fieldContext_MTG_CardFace_layout(ctx, field)
			case "loyalty":
				return ec.fieldContext_MTG_CardFace_loyalty(ctx, field)
			case "manaCost":
				return ec.fieldContext_MTG_CardFace_manaCost(ctx, field)
			case "name":
				return ec.fieldContext_MTG_CardFace_name(ctx, field)
			case "oracleText":
				return ec.fieldContext_MTG_CardFace_oracleText(ctx, field)
			case "power":
				return ec.fieldContext_MTG_CardFace_power(ctx, field)
			case "toughness":
				return ec.fieldContext_MTG_CardFace_toughness(ctx, field)
			case "typeLine":
				return ec.fieldContext_MTG_CardFace_typeLine(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MTG_CardFace", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardVersion_legalities(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardVersion_legalities(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Legalities, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(map[string]any)
	fc.Result = res
	return ec.marshalNMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardVersion_legalities(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardVersion_games(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardVersion_games(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Games, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.MtgGame)
	fc.Result = res
	return ec.marshalNMTG_Game2ᚕmagicᚑhelperᚋgraphᚋmodelᚐMtgGameᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardVersion_games(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type MTG_Game does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardVersion_imageUris(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardVersion_imageUris(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ImageUris, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.MtgImage)
	fc.Result = res
	return ec.marshalOMTG_Image2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgImage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardVersion_imageUris(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "artCrop":
				return ec.fieldContext_MTG_Image_artCrop(ctx, field)
			case "borderCrop":
				return ec.fieldContext_MTG_Image_borderCrop(ctx, field)
			case "large":
				return ec.fieldContext_MTG_Image_large(ctx, field)
			case "normal":
				return ec.fieldContext_MTG_Image_normal(ctx, field)
			case "PNG":
				return ec.fieldContext_MTG_Image_PNG(ctx, field)
			case "small":
				return ec.fieldContext_MTG_Image_small(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MTG_Image", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardVersion_rarity(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardVersion_rarity(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Rarity, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.MtgRarity)
	fc.Result = res
	return ec.marshalNMTG_Rarity2magicᚑhelperᚋgraphᚋmodelᚐMtgRarity(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardVersion_rarity(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type MTG_Rarity does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardVersion_releasedAt(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardVersion_releasedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ReleasedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardVersion_releasedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardVersion_reprint(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardVersion_reprint(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Reprint, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardVersion_reprint(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardVersion_setName(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardVersion_setName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SetName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardVersion_setName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardVersion_setType(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardVersion_setType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SetType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardVersion_setType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardVersion_set(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardVersion_set(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Set, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardVersion_set(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardVersion_setID(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardVersion_setID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SetID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardVersion_setID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardVersion_variation(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardVersion_variation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Variation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardVersion_variation(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardVersion_variationOf(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardVersion_variationOf(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.VariationOf, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardVersion_variationOf(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardVersion_Dashboard_ID(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardVersionDashboard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardVersion_Dashboard_ID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardVersion_Dashboard_ID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardVersion_Dashboard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardVersion_Dashboard_isDefault(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardVersionDashboard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardVersion_Dashboard_isDefault(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDefault, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardVersion_Dashboard_isDefault(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardVersion_Dashboard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardVersion_Dashboard_isAlchemy(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardVersionDashboard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardVersion_Dashboard_isAlchemy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsAlchemy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardVersion_Dashboard_isAlchemy(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardVersion_Dashboard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardVersion_Dashboard_cardFaces(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardVersionDashboard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardVersion_Dashboard_cardFaces(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CardFaces, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.MtgCardFaceDashboard)
	fc.Result = res
	return ec.marshalNMTG_CardFace_Dashboard2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgCardFaceDashboardᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardVersion_Dashboard_cardFaces(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardVersion_Dashboard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "imageUris":
				return ec.fieldContext_MTG_CardFace_Dashboard_imageUris(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MTG_CardFace_Dashboard", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardVersion_Dashboard_imageUris(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardVersionDashboard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardVersion_Dashboard_imageUris(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ImageUris, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.MtgImage)
	fc.Result = res
	return ec.marshalOMTG_Image2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgImage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardVersion_Dashboard_imageUris(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardVersion_Dashboard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "artCrop":
				return ec.fieldContext_MTG_Image_artCrop(ctx, field)
			case "borderCrop":
				return ec.fieldContext_MTG_Image_borderCrop(ctx, field)
			case "large":
				return ec.fieldContext_MTG_Image_large(ctx, field)
			case "normal":
				return ec.fieldContext_MTG_Image_normal(ctx, field)
			case "PNG":
				return ec.fieldContext_MTG_Image_PNG(ctx, field)
			case "small":
				return ec.fieldContext_MTG_Image_small(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MTG_Image", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Card_Dashboard_ID(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardDashboard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Card_Dashboard_ID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Card_Dashboard_ID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Card_Dashboard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Card_Dashboard_versions(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardDashboard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Card_Dashboard_versions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Versions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.MtgCardVersionDashboard)
	fc.Result = res
	return ec.marshalNMTG_CardVersion_Dashboard2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgCardVersionDashboardᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Card_Dashboard_versions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Card_Dashboard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ID":
				return ec.fieldContext_MTG_CardVersion_Dashboard_ID(ctx, field)
			case "isDefault":
				return ec.fieldContext_MTG_CardVersion_Dashboard_isDefault(ctx, field)
			case "isAlchemy":
				return ec.fieldContext_MTG_CardVersion_Dashboard_isAlchemy(ctx, field)
			case "cardFaces":
				return ec.fieldContext_MTG_CardVersion_Dashboard_cardFaces(ctx, field)
			case "imageUris":
				return ec.fieldContext_MTG_CardVersion_Dashboard_imageUris(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MTG_CardVersion_Dashboard", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Deck_ID(ctx context.Context, field graphql.CollectedField, obj *model.MtgDeck) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Deck_ID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Deck_ID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Deck",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Deck_name(ctx context.Context, field graphql.CollectedField, obj *model.MtgDeck) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Deck_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Deck_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Deck",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Deck_cardFrontImage(ctx context.Context, field graphql.CollectedField, obj *model.MtgDeck) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Deck_cardFrontImage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CardFrontImage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.MtgDeckCardFrontImage)
	fc.Result = res
	return ec.marshalOMTG_Deck_CardFrontImage2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgDeckCardFrontImage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Deck_cardFrontImage(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Deck",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cardID":
				return ec.fieldContext_MTG_Deck_CardFrontImage_cardID(ctx, field)
			case "versionID":
				return ec.fieldContext_MTG_Deck_CardFrontImage_versionID(ctx, field)
			case "image":
				return ec.fieldContext_MTG_Deck_CardFrontImage_image(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MTG_Deck_CardFrontImage", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Deck_cards(ctx context.Context, field graphql.CollectedField, obj *model.MtgDeck) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Deck_cards(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cards, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.MtgDeckCard)
	fc.Result = res
	return ec.marshalNMTG_DeckCard2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgDeckCardᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Deck_cards(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Deck",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "card":
				return ec.fieldContext_MTG_DeckCard_card(ctx, field)
			case "selectedVersionID":
				return ec.fieldContext_MTG_DeckCard_selectedVersionID(ctx, field)
			case "count":
				return ec.fieldContext_MTG_DeckCard_count(ctx, field)
			case "position":
				return ec.fieldContext_MTG_DeckCard_position(ctx, field)
			case "mainOrSide":
				return ec.fieldContext_MTG_DeckCard_mainOrSide(ctx, field)
			case "deckCardType":
				return ec.fieldContext_MTG_DeckCard_deckCardType(ctx, field)
			case "phantoms":
				return ec.fieldContext_MTG_DeckCard_phantoms(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MTG_DeckCard", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Deck_zones(ctx context.Context, field graphql.CollectedField, obj *model.MtgDeck) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Deck_zones(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Zones, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.FlowZone)
	fc.Result = res
	return ec.marshalNFlowZone2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐFlowZoneᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Deck_zones(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Deck",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ID":
				return ec.fieldContext_FlowZone_ID(ctx, field)
			case "name":
				return ec.fieldContext_FlowZone_name(ctx, field)
			case "position":
				return ec.fieldContext_FlowZone_position(ctx, field)
			case "width":
				return ec.fieldContext_FlowZone_width(ctx, field)
			case "height":
				return ec.fieldContext_FlowZone_height(ctx, field)
			case "cardChildren":
				return ec.fieldContext_FlowZone_cardChildren(ctx, field)
			case "zoneChildren":
				return ec.fieldContext_FlowZone_zoneChildren(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FlowZone", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Deck_ignoredCards(ctx context.Context, field graphql.CollectedField, obj *model.MtgDeck) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Deck_ignoredCards(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IgnoredCards, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Deck_ignoredCards(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Deck",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_DeckCard_card(ctx context.Context, field graphql.CollectedField, obj *model.MtgDeckCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_DeckCard_card(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Card, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.MtgCard)
	fc.Result = res
	return ec.marshalNMTG_Card2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgCard(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_DeckCard_card(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_DeckCard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ID":
				return ec.fieldContext_MTG_Card_ID(ctx, field)
			case "layout":
				return ec.fieldContext_MTG_Card_layout(ctx, field)
			case "CMC":
				return ec.fieldContext_MTG_Card_CMC(ctx, field)
			case "colorIdentity":
				return ec.fieldContext_MTG_Card_colorIdentity(ctx, field)
			case "colorIndicator":
				return ec.fieldContext_MTG_Card_colorIndicator(ctx, field)
			case "colors":
				return ec.fieldContext_MTG_Card_colors(ctx, field)
			case "EDHRecRank":
				return ec.fieldContext_MTG_Card_EDHRecRank(ctx, field)
			case "keywords":
				return ec.fieldContext_MTG_Card_keywords(ctx, field)
			case "loyalty":
				return ec.fieldContext_MTG_Card_loyalty(ctx, field)
			case "manaCost":
				return ec.fieldContext_MTG_Card_manaCost(ctx, field)
			case "name":
				return ec.fieldContext_MTG_Card_name(ctx, field)
			case "oracleText":
				return ec.fieldContext_MTG_Card_oracleText(ctx, field)
			case "power":
				return ec.fieldContext_MTG_Card_power(ctx, field)
			case "producedMana":
				return ec.fieldContext_MTG_Card_producedMana(ctx, field)
			case "toughness":
				return ec.fieldContext_MTG_Card_toughness(ctx, field)
			case "typeLine":
				return ec.fieldContext_MTG_Card_typeLine(ctx, field)
			case "versions":
				return ec.fieldContext_MTG_Card_versions(ctx, field)
			case "myRating":
				return ec.fieldContext_MTG_Card_myRating(ctx, field)
			case "cardTags":
				return ec.fieldContext_MTG_Card_cardTags(ctx, field)
			case "deckTags":
				return ec.fieldContext_MTG_Card_deckTags(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MTG_Card", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_DeckCard_selectedVersionID(ctx context.Context, field graphql.CollectedField, obj *model.MtgDeckCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_DeckCard_selectedVersionID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SelectedVersionID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_DeckCard_selectedVersionID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_DeckCard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_DeckCard_count(ctx context.Context, field graphql.CollectedField, obj *model.MtgDeckCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_DeckCard_count(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_DeckCard_count(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_DeckCard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_DeckCard_position(ctx context.Context, field graphql.CollectedField, obj *model.MtgDeckCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_DeckCard_position(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Position, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Position)
	fc.Result = res
	return ec.marshalNPosition2ᚖmagicᚑhelperᚋgraphᚋmodelᚐPosition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_DeckCard_position(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_DeckCard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "x":
				return ec.fieldContext_Position_x(ctx, field)
			case "y":
				return ec.fieldContext_Position_y(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Position", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_DeckCard_mainOrSide(ctx context.Context, field graphql.CollectedField, obj *model.MtgDeckCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_DeckCard_mainOrSide(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MainOrSide, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.MainOrSide)
	fc.Result = res
	return ec.marshalNMainOrSide2magicᚑhelperᚋgraphᚋmodelᚐMainOrSide(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_DeckCard_mainOrSide(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_DeckCard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type MainOrSide does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_DeckCard_deckCardType(ctx context.Context, field graphql.CollectedField, obj *model.MtgDeckCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_DeckCard_deckCardType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeckCardType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.MtgDeckCardType)
	fc.Result = res
	return ec.marshalNMTG_DeckCardType2magicᚑhelperᚋgraphᚋmodelᚐMtgDeckCardType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_DeckCard_deckCardType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_DeckCard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type MTG_DeckCardType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_DeckCard_phantoms(ctx context.Context, field graphql.CollectedField, obj *model.MtgDeckCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_DeckCard_phantoms(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Phantoms, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Phantom)
	fc.Result = res
	return ec.marshalNPhantom2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐPhantomᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_DeckCard_phantoms(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_DeckCard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "position":
				return ec.fieldContext_Phantom_position(ctx, field)
			case "ID":
				return ec.fieldContext_Phantom_ID(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Phantom", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_DeckCard_Dashboard_card(ctx context.Context, field graphql.CollectedField, obj *model.MtgDeckCardDashboard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_DeckCard_Dashboard_card(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Card, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.MtgCardDashboard)
	fc.Result = res
	return ec.marshalNMTG_Card_Dashboard2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgCardDashboard(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_DeckCard_Dashboard_card(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_DeckCard_Dashboard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ID":
				return ec.fieldContext_MTG_Card_Dashboard_ID(ctx, field)
			case "versions":
				return ec.fieldContext_MTG_Card_Dashboard_versions(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MTG_Card_Dashboard", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_DeckCard_Dashboard_selectedVersionID(ctx context.Context, field graphql.CollectedField, obj *model.MtgDeckCardDashboard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_DeckCard_Dashboard_selectedVersionID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SelectedVersionID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_DeckCard_Dashboard_selectedVersionID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_DeckCard_Dashboard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_DeckDashboard_ID(ctx context.Context, field graphql.CollectedField, obj *model.MtgDeckDashboard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_DeckDashboard_ID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_DeckDashboard_ID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_DeckDashboard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_DeckDashboard_name(ctx context.Context, field graphql.CollectedField, obj *model.MtgDeckDashboard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_DeckDashboard_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_DeckDashboard_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_DeckDashboard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_DeckDashboard_cardFrontImage(ctx context.Context, field graphql.CollectedField, obj *model.MtgDeckDashboard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_DeckDashboard_cardFrontImage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CardFrontImage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.MtgDeckCardFrontImage)
	fc.Result = res
	return ec.marshalOMTG_Deck_CardFrontImage2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgDeckCardFrontImage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_DeckDashboard_cardFrontImage(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_DeckDashboard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cardID":
				return ec.fieldContext_MTG_Deck_CardFrontImage_cardID(ctx, field)
			case "versionID":
				return ec.fieldContext_MTG_Deck_CardFrontImage_versionID(ctx, field)
			case "image":
				return ec.fieldContext_MTG_Deck_CardFrontImage_image(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MTG_Deck_CardFrontImage", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_DeckDashboard_cards(ctx context.Context, field graphql.CollectedField, obj *model.MtgDeckDashboard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_DeckDashboard_cards(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cards, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.MtgDeckCardDashboard)
	fc.Result = res
	return ec.marshalNMTG_DeckCard_Dashboard2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgDeckCardDashboardᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_DeckDashboard_cards(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_DeckDashboard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "card":
				return ec.fieldContext_MTG_DeckCard_Dashboard_card(ctx, field)
			case "selectedVersionID":
				return ec.fieldContext_MTG_DeckCard_Dashboard_selectedVersionID(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MTG_DeckCard_Dashboard", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Deck_CardFrontImage_cardID(ctx context.Context, field graphql.CollectedField, obj *model.MtgDeckCardFrontImage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Deck_CardFrontImage_cardID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CardID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Deck_CardFrontImage_cardID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Deck_CardFrontImage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Deck_CardFrontImage_versionID(ctx context.Context, field graphql.CollectedField, obj *model.MtgDeckCardFrontImage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Deck_CardFrontImage_versionID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.VersionID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Deck_CardFrontImage_versionID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Deck_CardFrontImage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Deck_CardFrontImage_image(ctx context.Context, field graphql.CollectedField, obj *model.MtgDeckCardFrontImage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Deck_CardFrontImage_image(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Image, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Deck_CardFrontImage_image(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Deck_CardFrontImage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Filter_CardTypes_cardType(ctx context.Context, field graphql.CollectedField, obj *model.MtgFilterCardTypes) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Filter_CardTypes_cardType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CardType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Filter_CardTypes_cardType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Filter_CardTypes",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Filter_CardTypes_subtypes(ctx context.Context, field graphql.CollectedField, obj *model.MtgFilterCardTypes) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Filter_CardTypes_subtypes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Subtypes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Filter_CardTypes_subtypes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Filter_CardTypes",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Filter_Entries_types(ctx context.Context, field graphql.CollectedField, obj *model.MtgFilterEntries) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Filter_Entries_types(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.MtgFilterCardTypes)
	fc.Result = res
	return ec.marshalNMTG_Filter_CardTypes2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterCardTypesᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Filter_Entries_types(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Filter_Entries",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cardType":
				return ec.fieldContext_MTG_Filter_CardTypes_cardType(ctx, field)
			case "subtypes":
				return ec.fieldContext_MTG_Filter_CardTypes_subtypes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MTG_Filter_CardTypes", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Filter_Entries_expansions(ctx context.Context, field graphql.CollectedField, obj *model.MtgFilterEntries) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Filter_Entries_expansions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Expansions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.MtgFilterExpansion)
	fc.Result = res
	return ec.marshalNMTG_Filter_Expansion2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterExpansionᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Filter_Entries_expansions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Filter_Entries",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "set":
				return ec.fieldContext_MTG_Filter_Expansion_set(ctx, field)
			case "setName":
				return ec.fieldContext_MTG_Filter_Expansion_setName(ctx, field)
			case "releasedAt":
				return ec.fieldContext_MTG_Filter_Expansion_releasedAt(ctx, field)
			case "imageURL":
				return ec.fieldContext_MTG_Filter_Expansion_imageURL(ctx, field)
			case "setType":
				return ec.fieldContext_MTG_Filter_Expansion_setType(ctx, field)
			case "games":
				return ec.fieldContext_MTG_Filter_Expansion_games(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MTG_Filter_Expansion", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Filter_Entries_legality(ctx context.Context, field graphql.CollectedField, obj *model.MtgFilterEntries) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Filter_Entries_legality(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Legality, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.MtgFilterLegality)
	fc.Result = res
	return ec.marshalNMTG_Filter_Legality2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterLegality(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Filter_Entries_legality(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Filter_Entries",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "formats":
				return ec.fieldContext_MTG_Filter_Legality_formats(ctx, field)
			case "legalityValues":
				return ec.fieldContext_MTG_Filter_Legality_legalityValues(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MTG_Filter_Legality", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Filter_Entries_layouts(ctx context.Context, field graphql.CollectedField, obj *model.MtgFilterEntries) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Filter_Entries_layouts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Layouts, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.MtgLayout)
	fc.Result = res
	return ec.marshalNMTG_Layout2ᚕmagicᚑhelperᚋgraphᚋmodelᚐMtgLayoutᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Filter_Entries_layouts(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Filter_Entries",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type MTG_Layout does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Filter_Expansion_set(ctx context.Context, field graphql.CollectedField, obj *model.MtgFilterExpansion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Filter_Expansion_set(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Set, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Filter_Expansion_set(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Filter_Expansion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Filter_Expansion_setName(ctx context.Context, field graphql.CollectedField, obj *model.MtgFilterExpansion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Filter_Expansion_setName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SetName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Filter_Expansion_setName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Filter_Expansion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Filter_Expansion_releasedAt(ctx context.Context, field graphql.CollectedField, obj *model.MtgFilterExpansion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Filter_Expansion_releasedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ReleasedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Filter_Expansion_releasedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Filter_Expansion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Filter_Expansion_imageURL(ctx context.Context, field graphql.CollectedField, obj *model.MtgFilterExpansion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Filter_Expansion_imageURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ImageURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Filter_Expansion_imageURL(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Filter_Expansion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Filter_Expansion_setType(ctx context.Context, field graphql.CollectedField, obj *model.MtgFilterExpansion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Filter_Expansion_setType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SetType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Filter_Expansion_setType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Filter_Expansion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Filter_Expansion_games(ctx context.Context, field graphql.CollectedField, obj *model.MtgFilterExpansion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Filter_Expansion_games(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Games, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.MtgGame)
	fc.Result = res
	return ec.marshalNMTG_Game2ᚕmagicᚑhelperᚋgraphᚋmodelᚐMtgGameᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Filter_Expansion_games(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Filter_Expansion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type MTG_Game does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Filter_Legality_formats(ctx context.Context, field graphql.CollectedField, obj *model.MtgFilterLegality) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Filter_Legality_formats(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Formats, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Filter_Legality_formats(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Filter_Legality",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Filter_Legality_legalityValues(ctx context.Context, field graphql.CollectedField, obj *model.MtgFilterLegality) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Filter_Legality_legalityValues(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LegalityValues, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Filter_Legality_legalityValues(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Filter_Legality",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Filter_Search_pagedCards(ctx context.Context, field graphql.CollectedField, obj *model.MtgFilterSearch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Filter_Search_pagedCards(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PagedCards, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.MtgCard)
	fc.Result = res
	return ec.marshalNMTG_Card2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgCardᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Filter_Search_pagedCards(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Filter_Search",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ID":
				return ec.fieldContext_MTG_Card_ID(ctx, field)
			case "layout":
				return ec.fieldContext_MTG_Card_layout(ctx, field)
			case "CMC":
				return ec.fieldContext_MTG_Card_CMC(ctx, field)
			case "colorIdentity":
				return ec.fieldContext_MTG_Card_colorIdentity(ctx, field)
			case "colorIndicator":
				return ec.fieldContext_MTG_Card_colorIndicator(ctx, field)
			case "colors":
				return ec.fieldContext_MTG_Card_colors(ctx, field)
			case "EDHRecRank":
				return ec.fieldContext_MTG_Card_EDHRecRank(ctx, field)
			case "keywords":
				return ec.fieldContext_MTG_Card_keywords(ctx, field)
			case "loyalty":
				return ec.fieldContext_MTG_Card_loyalty(ctx, field)
			case "manaCost":
				return ec.fieldContext_MTG_Card_manaCost(ctx, field)
			case "name":
				return ec.fieldContext_MTG_Card_name(ctx, field)
			case "oracleText":
				return ec.fieldContext_MTG_Card_oracleText(ctx, field)
			case "power":
				return ec.fieldContext_MTG_Card_power(ctx, field)
			case "producedMana":
				return ec.fieldContext_MTG_Card_producedMana(ctx, field)
			case "toughness":
				return ec.fieldContext_MTG_Card_toughness(ctx, field)
			case "typeLine":
				return ec.fieldContext_MTG_Card_typeLine(ctx, field)
			case "versions":
				return ec.fieldContext_MTG_Card_versions(ctx, field)
			case "myRating":
				return ec.fieldContext_MTG_Card_myRating(ctx, field)
			case "cardTags":
				return ec.fieldContext_MTG_Card_cardTags(ctx, field)
			case "deckTags":
				return ec.fieldContext_MTG_Card_deckTags(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MTG_Card", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Filter_Search_totalCount(ctx context.Context, field graphql.CollectedField, obj *model.MtgFilterSearch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Filter_Search_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Filter_Search_totalCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Filter_Search",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Image_artCrop(ctx context.Context, field graphql.CollectedField, obj *model.MtgImage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Image_artCrop(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ArtCrop, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Image_artCrop(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Image",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Image_borderCrop(ctx context.Context, field graphql.CollectedField, obj *model.MtgImage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Image_borderCrop(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BorderCrop, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Image_borderCrop(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Image",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Image_large(ctx context.Context, field graphql.CollectedField, obj *model.MtgImage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Image_large(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Large, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Image_large(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Image",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Image_normal(ctx context.Context, field graphql.CollectedField, obj *model.MtgImage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Image_normal(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Normal, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Image_normal(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Image",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Image_PNG(ctx context.Context, field graphql.CollectedField, obj *model.MtgImage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Image_PNG(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Png, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Image_PNG(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Image",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Image_small(ctx context.Context, field graphql.CollectedField, obj *model.MtgImage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Image_small(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Small, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Image_small(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Image",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createMTGDeck(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createMTGDeck(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateMTGDeck(rctx, fc.Args["input"].(model.MtgCreateDeckInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Response)
	fc.Result = res
	return ec.marshalNResponse2ᚖmagicᚑhelperᚋgraphᚋmodelᚐResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createMTGDeck(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "status":
				return ec.fieldContext_Response_status(ctx, field)
			case "message":
				return ec.fieldContext_Response_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Response", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createMTGDeck_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteMTGDeck(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteMTGDeck(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteMTGDeck(rctx, fc.Args["input"].(model.MtgDeleteDeckInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Response)
	fc.Result = res
	return ec.marshalNResponse2ᚖmagicᚑhelperᚋgraphᚋmodelᚐResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteMTGDeck(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "status":
				return ec.fieldContext_Response_status(ctx, field)
			case "message":
				return ec.fieldContext_Response_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Response", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteMTGDeck_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateMTGDeck(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateMTGDeck(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateMTGDeck(rctx, fc.Args["input"].(model.MtgUpdateDeckInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Response)
	fc.Result = res
	return ec.marshalNResponse2ᚖmagicᚑhelperᚋgraphᚋmodelᚐResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateMTGDeck(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "status":
				return ec.fieldContext_Response_status(ctx, field)
			case "message":
				return ec.fieldContext_Response_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Response", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateMTGDeck_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_saveMTGDeckAsCopy(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_saveMTGDeckAsCopy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().SaveMTGDeckAsCopy(rctx, fc.Args["input"].(model.MtgUpdateDeckInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Response)
	fc.Result = res
	return ec.marshalNResponse2ᚖmagicᚑhelperᚋgraphᚋmodelᚐResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_saveMTGDeckAsCopy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "status":
				return ec.fieldContext_Response_status(ctx, field)
			case "message":
				return ec.fieldContext_Response_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Response", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_saveMTGDeckAsCopy_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createMTGCardPackage(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createMTGCardPackage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateMTGCardPackage(rctx, fc.Args["input"].(model.MtgCreateCardPackageInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Response)
	fc.Result = res
	return ec.marshalNResponse2ᚖmagicᚑhelperᚋgraphᚋmodelᚐResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createMTGCardPackage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "status":
				return ec.fieldContext_Response_status(ctx, field)
			case "message":
				return ec.fieldContext_Response_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Response", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createMTGCardPackage_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteMTGCardPackage(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteMTGCardPackage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteMTGCardPackage(rctx, fc.Args["input"].(model.MtgDeleteCardPackageInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Response)
	fc.Result = res
	return ec.marshalNResponse2ᚖmagicᚑhelperᚋgraphᚋmodelᚐResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteMTGCardPackage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "status":
				return ec.fieldContext_Response_status(ctx, field)
			case "message":
				return ec.fieldContext_Response_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Response", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteMTGCardPackage_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_addMTGCardToCardPackage(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_addMTGCardToCardPackage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().AddMTGCardToCardPackage(rctx, fc.Args["input"].(model.MtgAddCardToCardPackageInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Response)
	fc.Result = res
	return ec.marshalNResponse2ᚖmagicᚑhelperᚋgraphᚋmodelᚐResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_addMTGCardToCardPackage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "status":
				return ec.fieldContext_Response_status(ctx, field)
			case "message":
				return ec.fieldContext_Response_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Response", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_addMTGCardToCardPackage_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_removeMTGCardFromCardPackage(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_removeMTGCardFromCardPackage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().RemoveMTGCardFromCardPackage(rctx, fc.Args["input"].(model.MtgRemoveCardFromCardPackageInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Response)
	fc.Result = res
	return ec.marshalNResponse2ᚖmagicᚑhelperᚋgraphᚋmodelᚐResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_removeMTGCardFromCardPackage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "status":
				return ec.fieldContext_Response_status(ctx, field)
			case "message":
				return ec.fieldContext_Response_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Response", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_removeMTGCardFromCardPackage_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createTag(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createTag(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateTag(rctx, fc.Args["input"].(model.CreateTagInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Response)
	fc.Result = res
	return ec.marshalNResponse2ᚖmagicᚑhelperᚋgraphᚋmodelᚐResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createTag(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "status":
				return ec.fieldContext_Response_status(ctx, field)
			case "message":
				return ec.fieldContext_Response_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Response", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createTag_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateTag(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateTag(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateTag(rctx, fc.Args["input"].(model.UpdateTagInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Response)
	fc.Result = res
	return ec.marshalNResponse2ᚖmagicᚑhelperᚋgraphᚋmodelᚐResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateTag(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "status":
				return ec.fieldContext_Response_status(ctx, field)
			case "message":
				return ec.fieldContext_Response_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Response", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateTag_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteTag(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteTag(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteTag(rctx, fc.Args["tagID"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Response)
	fc.Result = res
	return ec.marshalNResponse2ᚖmagicᚑhelperᚋgraphᚋmodelᚐResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteTag(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "status":
				return ec.fieldContext_Response_status(ctx, field)
			case "message":
				return ec.fieldContext_Response_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Response", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteTag_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_assignTag(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_assignTag(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().AssignTag(rctx, fc.Args["input"].(model.AssignTagInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Response)
	fc.Result = res
	return ec.marshalNResponse2ᚖmagicᚑhelperᚋgraphᚋmodelᚐResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_assignTag(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "status":
				return ec.fieldContext_Response_status(ctx, field)
			case "message":
				return ec.fieldContext_Response_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Response", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_assignTag_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_unassignTag(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_unassignTag(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UnassignTag(rctx, fc.Args["input"].(model.UnassignTagInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Response)
	fc.Result = res
	return ec.marshalNResponse2ᚖmagicᚑhelperᚋgraphᚋmodelᚐResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_unassignTag(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "status":
				return ec.fieldContext_Response_status(ctx, field)
			case "message":
				return ec.fieldContext_Response_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Response", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_unassignTag_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_rate(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_rate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().Rate(rctx, fc.Args["input"].(model.RateInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Response)
	fc.Result = res
	return ec.marshalNResponse2ᚖmagicᚑhelperᚋgraphᚋmodelᚐResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_rate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "status":
				return ec.fieldContext_Response_status(ctx, field)
			case "message":
				return ec.fieldContext_Response_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Response", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_rate_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_addIgnoredCard(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_addIgnoredCard(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().AddIgnoredCard(rctx, fc.Args["input"].(model.AddIgnoredCardInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Response)
	fc.Result = res
	return ec.marshalNResponse2ᚖmagicᚑhelperᚋgraphᚋmodelᚐResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_addIgnoredCard(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "status":
				return ec.fieldContext_Response_status(ctx, field)
			case "message":
				return ec.fieldContext_Response_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Response", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_addIgnoredCard_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_removeIgnoredCard(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_removeIgnoredCard(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().RemoveIgnoredCard(rctx, fc.Args["input"].(model.RemoveIgnoredCardInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Response)
	fc.Result = res
	return ec.marshalNResponse2ᚖmagicᚑhelperᚋgraphᚋmodelᚐResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_removeIgnoredCard(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "status":
				return ec.fieldContext_Response_status(ctx, field)
			case "message":
				return ec.fieldContext_Response_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Response", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_removeIgnoredCard_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Phantom_position(ctx context.Context, field graphql.CollectedField, obj *model.Phantom) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Phantom_position(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Position, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Position)
	fc.Result = res
	return ec.marshalNPosition2ᚖmagicᚑhelperᚋgraphᚋmodelᚐPosition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Phantom_position(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Phantom",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "x":
				return ec.fieldContext_Position_x(ctx, field)
			case "y":
				return ec.fieldContext_Position_y(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Position", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Phantom_ID(ctx context.Context, field graphql.CollectedField, obj *model.Phantom) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Phantom_ID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Phantom_ID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Phantom",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Position_x(ctx context.Context, field graphql.CollectedField, obj *model.Position) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Position_x(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.X, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Position_x(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Position",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Position_y(ctx context.Context, field graphql.CollectedField, obj *model.Position) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Position_y(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Y, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Position_y(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Position",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_getMTGCards(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getMTGCards(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GetMTGCards(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.MtgCard)
	fc.Result = res
	return ec.marshalNMTG_Card2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgCardᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getMTGCards(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ID":
				return ec.fieldContext_MTG_Card_ID(ctx, field)
			case "layout":
				return ec.fieldContext_MTG_Card_layout(ctx, field)
			case "CMC":
				return ec.fieldContext_MTG_Card_CMC(ctx, field)
			case "colorIdentity":
				return ec.fieldContext_MTG_Card_colorIdentity(ctx, field)
			case "colorIndicator":
				return ec.fieldContext_MTG_Card_colorIndicator(ctx, field)
			case "colors":
				return ec.fieldContext_MTG_Card_colors(ctx, field)
			case "EDHRecRank":
				return ec.fieldContext_MTG_Card_EDHRecRank(ctx, field)
			case "keywords":
				return ec.fieldContext_MTG_Card_keywords(ctx, field)
			case "loyalty":
				return ec.fieldContext_MTG_Card_loyalty(ctx, field)
			case "manaCost":
				return ec.fieldContext_MTG_Card_manaCost(ctx, field)
			case "name":
				return ec.fieldContext_MTG_Card_name(ctx, field)
			case "oracleText":
				return ec.fieldContext_MTG_Card_oracleText(ctx, field)
			case "power":
				return ec.fieldContext_MTG_Card_power(ctx, field)
			case "producedMana":
				return ec.fieldContext_MTG_Card_producedMana(ctx, field)
			case "toughness":
				return ec.fieldContext_MTG_Card_toughness(ctx, field)
			case "typeLine":
				return ec.fieldContext_MTG_Card_typeLine(ctx, field)
			case "versions":
				return ec.fieldContext_MTG_Card_versions(ctx, field)
			case "myRating":
				return ec.fieldContext_MTG_Card_myRating(ctx, field)
			case "cardTags":
				return ec.fieldContext_MTG_Card_cardTags(ctx, field)
			case "deckTags":
				return ec.fieldContext_MTG_Card_deckTags(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MTG_Card", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_getMTGCardsFiltered(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getMTGCardsFiltered(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GetMTGCardsFiltered(rctx, fc.Args["filter"].(model.MtgFilterSearchInput), fc.Args["pagination"].(model.MtgFilterPaginationInput), fc.Args["sort"].([]*model.MtgFilterSortInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.MtgFilterSearch)
	fc.Result = res
	return ec.marshalNMTG_Filter_Search2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterSearch(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getMTGCardsFiltered(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pagedCards":
				return ec.fieldContext_MTG_Filter_Search_pagedCards(ctx, field)
			case "totalCount":
				return ec.fieldContext_MTG_Filter_Search_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MTG_Filter_Search", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getMTGCardsFiltered_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_getMTGFilters(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getMTGFilters(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GetMTGFilters(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.MtgFilterEntries)
	fc.Result = res
	return ec.marshalNMTG_Filter_Entries2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterEntries(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getMTGFilters(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "types":
				return ec.fieldContext_MTG_Filter_Entries_types(ctx, field)
			case "expansions":
				return ec.fieldContext_MTG_Filter_Entries_expansions(ctx, field)
			case "legality":
				return ec.fieldContext_MTG_Filter_Entries_legality(ctx, field)
			case "layouts":
				return ec.fieldContext_MTG_Filter_Entries_layouts(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MTG_Filter_Entries", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_getMTGDecks(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getMTGDecks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GetMTGDecks(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.MtgDeckDashboard)
	fc.Result = res
	return ec.marshalNMTG_DeckDashboard2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgDeckDashboardᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getMTGDecks(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ID":
				return ec.fieldContext_MTG_DeckDashboard_ID(ctx, field)
			case "name":
				return ec.fieldContext_MTG_DeckDashboard_name(ctx, field)
			case "cardFrontImage":
				return ec.fieldContext_MTG_DeckDashboard_cardFrontImage(ctx, field)
			case "cards":
				return ec.fieldContext_MTG_DeckDashboard_cards(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MTG_DeckDashboard", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_getMTGDeck(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getMTGDeck(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GetMTGDeck(rctx, fc.Args["deckID"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.MtgDeck)
	fc.Result = res
	return ec.marshalNMTG_Deck2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgDeck(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getMTGDeck(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ID":
				return ec.fieldContext_MTG_Deck_ID(ctx, field)
			case "name":
				return ec.fieldContext_MTG_Deck_name(ctx, field)
			case "cardFrontImage":
				return ec.fieldContext_MTG_Deck_cardFrontImage(ctx, field)
			case "cards":
				return ec.fieldContext_MTG_Deck_cards(ctx, field)
			case "zones":
				return ec.fieldContext_MTG_Deck_zones(ctx, field)
			case "ignoredCards":
				return ec.fieldContext_MTG_Deck_ignoredCards(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MTG_Deck", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getMTGDeck_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_getMTGCardPackages(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getMTGCardPackages(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GetMTGCardPackages(rctx, fc.Args["cardPackageID"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.MtgCardPackage)
	fc.Result = res
	return ec.marshalNMTG_CardPackage2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgCardPackageᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getMTGCardPackages(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ID":
				return ec.fieldContext_MTG_CardPackage_ID(ctx, field)
			case "name":
				return ec.fieldContext_MTG_CardPackage_name(ctx, field)
			case "cards":
				return ec.fieldContext_MTG_CardPackage_cards(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MTG_CardPackage", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getMTGCardPackages_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_tags(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_tags(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Tags(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.Tag)
	fc.Result = res
	return ec.marshalNTag2ᚕmagicᚑhelperᚋgraphᚋmodelᚐTagᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_tags(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_cardTags(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_cardTags(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().CardTags(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.CardTag)
	fc.Result = res
	return ec.marshalNCardTag2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐCardTagᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_cardTags(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ID":
				return ec.fieldContext_CardTag_ID(ctx, field)
			case "name":
				return ec.fieldContext_CardTag_name(ctx, field)
			case "description":
				return ec.fieldContext_CardTag_description(ctx, field)
			case "myRating":
				return ec.fieldContext_CardTag_myRating(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CardTag", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_deckTags(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_deckTags(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().DeckTags(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.DeckTag)
	fc.Result = res
	return ec.marshalNDeckTag2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐDeckTagᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_deckTags(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ID":
				return ec.fieldContext_DeckTag_ID(ctx, field)
			case "name":
				return ec.fieldContext_DeckTag_name(ctx, field)
			case "description":
				return ec.fieldContext_DeckTag_description(ctx, field)
			case "myRating":
				return ec.fieldContext_DeckTag_myRating(ctx, field)
			case "colors":
				return ec.fieldContext_DeckTag_colors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DeckTag", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_tag(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_tag(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Tag(rctx, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.Tag)
	fc.Result = res
	return ec.marshalOTag2magicᚑhelperᚋgraphᚋmodelᚐTag(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_tag(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_tag_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(fc.Args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query___type_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___schema(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	fc.Result = res
	return ec.marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___schema(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "description":
				return ec.fieldContext___Schema_description(ctx, field)
			case "types":
				return ec.fieldContext___Schema_types(ctx, field)
			case "queryType":
				return ec.fieldContext___Schema_queryType(ctx, field)
			case "mutationType":
				return ec.fieldContext___Schema_mutationType(ctx, field)
			case "subscriptionType":
				return ec.fieldContext___Schema_subscriptionType(ctx, field)
			case "directives":
				return ec.fieldContext___Schema_directives(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Schema", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Response_status(ctx context.Context, field graphql.CollectedField, obj *model.Response) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Response_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Response_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Response",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Response_message(ctx context.Context, field graphql.CollectedField, obj *model.Response) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Response_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Response_message(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Response",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_ID(ctx context.Context, field graphql.CollectedField, obj *model.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_ID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_ID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserRating_user(ctx context.Context, field graphql.CollectedField, obj *model.UserRating) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserRating_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.User, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.User)
	fc.Result = res
	return ec.marshalNUser2ᚖmagicᚑhelperᚋgraphᚋmodelᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserRating_user(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserRating",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ID":
				return ec.fieldContext_User_ID(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserRating_value(ctx context.Context, field graphql.CollectedField, obj *model.UserRating) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserRating_value(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Value, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserRating_value(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserRating",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_locations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalN__DirectiveLocation2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_locations(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __DirectiveLocation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___InputValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___InputValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Directive_args_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_isRepeatable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRepeatable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_isRepeatable(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_isDeprecated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_deprecationReason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___InputValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___InputValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Field_args_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_isDeprecated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_deprecationReason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_defaultValue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_defaultValue(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_isDeprecated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_deprecationReason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_types(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_types(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_queryType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_queryType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_mutationType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_mutationType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_subscriptionType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_subscriptionType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_directives(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	fc.Result = res
	return ec.marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirectiveᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_directives(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Directive_name(ctx, field)
			case "description":
				return ec.fieldContext___Directive_description(ctx, field)
			case "locations":
				return ec.fieldContext___Directive_locations(ctx, field)
			case "args":
				return ec.fieldContext___Directive_args(ctx, field)
			case "isRepeatable":
				return ec.fieldContext___Directive_isRepeatable(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Directive", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_kind(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalN__TypeKind2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_kind(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __TypeKind does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_fields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	fc.Result = res
	return ec.marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐFieldᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_fields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Field_name(ctx, field)
			case "description":
				return ec.fieldContext___Field_description(ctx, field)
			case "args":
				return ec.fieldContext___Field_args(ctx, field)
			case "type":
				return ec.fieldContext___Field_type(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___Field_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___Field_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Field", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_fields_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_interfaces(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_interfaces(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_possibleTypes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_possibleTypes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_enumValues(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	fc.Result = res
	return ec.marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_enumValues(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___EnumValue_name(ctx, field)
			case "description":
				return ec.fieldContext___EnumValue_description(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___EnumValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___EnumValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __EnumValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_enumValues_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_inputFields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_inputFields(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___InputValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___InputValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_ofType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_ofType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_specifiedByURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpecifiedByURL(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_specifiedByURL(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_isOneOf(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_isOneOf(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsOneOf(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_isOneOf(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputAddIgnoredCardInput(ctx context.Context, obj any) (model.AddIgnoredCardInput, error) {
	var it model.AddIgnoredCardInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"cardID", "deckID"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "cardID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cardID"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CardID = data
		case "deckID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deckID"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeckID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputAssignTagInput(ctx context.Context, obj any) (model.AssignTagInput, error) {
	var it model.AssignTagInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"tagID", "cardID"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "tagID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tagID"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TagID = data
		case "cardID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cardID"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CardID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateTagInput(ctx context.Context, obj any) (model.CreateTagInput, error) {
	var it model.CreateTagInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"type", "name", "description", "colors", "cardID"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalNTagType2magicᚑhelperᚋgraphᚋmodelᚐTagType(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "colors":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("colors"))
			data, err := ec.unmarshalOMTG_Color2ᚕmagicᚑhelperᚋgraphᚋmodelᚐMtgColorᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Colors = data
		case "cardID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cardID"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.CardID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputFlowZoneInput(ctx context.Context, obj any) (model.FlowZoneInput, error) {
	var it model.FlowZoneInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"ID", "name", "position", "width", "height", "cardChildren", "zoneChildren"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "ID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ID"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "position":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("position"))
			data, err := ec.unmarshalNPositionInput2ᚖmagicᚑhelperᚋgraphᚋmodelᚐPositionInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Position = data
		case "width":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("width"))
			data, err := ec.unmarshalNFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Width = data
		case "height":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("height"))
			data, err := ec.unmarshalNFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Height = data
		case "cardChildren":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cardChildren"))
			data, err := ec.unmarshalNID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.CardChildren = data
		case "zoneChildren":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("zoneChildren"))
			data, err := ec.unmarshalNID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.ZoneChildren = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMTG_AddCardToCardPackageInput(ctx context.Context, obj any) (model.MtgAddCardToCardPackageInput, error) {
	var it model.MtgAddCardToCardPackageInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"cardPackageID", "card", "count"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "cardPackageID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cardPackageID"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CardPackageID = data
		case "card":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("card"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Card = data
		case "count":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("count"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Count = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMTG_CardPackageCardInput(ctx context.Context, obj any) (model.MtgCardPackageCardInput, error) {
	var it model.MtgCardPackageCardInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"card", "selectedVersionID", "count", "mainOrSide"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "card":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("card"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Card = data
		case "selectedVersionID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("selectedVersionID"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.SelectedVersionID = data
		case "count":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("count"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Count = data
		case "mainOrSide":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("mainOrSide"))
			data, err := ec.unmarshalNMainOrSide2magicᚑhelperᚋgraphᚋmodelᚐMainOrSide(ctx, v)
			if err != nil {
				return it, err
			}
			it.MainOrSide = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMTG_CreateCardPackageInput(ctx context.Context, obj any) (model.MtgCreateCardPackageInput, error) {
	var it model.MtgCreateCardPackageInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMTG_CreateDeckInput(ctx context.Context, obj any) (model.MtgCreateDeckInput, error) {
	var it model.MtgCreateDeckInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMTG_DeckCardFrontImageInput(ctx context.Context, obj any) (model.MtgDeckCardFrontImageInput, error) {
	var it model.MtgDeckCardFrontImageInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"cardID", "versionID"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "cardID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cardID"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CardID = data
		case "versionID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("versionID"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.VersionID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMTG_DeckCardInput(ctx context.Context, obj any) (model.MtgDeckCardInput, error) {
	var it model.MtgDeckCardInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"ID", "card", "selectedVersionID", "count", "position", "mainOrSide", "deckCardType", "phantoms"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "ID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ID"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "card":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("card"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Card = data
		case "selectedVersionID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("selectedVersionID"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.SelectedVersionID = data
		case "count":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("count"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Count = data
		case "position":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("position"))
			data, err := ec.unmarshalNPositionInput2ᚖmagicᚑhelperᚋgraphᚋmodelᚐPositionInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Position = data
		case "mainOrSide":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("mainOrSide"))
			data, err := ec.unmarshalNMainOrSide2magicᚑhelperᚋgraphᚋmodelᚐMainOrSide(ctx, v)
			if err != nil {
				return it, err
			}
			it.MainOrSide = data
		case "deckCardType":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deckCardType"))
			data, err := ec.unmarshalNMTG_DeckCardType2magicᚑhelperᚋgraphᚋmodelᚐMtgDeckCardType(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeckCardType = data
		case "phantoms":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("phantoms"))
			data, err := ec.unmarshalNPhantomInput2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐPhantomInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Phantoms = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMTG_DeleteCardPackageInput(ctx context.Context, obj any) (model.MtgDeleteCardPackageInput, error) {
	var it model.MtgDeleteCardPackageInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"cardPackageID"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "cardPackageID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cardPackageID"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CardPackageID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMTG_DeleteDeckInput(ctx context.Context, obj any) (model.MtgDeleteDeckInput, error) {
	var it model.MtgDeleteDeckInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"deckID"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "deckID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deckID"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeckID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMTG_Filter_CardTypeInput(ctx context.Context, obj any) (model.MtgFilterCardTypeInput, error) {
	var it model.MtgFilterCardTypeInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"cardType", "value"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "cardType":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cardType"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CardType = data
		case "value":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalNTernaryBoolean2magicᚑhelperᚋgraphᚋmodelᚐTernaryBoolean(ctx, v)
			if err != nil {
				return it, err
			}
			it.Value = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMTG_Filter_ColorInput(ctx context.Context, obj any) (model.MtgFilterColorInput, error) {
	var it model.MtgFilterColorInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"color", "value"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "color":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("color"))
			data, err := ec.unmarshalNMTG_Color2magicᚑhelperᚋgraphᚋmodelᚐMtgColor(ctx, v)
			if err != nil {
				return it, err
			}
			it.Color = data
		case "value":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalNTernaryBoolean2magicᚑhelperᚋgraphᚋmodelᚐTernaryBoolean(ctx, v)
			if err != nil {
				return it, err
			}
			it.Value = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMTG_Filter_GameInput(ctx context.Context, obj any) (model.MtgFilterGameInput, error) {
	var it model.MtgFilterGameInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"game", "value"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "game":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("game"))
			data, err := ec.unmarshalNMTG_Game2magicᚑhelperᚋgraphᚋmodelᚐMtgGame(ctx, v)
			if err != nil {
				return it, err
			}
			it.Game = data
		case "value":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalNTernaryBoolean2magicᚑhelperᚋgraphᚋmodelᚐTernaryBoolean(ctx, v)
			if err != nil {
				return it, err
			}
			it.Value = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMTG_Filter_LayoutInput(ctx context.Context, obj any) (model.MtgFilterLayoutInput, error) {
	var it model.MtgFilterLayoutInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"layout", "value"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "layout":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("layout"))
			data, err := ec.unmarshalNMTG_Layout2magicᚑhelperᚋgraphᚋmodelᚐMtgLayout(ctx, v)
			if err != nil {
				return it, err
			}
			it.Layout = data
		case "value":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalNTernaryBoolean2magicᚑhelperᚋgraphᚋmodelᚐTernaryBoolean(ctx, v)
			if err != nil {
				return it, err
			}
			it.Value = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMTG_Filter_LegalityEntryInput(ctx context.Context, obj any) (model.MtgFilterLegalityEntryInput, error) {
	var it model.MtgFilterLegalityEntryInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"legalityValue", "value"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "legalityValue":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("legalityValue"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LegalityValue = data
		case "value":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalNTernaryBoolean2magicᚑhelperᚋgraphᚋmodelᚐTernaryBoolean(ctx, v)
			if err != nil {
				return it, err
			}
			it.Value = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMTG_Filter_LegalityInput(ctx context.Context, obj any) (model.MtgFilterLegalityInput, error) {
	var it model.MtgFilterLegalityInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"format", "legalityEntries"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "format":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("format"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Format = data
		case "legalityEntries":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("legalityEntries"))
			data, err := ec.unmarshalNMTG_Filter_LegalityEntryInput2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterLegalityEntryInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.LegalityEntries = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMTG_Filter_ManaCostInput(ctx context.Context, obj any) (model.MtgFilterManaCostInput, error) {
	var it model.MtgFilterManaCostInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"manaCost", "value"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "manaCost":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("manaCost"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ManaCost = data
		case "value":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalNTernaryBoolean2magicᚑhelperᚋgraphᚋmodelᚐTernaryBoolean(ctx, v)
			if err != nil {
				return it, err
			}
			it.Value = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMTG_Filter_PaginationInput(ctx context.Context, obj any) (model.MtgFilterPaginationInput, error) {
	var it model.MtgFilterPaginationInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"page", "pageSize"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "page":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("page"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Page = data
		case "pageSize":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pageSize"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.PageSize = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMTG_Filter_RarityInput(ctx context.Context, obj any) (model.MtgFilterRarityInput, error) {
	var it model.MtgFilterRarityInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"rarity", "value"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "rarity":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rarity"))
			data, err := ec.unmarshalNMTG_Rarity2magicᚑhelperᚋgraphᚋmodelᚐMtgRarity(ctx, v)
			if err != nil {
				return it, err
			}
			it.Rarity = data
		case "value":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalNTernaryBoolean2magicᚑhelperᚋgraphᚋmodelᚐTernaryBoolean(ctx, v)
			if err != nil {
				return it, err
			}
			it.Value = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMTG_Filter_RatingInput(ctx context.Context, obj any) (model.MtgFilterRatingInput, error) {
	var it model.MtgFilterRatingInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"min", "max"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "min":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("min"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Min = data
		case "max":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("max"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Max = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMTG_Filter_SearchInput(ctx context.Context, obj any) (model.MtgFilterSearchInput, error) {
	var it model.MtgFilterSearchInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"searchString", "rarity", "color", "multiColor", "manaCosts", "cardTypes", "subtypes", "sets", "legalities", "layouts", "games", "hideIgnored", "tags", "rating", "commander", "deckID", "isSelectingCommander"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "searchString":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("searchString"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.SearchString = data
		case "rarity":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rarity"))
			data, err := ec.unmarshalNMTG_Filter_RarityInput2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterRarityInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Rarity = data
		case "color":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("color"))
			data, err := ec.unmarshalNMTG_Filter_ColorInput2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterColorInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Color = data
		case "multiColor":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("multiColor"))
			data, err := ec.unmarshalNTernaryBoolean2magicᚑhelperᚋgraphᚋmodelᚐTernaryBoolean(ctx, v)
			if err != nil {
				return it, err
			}
			it.MultiColor = data
		case "manaCosts":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("manaCosts"))
			data, err := ec.unmarshalNMTG_Filter_ManaCostInput2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterManaCostInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.ManaCosts = data
		case "cardTypes":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cardTypes"))
			data, err := ec.unmarshalNMTG_Filter_CardTypeInput2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterCardTypeInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.CardTypes = data
		case "subtypes":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subtypes"))
			data, err := ec.unmarshalNMTG_Filter_SubtypeInput2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterSubtypeInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Subtypes = data
		case "sets":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sets"))
			data, err := ec.unmarshalNMTG_Filter_SetInput2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterSetInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Sets = data
		case "legalities":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("legalities"))
			data, err := ec.unmarshalNMTG_Filter_LegalityInput2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterLegalityInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Legalities = data
		case "layouts":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("layouts"))
			data, err := ec.unmarshalNMTG_Filter_LayoutInput2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterLayoutInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Layouts = data
		case "games":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("games"))
			data, err := ec.unmarshalNMTG_Filter_GameInput2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterGameInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Games = data
		case "hideIgnored":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hideIgnored"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HideIgnored = data
		case "tags":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tags"))
			data, err := ec.unmarshalNMTG_Filter_TagInput2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterTagInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Tags = data
		case "rating":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rating"))
			data, err := ec.unmarshalNMTG_Filter_RatingInput2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterRatingInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Rating = data
		case "commander":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("commander"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Commander = data
		case "deckID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deckID"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeckID = data
		case "isSelectingCommander":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isSelectingCommander"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsSelectingCommander = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMTG_Filter_SetInput(ctx context.Context, obj any) (model.MtgFilterSetInput, error) {
	var it model.MtgFilterSetInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"set", "value"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "set":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("set"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Set = data
		case "value":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalNTernaryBoolean2magicᚑhelperᚋgraphᚋmodelᚐTernaryBoolean(ctx, v)
			if err != nil {
				return it, err
			}
			it.Value = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMTG_Filter_SortInput(ctx context.Context, obj any) (model.MtgFilterSortInput, error) {
	var it model.MtgFilterSortInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"sortBy", "sortDirection", "enabled"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "sortBy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sortBy"))
			data, err := ec.unmarshalNMTG_Filter_SortBy2magicᚑhelperᚋgraphᚋmodelᚐMtgFilterSortBy(ctx, v)
			if err != nil {
				return it, err
			}
			it.SortBy = data
		case "sortDirection":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sortDirection"))
			data, err := ec.unmarshalNMTG_Filter_SortDirection2magicᚑhelperᚋgraphᚋmodelᚐMtgFilterSortDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.SortDirection = data
		case "enabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("enabled"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Enabled = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMTG_Filter_SubtypeInput(ctx context.Context, obj any) (model.MtgFilterSubtypeInput, error) {
	var it model.MtgFilterSubtypeInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"subtype", "value"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "subtype":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subtype"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Subtype = data
		case "value":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalNTernaryBoolean2magicᚑhelperᚋgraphᚋmodelᚐTernaryBoolean(ctx, v)
			if err != nil {
				return it, err
			}
			it.Value = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMTG_Filter_TagInput(ctx context.Context, obj any) (model.MtgFilterTagInput, error) {
	var it model.MtgFilterTagInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"tag", "value"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "tag":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tag"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Tag = data
		case "value":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalNTernaryBoolean2magicᚑhelperᚋgraphᚋmodelᚐTernaryBoolean(ctx, v)
			if err != nil {
				return it, err
			}
			it.Value = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMTG_RemoveCardFromCardPackageInput(ctx context.Context, obj any) (model.MtgRemoveCardFromCardPackageInput, error) {
	var it model.MtgRemoveCardFromCardPackageInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"cardPackageID", "card"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "cardPackageID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cardPackageID"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CardPackageID = data
		case "card":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("card"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Card = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMTG_UpdateDeckInput(ctx context.Context, obj any) (model.MtgUpdateDeckInput, error) {
	var it model.MtgUpdateDeckInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"deckID", "name", "cardFrontImage", "cards", "zones"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "deckID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deckID"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeckID = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "cardFrontImage":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cardFrontImage"))
			data, err := ec.unmarshalOMTG_DeckCardFrontImageInput2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgDeckCardFrontImageInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.CardFrontImage = data
		case "cards":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cards"))
			data, err := ec.unmarshalNMTG_DeckCardInput2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgDeckCardInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Cards = data
		case "zones":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("zones"))
			data, err := ec.unmarshalNFlowZoneInput2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐFlowZoneInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Zones = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPhantomInput(ctx context.Context, obj any) (model.PhantomInput, error) {
	var it model.PhantomInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"ID", "position"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "ID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ID"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "position":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("position"))
			data, err := ec.unmarshalNPositionInput2ᚖmagicᚑhelperᚋgraphᚋmodelᚐPositionInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Position = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPositionInput(ctx context.Context, obj any) (model.PositionInput, error) {
	var it model.PositionInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"x", "y"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "x":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("x"))
			data, err := ec.unmarshalNFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.X = data
		case "y":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("y"))
			data, err := ec.unmarshalNFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Y = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRateInput(ctx context.Context, obj any) (model.RateInput, error) {
	var it model.RateInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"entityID", "entityType", "value"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "entityID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("entityID"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.EntityID = data
		case "entityType":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("entityType"))
			data, err := ec.unmarshalNRatableEntityType2magicᚑhelperᚋgraphᚋmodelᚐRatableEntityType(ctx, v)
			if err != nil {
				return it, err
			}
			it.EntityType = data
		case "value":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Value = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRemoveIgnoredCardInput(ctx context.Context, obj any) (model.RemoveIgnoredCardInput, error) {
	var it model.RemoveIgnoredCardInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"cardID", "deckID"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "cardID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cardID"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CardID = data
		case "deckID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deckID"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeckID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUnassignTagInput(ctx context.Context, obj any) (model.UnassignTagInput, error) {
	var it model.UnassignTagInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"tagID", "cardID"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "tagID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tagID"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TagID = data
		case "cardID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cardID"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CardID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateTagInput(ctx context.Context, obj any) (model.UpdateTagInput, error) {
	var it model.UpdateTagInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"ID", "name", "description", "colors"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "ID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ID"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "colors":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("colors"))
			data, err := ec.unmarshalOMTG_Color2ᚕmagicᚑhelperᚋgraphᚋmodelᚐMtgColorᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Colors = data
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

func (ec *executionContext) _Tag(ctx context.Context, sel ast.SelectionSet, obj model.Tag) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.DeckTag:
		return ec._DeckTag(ctx, sel, &obj)
	case *model.DeckTag:
		if obj == nil {
			return graphql.Null
		}
		return ec._DeckTag(ctx, sel, obj)
	case model.CardTag:
		return ec._CardTag(ctx, sel, &obj)
	case *model.CardTag:
		if obj == nil {
			return graphql.Null
		}
		return ec._CardTag(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var cardTagImplementors = []string{"CardTag", "Tag"}

func (ec *executionContext) _CardTag(ctx context.Context, sel ast.SelectionSet, obj *model.CardTag) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, cardTagImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CardTag")
		case "ID":
			out.Values[i] = ec._CardTag_ID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._CardTag_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec._CardTag_description(ctx, field, obj)
		case "myRating":
			out.Values[i] = ec._CardTag_myRating(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var deckTagImplementors = []string{"DeckTag", "Tag"}

func (ec *executionContext) _DeckTag(ctx context.Context, sel ast.SelectionSet, obj *model.DeckTag) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, deckTagImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DeckTag")
		case "ID":
			out.Values[i] = ec._DeckTag_ID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._DeckTag_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec._DeckTag_description(ctx, field, obj)
		case "myRating":
			out.Values[i] = ec._DeckTag_myRating(ctx, field, obj)
		case "colors":
			out.Values[i] = ec._DeckTag_colors(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var flowZoneImplementors = []string{"FlowZone"}

func (ec *executionContext) _FlowZone(ctx context.Context, sel ast.SelectionSet, obj *model.FlowZone) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, flowZoneImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FlowZone")
		case "ID":
			out.Values[i] = ec._FlowZone_ID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._FlowZone_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "position":
			out.Values[i] = ec._FlowZone_position(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "width":
			out.Values[i] = ec._FlowZone_width(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "height":
			out.Values[i] = ec._FlowZone_height(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "cardChildren":
			out.Values[i] = ec._FlowZone_cardChildren(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "zoneChildren":
			out.Values[i] = ec._FlowZone_zoneChildren(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mTG_CardImplementors = []string{"MTG_Card"}

func (ec *executionContext) _MTG_Card(ctx context.Context, sel ast.SelectionSet, obj *model.MtgCard) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mTG_CardImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MTG_Card")
		case "ID":
			out.Values[i] = ec._MTG_Card_ID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "layout":
			out.Values[i] = ec._MTG_Card_layout(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "CMC":
			out.Values[i] = ec._MTG_Card_CMC(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "colorIdentity":
			out.Values[i] = ec._MTG_Card_colorIdentity(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "colorIndicator":
			out.Values[i] = ec._MTG_Card_colorIndicator(ctx, field, obj)
		case "colors":
			out.Values[i] = ec._MTG_Card_colors(ctx, field, obj)
		case "EDHRecRank":
			out.Values[i] = ec._MTG_Card_EDHRecRank(ctx, field, obj)
		case "keywords":
			out.Values[i] = ec._MTG_Card_keywords(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "loyalty":
			out.Values[i] = ec._MTG_Card_loyalty(ctx, field, obj)
		case "manaCost":
			out.Values[i] = ec._MTG_Card_manaCost(ctx, field, obj)
		case "name":
			out.Values[i] = ec._MTG_Card_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "oracleText":
			out.Values[i] = ec._MTG_Card_oracleText(ctx, field, obj)
		case "power":
			out.Values[i] = ec._MTG_Card_power(ctx, field, obj)
		case "producedMana":
			out.Values[i] = ec._MTG_Card_producedMana(ctx, field, obj)
		case "toughness":
			out.Values[i] = ec._MTG_Card_toughness(ctx, field, obj)
		case "typeLine":
			out.Values[i] = ec._MTG_Card_typeLine(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "versions":
			out.Values[i] = ec._MTG_Card_versions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "myRating":
			out.Values[i] = ec._MTG_Card_myRating(ctx, field, obj)
		case "cardTags":
			out.Values[i] = ec._MTG_Card_cardTags(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deckTags":
			out.Values[i] = ec._MTG_Card_deckTags(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mTG_CardFaceImplementors = []string{"MTG_CardFace"}

func (ec *executionContext) _MTG_CardFace(ctx context.Context, sel ast.SelectionSet, obj *model.MtgCardFace) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mTG_CardFaceImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MTG_CardFace")
		case "artist":
			out.Values[i] = ec._MTG_CardFace_artist(ctx, field, obj)
		case "CMC":
			out.Values[i] = ec._MTG_CardFace_CMC(ctx, field, obj)
		case "colorIndicator":
			out.Values[i] = ec._MTG_CardFace_colorIndicator(ctx, field, obj)
		case "colors":
			out.Values[i] = ec._MTG_CardFace_colors(ctx, field, obj)
		case "flavorText":
			out.Values[i] = ec._MTG_CardFace_flavorText(ctx, field, obj)
		case "imageUris":
			out.Values[i] = ec._MTG_CardFace_imageUris(ctx, field, obj)
		case "layout":
			out.Values[i] = ec._MTG_CardFace_layout(ctx, field, obj)
		case "loyalty":
			out.Values[i] = ec._MTG_CardFace_loyalty(ctx, field, obj)
		case "manaCost":
			out.Values[i] = ec._MTG_CardFace_manaCost(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._MTG_CardFace_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "oracleText":
			out.Values[i] = ec._MTG_CardFace_oracleText(ctx, field, obj)
		case "power":
			out.Values[i] = ec._MTG_CardFace_power(ctx, field, obj)
		case "toughness":
			out.Values[i] = ec._MTG_CardFace_toughness(ctx, field, obj)
		case "typeLine":
			out.Values[i] = ec._MTG_CardFace_typeLine(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mTG_CardFace_DashboardImplementors = []string{"MTG_CardFace_Dashboard"}

func (ec *executionContext) _MTG_CardFace_Dashboard(ctx context.Context, sel ast.SelectionSet, obj *model.MtgCardFaceDashboard) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mTG_CardFace_DashboardImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MTG_CardFace_Dashboard")
		case "imageUris":
			out.Values[i] = ec._MTG_CardFace_Dashboard_imageUris(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mTG_CardPackageImplementors = []string{"MTG_CardPackage"}

func (ec *executionContext) _MTG_CardPackage(ctx context.Context, sel ast.SelectionSet, obj *model.MtgCardPackage) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mTG_CardPackageImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MTG_CardPackage")
		case "ID":
			out.Values[i] = ec._MTG_CardPackage_ID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._MTG_CardPackage_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "cards":
			out.Values[i] = ec._MTG_CardPackage_cards(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mTG_CardPackageCardImplementors = []string{"MTG_CardPackageCard"}

func (ec *executionContext) _MTG_CardPackageCard(ctx context.Context, sel ast.SelectionSet, obj *model.MtgCardPackageCard) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mTG_CardPackageCardImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MTG_CardPackageCard")
		case "card":
			out.Values[i] = ec._MTG_CardPackageCard_card(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "selectedVersionID":
			out.Values[i] = ec._MTG_CardPackageCard_selectedVersionID(ctx, field, obj)
		case "count":
			out.Values[i] = ec._MTG_CardPackageCard_count(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "mainOrSide":
			out.Values[i] = ec._MTG_CardPackageCard_mainOrSide(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mTG_CardVersionImplementors = []string{"MTG_CardVersion"}

func (ec *executionContext) _MTG_CardVersion(ctx context.Context, sel ast.SelectionSet, obj *model.MtgCardVersion) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mTG_CardVersionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MTG_CardVersion")
		case "ID":
			out.Values[i] = ec._MTG_CardVersion_ID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isDefault":
			out.Values[i] = ec._MTG_CardVersion_isDefault(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isAlchemy":
			out.Values[i] = ec._MTG_CardVersion_isAlchemy(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "artist":
			out.Values[i] = ec._MTG_CardVersion_artist(ctx, field, obj)
		case "lang":
			out.Values[i] = ec._MTG_CardVersion_lang(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "flavorName":
			out.Values[i] = ec._MTG_CardVersion_flavorName(ctx, field, obj)
		case "flavorText":
			out.Values[i] = ec._MTG_CardVersion_flavorText(ctx, field, obj)
		case "cardFaces":
			out.Values[i] = ec._MTG_CardVersion_cardFaces(ctx, field, obj)
		case "legalities":
			out.Values[i] = ec._MTG_CardVersion_legalities(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "games":
			out.Values[i] = ec._MTG_CardVersion_games(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "imageUris":
			out.Values[i] = ec._MTG_CardVersion_imageUris(ctx, field, obj)
		case "rarity":
			out.Values[i] = ec._MTG_CardVersion_rarity(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "releasedAt":
			out.Values[i] = ec._MTG_CardVersion_releasedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "reprint":
			out.Values[i] = ec._MTG_CardVersion_reprint(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "setName":
			out.Values[i] = ec._MTG_CardVersion_setName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "setType":
			out.Values[i] = ec._MTG_CardVersion_setType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "set":
			out.Values[i] = ec._MTG_CardVersion_set(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "setID":
			out.Values[i] = ec._MTG_CardVersion_setID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "variation":
			out.Values[i] = ec._MTG_CardVersion_variation(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "variationOf":
			out.Values[i] = ec._MTG_CardVersion_variationOf(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mTG_CardVersion_DashboardImplementors = []string{"MTG_CardVersion_Dashboard"}

func (ec *executionContext) _MTG_CardVersion_Dashboard(ctx context.Context, sel ast.SelectionSet, obj *model.MtgCardVersionDashboard) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mTG_CardVersion_DashboardImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MTG_CardVersion_Dashboard")
		case "ID":
			out.Values[i] = ec._MTG_CardVersion_Dashboard_ID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isDefault":
			out.Values[i] = ec._MTG_CardVersion_Dashboard_isDefault(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isAlchemy":
			out.Values[i] = ec._MTG_CardVersion_Dashboard_isAlchemy(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "cardFaces":
			out.Values[i] = ec._MTG_CardVersion_Dashboard_cardFaces(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "imageUris":
			out.Values[i] = ec._MTG_CardVersion_Dashboard_imageUris(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mTG_Card_DashboardImplementors = []string{"MTG_Card_Dashboard"}

func (ec *executionContext) _MTG_Card_Dashboard(ctx context.Context, sel ast.SelectionSet, obj *model.MtgCardDashboard) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mTG_Card_DashboardImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MTG_Card_Dashboard")
		case "ID":
			out.Values[i] = ec._MTG_Card_Dashboard_ID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "versions":
			out.Values[i] = ec._MTG_Card_Dashboard_versions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mTG_DeckImplementors = []string{"MTG_Deck"}

func (ec *executionContext) _MTG_Deck(ctx context.Context, sel ast.SelectionSet, obj *model.MtgDeck) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mTG_DeckImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MTG_Deck")
		case "ID":
			out.Values[i] = ec._MTG_Deck_ID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._MTG_Deck_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "cardFrontImage":
			out.Values[i] = ec._MTG_Deck_cardFrontImage(ctx, field, obj)
		case "cards":
			out.Values[i] = ec._MTG_Deck_cards(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "zones":
			out.Values[i] = ec._MTG_Deck_zones(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "ignoredCards":
			out.Values[i] = ec._MTG_Deck_ignoredCards(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mTG_DeckCardImplementors = []string{"MTG_DeckCard"}

func (ec *executionContext) _MTG_DeckCard(ctx context.Context, sel ast.SelectionSet, obj *model.MtgDeckCard) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mTG_DeckCardImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MTG_DeckCard")
		case "card":
			out.Values[i] = ec._MTG_DeckCard_card(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "selectedVersionID":
			out.Values[i] = ec._MTG_DeckCard_selectedVersionID(ctx, field, obj)
		case "count":
			out.Values[i] = ec._MTG_DeckCard_count(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "position":
			out.Values[i] = ec._MTG_DeckCard_position(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "mainOrSide":
			out.Values[i] = ec._MTG_DeckCard_mainOrSide(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deckCardType":
			out.Values[i] = ec._MTG_DeckCard_deckCardType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "phantoms":
			out.Values[i] = ec._MTG_DeckCard_phantoms(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mTG_DeckCard_DashboardImplementors = []string{"MTG_DeckCard_Dashboard"}

func (ec *executionContext) _MTG_DeckCard_Dashboard(ctx context.Context, sel ast.SelectionSet, obj *model.MtgDeckCardDashboard) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mTG_DeckCard_DashboardImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MTG_DeckCard_Dashboard")
		case "card":
			out.Values[i] = ec._MTG_DeckCard_Dashboard_card(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "selectedVersionID":
			out.Values[i] = ec._MTG_DeckCard_Dashboard_selectedVersionID(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mTG_DeckDashboardImplementors = []string{"MTG_DeckDashboard"}

func (ec *executionContext) _MTG_DeckDashboard(ctx context.Context, sel ast.SelectionSet, obj *model.MtgDeckDashboard) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mTG_DeckDashboardImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MTG_DeckDashboard")
		case "ID":
			out.Values[i] = ec._MTG_DeckDashboard_ID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._MTG_DeckDashboard_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "cardFrontImage":
			out.Values[i] = ec._MTG_DeckDashboard_cardFrontImage(ctx, field, obj)
		case "cards":
			out.Values[i] = ec._MTG_DeckDashboard_cards(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mTG_Deck_CardFrontImageImplementors = []string{"MTG_Deck_CardFrontImage"}

func (ec *executionContext) _MTG_Deck_CardFrontImage(ctx context.Context, sel ast.SelectionSet, obj *model.MtgDeckCardFrontImage) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mTG_Deck_CardFrontImageImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MTG_Deck_CardFrontImage")
		case "cardID":
			out.Values[i] = ec._MTG_Deck_CardFrontImage_cardID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "versionID":
			out.Values[i] = ec._MTG_Deck_CardFrontImage_versionID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "image":
			out.Values[i] = ec._MTG_Deck_CardFrontImage_image(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mTG_Filter_CardTypesImplementors = []string{"MTG_Filter_CardTypes"}

func (ec *executionContext) _MTG_Filter_CardTypes(ctx context.Context, sel ast.SelectionSet, obj *model.MtgFilterCardTypes) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mTG_Filter_CardTypesImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MTG_Filter_CardTypes")
		case "cardType":
			out.Values[i] = ec._MTG_Filter_CardTypes_cardType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "subtypes":
			out.Values[i] = ec._MTG_Filter_CardTypes_subtypes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mTG_Filter_EntriesImplementors = []string{"MTG_Filter_Entries"}

func (ec *executionContext) _MTG_Filter_Entries(ctx context.Context, sel ast.SelectionSet, obj *model.MtgFilterEntries) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mTG_Filter_EntriesImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MTG_Filter_Entries")
		case "types":
			out.Values[i] = ec._MTG_Filter_Entries_types(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "expansions":
			out.Values[i] = ec._MTG_Filter_Entries_expansions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "legality":
			out.Values[i] = ec._MTG_Filter_Entries_legality(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "layouts":
			out.Values[i] = ec._MTG_Filter_Entries_layouts(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mTG_Filter_ExpansionImplementors = []string{"MTG_Filter_Expansion"}

func (ec *executionContext) _MTG_Filter_Expansion(ctx context.Context, sel ast.SelectionSet, obj *model.MtgFilterExpansion) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mTG_Filter_ExpansionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MTG_Filter_Expansion")
		case "set":
			out.Values[i] = ec._MTG_Filter_Expansion_set(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "setName":
			out.Values[i] = ec._MTG_Filter_Expansion_setName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "releasedAt":
			out.Values[i] = ec._MTG_Filter_Expansion_releasedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "imageURL":
			out.Values[i] = ec._MTG_Filter_Expansion_imageURL(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "setType":
			out.Values[i] = ec._MTG_Filter_Expansion_setType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "games":
			out.Values[i] = ec._MTG_Filter_Expansion_games(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mTG_Filter_LegalityImplementors = []string{"MTG_Filter_Legality"}

func (ec *executionContext) _MTG_Filter_Legality(ctx context.Context, sel ast.SelectionSet, obj *model.MtgFilterLegality) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mTG_Filter_LegalityImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MTG_Filter_Legality")
		case "formats":
			out.Values[i] = ec._MTG_Filter_Legality_formats(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "legalityValues":
			out.Values[i] = ec._MTG_Filter_Legality_legalityValues(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mTG_Filter_SearchImplementors = []string{"MTG_Filter_Search"}

func (ec *executionContext) _MTG_Filter_Search(ctx context.Context, sel ast.SelectionSet, obj *model.MtgFilterSearch) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mTG_Filter_SearchImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MTG_Filter_Search")
		case "pagedCards":
			out.Values[i] = ec._MTG_Filter_Search_pagedCards(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._MTG_Filter_Search_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mTG_ImageImplementors = []string{"MTG_Image"}

func (ec *executionContext) _MTG_Image(ctx context.Context, sel ast.SelectionSet, obj *model.MtgImage) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mTG_ImageImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MTG_Image")
		case "artCrop":
			out.Values[i] = ec._MTG_Image_artCrop(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "borderCrop":
			out.Values[i] = ec._MTG_Image_borderCrop(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "large":
			out.Values[i] = ec._MTG_Image_large(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "normal":
			out.Values[i] = ec._MTG_Image_normal(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "PNG":
			out.Values[i] = ec._MTG_Image_PNG(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "small":
			out.Values[i] = ec._MTG_Image_small(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mutationImplementors = []string{"Mutation"}

func (ec *executionContext) _Mutation(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mutationImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Mutation",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mutation")
		case "createMTGDeck":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createMTGDeck(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteMTGDeck":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteMTGDeck(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateMTGDeck":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateMTGDeck(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "saveMTGDeckAsCopy":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_saveMTGDeckAsCopy(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createMTGCardPackage":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createMTGCardPackage(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteMTGCardPackage":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteMTGCardPackage(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "addMTGCardToCardPackage":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_addMTGCardToCardPackage(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "removeMTGCardFromCardPackage":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_removeMTGCardFromCardPackage(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createTag":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createTag(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateTag":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateTag(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteTag":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteTag(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "assignTag":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_assignTag(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "unassignTag":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_unassignTag(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "rate":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_rate(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "addIgnoredCard":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_addIgnoredCard(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "removeIgnoredCard":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_removeIgnoredCard(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var phantomImplementors = []string{"Phantom"}

func (ec *executionContext) _Phantom(ctx context.Context, sel ast.SelectionSet, obj *model.Phantom) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, phantomImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Phantom")
		case "position":
			out.Values[i] = ec._Phantom_position(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "ID":
			out.Values[i] = ec._Phantom_ID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var positionImplementors = []string{"Position"}

func (ec *executionContext) _Position(ctx context.Context, sel ast.SelectionSet, obj *model.Position) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, positionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Position")
		case "x":
			out.Values[i] = ec._Position_x(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "y":
			out.Values[i] = ec._Position_y(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "getMTGCards":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getMTGCards(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getMTGCardsFiltered":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getMTGCardsFiltered(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getMTGFilters":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getMTGFilters(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getMTGDecks":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getMTGDecks(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getMTGDeck":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getMTGDeck(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getMTGCardPackages":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getMTGCardPackages(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "tags":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_tags(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "cardTags":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_cardTags(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "deckTags":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_deckTags(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "tag":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_tag(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "__type":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___type(ctx, field)
			})
		case "__schema":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___schema(ctx, field)
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var responseImplementors = []string{"Response"}

func (ec *executionContext) _Response(ctx context.Context, sel ast.SelectionSet, obj *model.Response) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, responseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Response")
		case "status":
			out.Values[i] = ec._Response_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._Response_message(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var userImplementors = []string{"User"}

func (ec *executionContext) _User(ctx context.Context, sel ast.SelectionSet, obj *model.User) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("User")
		case "ID":
			out.Values[i] = ec._User_ID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var userRatingImplementors = []string{"UserRating"}

func (ec *executionContext) _UserRating(ctx context.Context, sel ast.SelectionSet, obj *model.UserRating) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userRatingImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UserRating")
		case "user":
			out.Values[i] = ec._UserRating_user(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "value":
			out.Values[i] = ec._UserRating_value(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __DirectiveImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Directive_description(ctx, field, obj)
		case "locations":
			out.Values[i] = ec.___Directive_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "args":
			out.Values[i] = ec.___Directive_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isRepeatable":
			out.Values[i] = ec.___Directive_isRepeatable(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __EnumValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __FieldImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Field_description(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Field_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec.___Field_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __InputValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___InputValue_description(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___InputValue_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___InputValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___InputValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __SchemaImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "description":
			out.Values[i] = ec.___Schema_description(ctx, field, obj)
		case "types":
			out.Values[i] = ec.___Schema_types(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)
		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)
		case "directives":
			out.Values[i] = ec.___Schema_directives(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __TypeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec.___Type_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Type_description(ctx, field, obj)
		case "fields":
			out.Values[i] = ec.___Type_fields(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)
		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)
		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)
		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)
		case "ofType":
			out.Values[i] = ec.___Type_ofType(ctx, field, obj)
		case "specifiedByURL":
			out.Values[i] = ec.___Type_specifiedByURL(ctx, field, obj)
		case "isOneOf":
			out.Values[i] = ec.___Type_isOneOf(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) unmarshalNAddIgnoredCardInput2magicᚑhelperᚋgraphᚋmodelᚐAddIgnoredCardInput(ctx context.Context, v any) (model.AddIgnoredCardInput, error) {
	res, err := ec.unmarshalInputAddIgnoredCardInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNAssignTagInput2magicᚑhelperᚋgraphᚋmodelᚐAssignTagInput(ctx context.Context, v any) (model.AssignTagInput, error) {
	res, err := ec.unmarshalInputAssignTagInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v any) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNCardTag2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐCardTagᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.CardTag) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNCardTag2ᚖmagicᚑhelperᚋgraphᚋmodelᚐCardTag(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNCardTag2ᚖmagicᚑhelperᚋgraphᚋmodelᚐCardTag(ctx context.Context, sel ast.SelectionSet, v *model.CardTag) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CardTag(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCreateTagInput2magicᚑhelperᚋgraphᚋmodelᚐCreateTagInput(ctx context.Context, v any) (model.CreateTagInput, error) {
	res, err := ec.unmarshalInputCreateTagInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDeckTag2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐDeckTagᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.DeckTag) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNDeckTag2ᚖmagicᚑhelperᚋgraphᚋmodelᚐDeckTag(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNDeckTag2ᚖmagicᚑhelperᚋgraphᚋmodelᚐDeckTag(ctx context.Context, sel ast.SelectionSet, v *model.DeckTag) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._DeckTag(ctx, sel, v)
}

func (ec *executionContext) unmarshalNFloat2float64(ctx context.Context, v any) (float64, error) {
	res, err := graphql.UnmarshalFloatContext(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFloat2float64(ctx context.Context, sel ast.SelectionSet, v float64) graphql.Marshaler {
	res := graphql.MarshalFloatContext(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return graphql.WrapContextMarshaler(ctx, res)
}

func (ec *executionContext) marshalNFlowZone2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐFlowZoneᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.FlowZone) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNFlowZone2ᚖmagicᚑhelperᚋgraphᚋmodelᚐFlowZone(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNFlowZone2ᚖmagicᚑhelperᚋgraphᚋmodelᚐFlowZone(ctx context.Context, sel ast.SelectionSet, v *model.FlowZone) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._FlowZone(ctx, sel, v)
}

func (ec *executionContext) unmarshalNFlowZoneInput2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐFlowZoneInputᚄ(ctx context.Context, v any) ([]*model.FlowZoneInput, error) {
	var vSlice []any
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.FlowZoneInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNFlowZoneInput2ᚖmagicᚑhelperᚋgraphᚋmodelᚐFlowZoneInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNFlowZoneInput2ᚖmagicᚑhelperᚋgraphᚋmodelᚐFlowZoneInput(ctx context.Context, v any) (*model.FlowZoneInput, error) {
	res, err := ec.unmarshalInputFlowZoneInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNID2string(ctx context.Context, v any) (string, error) {
	res, err := graphql.UnmarshalID(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNID2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalID(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNID2ᚕstringᚄ(ctx context.Context, v any) ([]string, error) {
	var vSlice []any
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNID2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNID2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNID2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v any) (int, error) {
	res, err := graphql.UnmarshalInt(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	res := graphql.MarshalInt(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNMTG_AddCardToCardPackageInput2magicᚑhelperᚋgraphᚋmodelᚐMtgAddCardToCardPackageInput(ctx context.Context, v any) (model.MtgAddCardToCardPackageInput, error) {
	res, err := ec.unmarshalInputMTG_AddCardToCardPackageInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNMTG_Card2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgCardᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.MtgCard) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMTG_Card2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgCard(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNMTG_Card2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgCard(ctx context.Context, sel ast.SelectionSet, v *model.MtgCard) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._MTG_Card(ctx, sel, v)
}

func (ec *executionContext) marshalNMTG_CardFace2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgCardFace(ctx context.Context, sel ast.SelectionSet, v *model.MtgCardFace) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._MTG_CardFace(ctx, sel, v)
}

func (ec *executionContext) marshalNMTG_CardFace_Dashboard2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgCardFaceDashboardᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.MtgCardFaceDashboard) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMTG_CardFace_Dashboard2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgCardFaceDashboard(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNMTG_CardFace_Dashboard2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgCardFaceDashboard(ctx context.Context, sel ast.SelectionSet, v *model.MtgCardFaceDashboard) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._MTG_CardFace_Dashboard(ctx, sel, v)
}

func (ec *executionContext) marshalNMTG_CardPackage2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgCardPackageᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.MtgCardPackage) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMTG_CardPackage2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgCardPackage(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNMTG_CardPackage2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgCardPackage(ctx context.Context, sel ast.SelectionSet, v *model.MtgCardPackage) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._MTG_CardPackage(ctx, sel, v)
}

func (ec *executionContext) marshalNMTG_CardPackageCard2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgCardPackageCardᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.MtgCardPackageCard) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMTG_CardPackageCard2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgCardPackageCard(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNMTG_CardPackageCard2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgCardPackageCard(ctx context.Context, sel ast.SelectionSet, v *model.MtgCardPackageCard) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._MTG_CardPackageCard(ctx, sel, v)
}

func (ec *executionContext) marshalNMTG_CardVersion2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgCardVersionᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.MtgCardVersion) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMTG_CardVersion2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgCardVersion(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNMTG_CardVersion2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgCardVersion(ctx context.Context, sel ast.SelectionSet, v *model.MtgCardVersion) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._MTG_CardVersion(ctx, sel, v)
}

func (ec *executionContext) marshalNMTG_CardVersion_Dashboard2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgCardVersionDashboardᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.MtgCardVersionDashboard) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMTG_CardVersion_Dashboard2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgCardVersionDashboard(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNMTG_CardVersion_Dashboard2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgCardVersionDashboard(ctx context.Context, sel ast.SelectionSet, v *model.MtgCardVersionDashboard) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._MTG_CardVersion_Dashboard(ctx, sel, v)
}

func (ec *executionContext) marshalNMTG_Card_Dashboard2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgCardDashboard(ctx context.Context, sel ast.SelectionSet, v *model.MtgCardDashboard) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._MTG_Card_Dashboard(ctx, sel, v)
}

func (ec *executionContext) unmarshalNMTG_Color2magicᚑhelperᚋgraphᚋmodelᚐMtgColor(ctx context.Context, v any) (model.MtgColor, error) {
	var res model.MtgColor
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNMTG_Color2magicᚑhelperᚋgraphᚋmodelᚐMtgColor(ctx context.Context, sel ast.SelectionSet, v model.MtgColor) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNMTG_Color2ᚕmagicᚑhelperᚋgraphᚋmodelᚐMtgColorᚄ(ctx context.Context, v any) ([]model.MtgColor, error) {
	var vSlice []any
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]model.MtgColor, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNMTG_Color2magicᚑhelperᚋgraphᚋmodelᚐMtgColor(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNMTG_Color2ᚕmagicᚑhelperᚋgraphᚋmodelᚐMtgColorᚄ(ctx context.Context, sel ast.SelectionSet, v []model.MtgColor) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMTG_Color2magicᚑhelperᚋgraphᚋmodelᚐMtgColor(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNMTG_CreateCardPackageInput2magicᚑhelperᚋgraphᚋmodelᚐMtgCreateCardPackageInput(ctx context.Context, v any) (model.MtgCreateCardPackageInput, error) {
	res, err := ec.unmarshalInputMTG_CreateCardPackageInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNMTG_CreateDeckInput2magicᚑhelperᚋgraphᚋmodelᚐMtgCreateDeckInput(ctx context.Context, v any) (model.MtgCreateDeckInput, error) {
	res, err := ec.unmarshalInputMTG_CreateDeckInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNMTG_Deck2magicᚑhelperᚋgraphᚋmodelᚐMtgDeck(ctx context.Context, sel ast.SelectionSet, v model.MtgDeck) graphql.Marshaler {
	return ec._MTG_Deck(ctx, sel, &v)
}

func (ec *executionContext) marshalNMTG_Deck2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgDeck(ctx context.Context, sel ast.SelectionSet, v *model.MtgDeck) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._MTG_Deck(ctx, sel, v)
}

func (ec *executionContext) marshalNMTG_DeckCard2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgDeckCardᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.MtgDeckCard) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMTG_DeckCard2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgDeckCard(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNMTG_DeckCard2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgDeckCard(ctx context.Context, sel ast.SelectionSet, v *model.MtgDeckCard) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._MTG_DeckCard(ctx, sel, v)
}

func (ec *executionContext) unmarshalNMTG_DeckCardInput2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgDeckCardInputᚄ(ctx context.Context, v any) ([]*model.MtgDeckCardInput, error) {
	var vSlice []any
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.MtgDeckCardInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNMTG_DeckCardInput2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgDeckCardInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNMTG_DeckCardInput2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgDeckCardInput(ctx context.Context, v any) (*model.MtgDeckCardInput, error) {
	res, err := ec.unmarshalInputMTG_DeckCardInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNMTG_DeckCardType2magicᚑhelperᚋgraphᚋmodelᚐMtgDeckCardType(ctx context.Context, v any) (model.MtgDeckCardType, error) {
	var res model.MtgDeckCardType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNMTG_DeckCardType2magicᚑhelperᚋgraphᚋmodelᚐMtgDeckCardType(ctx context.Context, sel ast.SelectionSet, v model.MtgDeckCardType) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNMTG_DeckCard_Dashboard2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgDeckCardDashboardᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.MtgDeckCardDashboard) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMTG_DeckCard_Dashboard2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgDeckCardDashboard(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNMTG_DeckCard_Dashboard2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgDeckCardDashboard(ctx context.Context, sel ast.SelectionSet, v *model.MtgDeckCardDashboard) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._MTG_DeckCard_Dashboard(ctx, sel, v)
}

func (ec *executionContext) marshalNMTG_DeckDashboard2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgDeckDashboardᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.MtgDeckDashboard) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMTG_DeckDashboard2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgDeckDashboard(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNMTG_DeckDashboard2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgDeckDashboard(ctx context.Context, sel ast.SelectionSet, v *model.MtgDeckDashboard) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._MTG_DeckDashboard(ctx, sel, v)
}

func (ec *executionContext) unmarshalNMTG_DeleteCardPackageInput2magicᚑhelperᚋgraphᚋmodelᚐMtgDeleteCardPackageInput(ctx context.Context, v any) (model.MtgDeleteCardPackageInput, error) {
	res, err := ec.unmarshalInputMTG_DeleteCardPackageInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNMTG_DeleteDeckInput2magicᚑhelperᚋgraphᚋmodelᚐMtgDeleteDeckInput(ctx context.Context, v any) (model.MtgDeleteDeckInput, error) {
	res, err := ec.unmarshalInputMTG_DeleteDeckInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNMTG_Filter_CardTypeInput2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterCardTypeInputᚄ(ctx context.Context, v any) ([]*model.MtgFilterCardTypeInput, error) {
	var vSlice []any
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.MtgFilterCardTypeInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNMTG_Filter_CardTypeInput2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterCardTypeInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNMTG_Filter_CardTypeInput2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterCardTypeInput(ctx context.Context, v any) (*model.MtgFilterCardTypeInput, error) {
	res, err := ec.unmarshalInputMTG_Filter_CardTypeInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNMTG_Filter_CardTypes2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterCardTypesᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.MtgFilterCardTypes) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMTG_Filter_CardTypes2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterCardTypes(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNMTG_Filter_CardTypes2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterCardTypes(ctx context.Context, sel ast.SelectionSet, v *model.MtgFilterCardTypes) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._MTG_Filter_CardTypes(ctx, sel, v)
}

func (ec *executionContext) unmarshalNMTG_Filter_ColorInput2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterColorInputᚄ(ctx context.Context, v any) ([]*model.MtgFilterColorInput, error) {
	var vSlice []any
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.MtgFilterColorInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNMTG_Filter_ColorInput2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterColorInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNMTG_Filter_ColorInput2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterColorInput(ctx context.Context, v any) (*model.MtgFilterColorInput, error) {
	res, err := ec.unmarshalInputMTG_Filter_ColorInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNMTG_Filter_Entries2magicᚑhelperᚋgraphᚋmodelᚐMtgFilterEntries(ctx context.Context, sel ast.SelectionSet, v model.MtgFilterEntries) graphql.Marshaler {
	return ec._MTG_Filter_Entries(ctx, sel, &v)
}

func (ec *executionContext) marshalNMTG_Filter_Entries2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterEntries(ctx context.Context, sel ast.SelectionSet, v *model.MtgFilterEntries) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._MTG_Filter_Entries(ctx, sel, v)
}

func (ec *executionContext) marshalNMTG_Filter_Expansion2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterExpansionᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.MtgFilterExpansion) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMTG_Filter_Expansion2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterExpansion(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNMTG_Filter_Expansion2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterExpansion(ctx context.Context, sel ast.SelectionSet, v *model.MtgFilterExpansion) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._MTG_Filter_Expansion(ctx, sel, v)
}

func (ec *executionContext) unmarshalNMTG_Filter_GameInput2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterGameInputᚄ(ctx context.Context, v any) ([]*model.MtgFilterGameInput, error) {
	var vSlice []any
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.MtgFilterGameInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNMTG_Filter_GameInput2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterGameInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNMTG_Filter_GameInput2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterGameInput(ctx context.Context, v any) (*model.MtgFilterGameInput, error) {
	res, err := ec.unmarshalInputMTG_Filter_GameInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNMTG_Filter_LayoutInput2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterLayoutInputᚄ(ctx context.Context, v any) ([]*model.MtgFilterLayoutInput, error) {
	var vSlice []any
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.MtgFilterLayoutInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNMTG_Filter_LayoutInput2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterLayoutInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNMTG_Filter_LayoutInput2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterLayoutInput(ctx context.Context, v any) (*model.MtgFilterLayoutInput, error) {
	res, err := ec.unmarshalInputMTG_Filter_LayoutInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNMTG_Filter_Legality2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterLegality(ctx context.Context, sel ast.SelectionSet, v *model.MtgFilterLegality) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._MTG_Filter_Legality(ctx, sel, v)
}

func (ec *executionContext) unmarshalNMTG_Filter_LegalityEntryInput2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterLegalityEntryInputᚄ(ctx context.Context, v any) ([]*model.MtgFilterLegalityEntryInput, error) {
	var vSlice []any
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.MtgFilterLegalityEntryInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNMTG_Filter_LegalityEntryInput2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterLegalityEntryInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNMTG_Filter_LegalityEntryInput2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterLegalityEntryInput(ctx context.Context, v any) (*model.MtgFilterLegalityEntryInput, error) {
	res, err := ec.unmarshalInputMTG_Filter_LegalityEntryInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNMTG_Filter_LegalityInput2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterLegalityInputᚄ(ctx context.Context, v any) ([]*model.MtgFilterLegalityInput, error) {
	var vSlice []any
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.MtgFilterLegalityInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNMTG_Filter_LegalityInput2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterLegalityInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNMTG_Filter_LegalityInput2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterLegalityInput(ctx context.Context, v any) (*model.MtgFilterLegalityInput, error) {
	res, err := ec.unmarshalInputMTG_Filter_LegalityInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNMTG_Filter_ManaCostInput2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterManaCostInputᚄ(ctx context.Context, v any) ([]*model.MtgFilterManaCostInput, error) {
	var vSlice []any
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.MtgFilterManaCostInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNMTG_Filter_ManaCostInput2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterManaCostInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNMTG_Filter_ManaCostInput2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterManaCostInput(ctx context.Context, v any) (*model.MtgFilterManaCostInput, error) {
	res, err := ec.unmarshalInputMTG_Filter_ManaCostInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNMTG_Filter_PaginationInput2magicᚑhelperᚋgraphᚋmodelᚐMtgFilterPaginationInput(ctx context.Context, v any) (model.MtgFilterPaginationInput, error) {
	res, err := ec.unmarshalInputMTG_Filter_PaginationInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNMTG_Filter_RarityInput2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterRarityInputᚄ(ctx context.Context, v any) ([]*model.MtgFilterRarityInput, error) {
	var vSlice []any
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.MtgFilterRarityInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNMTG_Filter_RarityInput2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterRarityInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNMTG_Filter_RarityInput2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterRarityInput(ctx context.Context, v any) (*model.MtgFilterRarityInput, error) {
	res, err := ec.unmarshalInputMTG_Filter_RarityInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNMTG_Filter_RatingInput2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterRatingInput(ctx context.Context, v any) (*model.MtgFilterRatingInput, error) {
	res, err := ec.unmarshalInputMTG_Filter_RatingInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNMTG_Filter_Search2magicᚑhelperᚋgraphᚋmodelᚐMtgFilterSearch(ctx context.Context, sel ast.SelectionSet, v model.MtgFilterSearch) graphql.Marshaler {
	return ec._MTG_Filter_Search(ctx, sel, &v)
}

func (ec *executionContext) marshalNMTG_Filter_Search2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterSearch(ctx context.Context, sel ast.SelectionSet, v *model.MtgFilterSearch) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._MTG_Filter_Search(ctx, sel, v)
}

func (ec *executionContext) unmarshalNMTG_Filter_SearchInput2magicᚑhelperᚋgraphᚋmodelᚐMtgFilterSearchInput(ctx context.Context, v any) (model.MtgFilterSearchInput, error) {
	res, err := ec.unmarshalInputMTG_Filter_SearchInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNMTG_Filter_SetInput2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterSetInputᚄ(ctx context.Context, v any) ([]*model.MtgFilterSetInput, error) {
	var vSlice []any
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.MtgFilterSetInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNMTG_Filter_SetInput2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterSetInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNMTG_Filter_SetInput2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterSetInput(ctx context.Context, v any) (*model.MtgFilterSetInput, error) {
	res, err := ec.unmarshalInputMTG_Filter_SetInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNMTG_Filter_SortBy2magicᚑhelperᚋgraphᚋmodelᚐMtgFilterSortBy(ctx context.Context, v any) (model.MtgFilterSortBy, error) {
	var res model.MtgFilterSortBy
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNMTG_Filter_SortBy2magicᚑhelperᚋgraphᚋmodelᚐMtgFilterSortBy(ctx context.Context, sel ast.SelectionSet, v model.MtgFilterSortBy) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNMTG_Filter_SortDirection2magicᚑhelperᚋgraphᚋmodelᚐMtgFilterSortDirection(ctx context.Context, v any) (model.MtgFilterSortDirection, error) {
	var res model.MtgFilterSortDirection
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNMTG_Filter_SortDirection2magicᚑhelperᚋgraphᚋmodelᚐMtgFilterSortDirection(ctx context.Context, sel ast.SelectionSet, v model.MtgFilterSortDirection) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNMTG_Filter_SortInput2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterSortInputᚄ(ctx context.Context, v any) ([]*model.MtgFilterSortInput, error) {
	var vSlice []any
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.MtgFilterSortInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNMTG_Filter_SortInput2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterSortInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNMTG_Filter_SortInput2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterSortInput(ctx context.Context, v any) (*model.MtgFilterSortInput, error) {
	res, err := ec.unmarshalInputMTG_Filter_SortInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNMTG_Filter_SubtypeInput2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterSubtypeInputᚄ(ctx context.Context, v any) ([]*model.MtgFilterSubtypeInput, error) {
	var vSlice []any
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.MtgFilterSubtypeInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNMTG_Filter_SubtypeInput2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterSubtypeInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNMTG_Filter_SubtypeInput2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterSubtypeInput(ctx context.Context, v any) (*model.MtgFilterSubtypeInput, error) {
	res, err := ec.unmarshalInputMTG_Filter_SubtypeInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNMTG_Filter_TagInput2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterTagInputᚄ(ctx context.Context, v any) ([]*model.MtgFilterTagInput, error) {
	var vSlice []any
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.MtgFilterTagInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNMTG_Filter_TagInput2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterTagInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNMTG_Filter_TagInput2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgFilterTagInput(ctx context.Context, v any) (*model.MtgFilterTagInput, error) {
	res, err := ec.unmarshalInputMTG_Filter_TagInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNMTG_Game2magicᚑhelperᚋgraphᚋmodelᚐMtgGame(ctx context.Context, v any) (model.MtgGame, error) {
	var res model.MtgGame
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNMTG_Game2magicᚑhelperᚋgraphᚋmodelᚐMtgGame(ctx context.Context, sel ast.SelectionSet, v model.MtgGame) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNMTG_Game2ᚕmagicᚑhelperᚋgraphᚋmodelᚐMtgGameᚄ(ctx context.Context, v any) ([]model.MtgGame, error) {
	var vSlice []any
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]model.MtgGame, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNMTG_Game2magicᚑhelperᚋgraphᚋmodelᚐMtgGame(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNMTG_Game2ᚕmagicᚑhelperᚋgraphᚋmodelᚐMtgGameᚄ(ctx context.Context, sel ast.SelectionSet, v []model.MtgGame) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMTG_Game2magicᚑhelperᚋgraphᚋmodelᚐMtgGame(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNMTG_Layout2magicᚑhelperᚋgraphᚋmodelᚐMtgLayout(ctx context.Context, v any) (model.MtgLayout, error) {
	var res model.MtgLayout
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNMTG_Layout2magicᚑhelperᚋgraphᚋmodelᚐMtgLayout(ctx context.Context, sel ast.SelectionSet, v model.MtgLayout) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNMTG_Layout2ᚕmagicᚑhelperᚋgraphᚋmodelᚐMtgLayoutᚄ(ctx context.Context, v any) ([]model.MtgLayout, error) {
	var vSlice []any
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]model.MtgLayout, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNMTG_Layout2magicᚑhelperᚋgraphᚋmodelᚐMtgLayout(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNMTG_Layout2ᚕmagicᚑhelperᚋgraphᚋmodelᚐMtgLayoutᚄ(ctx context.Context, sel ast.SelectionSet, v []model.MtgLayout) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMTG_Layout2magicᚑhelperᚋgraphᚋmodelᚐMtgLayout(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNMTG_Rarity2magicᚑhelperᚋgraphᚋmodelᚐMtgRarity(ctx context.Context, v any) (model.MtgRarity, error) {
	var res model.MtgRarity
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNMTG_Rarity2magicᚑhelperᚋgraphᚋmodelᚐMtgRarity(ctx context.Context, sel ast.SelectionSet, v model.MtgRarity) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNMTG_RemoveCardFromCardPackageInput2magicᚑhelperᚋgraphᚋmodelᚐMtgRemoveCardFromCardPackageInput(ctx context.Context, v any) (model.MtgRemoveCardFromCardPackageInput, error) {
	res, err := ec.unmarshalInputMTG_RemoveCardFromCardPackageInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNMTG_UpdateDeckInput2magicᚑhelperᚋgraphᚋmodelᚐMtgUpdateDeckInput(ctx context.Context, v any) (model.MtgUpdateDeckInput, error) {
	res, err := ec.unmarshalInputMTG_UpdateDeckInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNMainOrSide2magicᚑhelperᚋgraphᚋmodelᚐMainOrSide(ctx context.Context, v any) (model.MainOrSide, error) {
	var res model.MainOrSide
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNMainOrSide2magicᚑhelperᚋgraphᚋmodelᚐMainOrSide(ctx context.Context, sel ast.SelectionSet, v model.MainOrSide) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNMap2map(ctx context.Context, v any) (map[string]any, error) {
	res, err := graphql.UnmarshalMap(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNMap2map(ctx context.Context, sel ast.SelectionSet, v map[string]any) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	res := graphql.MarshalMap(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNPhantom2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐPhantomᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.Phantom) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPhantom2ᚖmagicᚑhelperᚋgraphᚋmodelᚐPhantom(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNPhantom2ᚖmagicᚑhelperᚋgraphᚋmodelᚐPhantom(ctx context.Context, sel ast.SelectionSet, v *model.Phantom) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Phantom(ctx, sel, v)
}

func (ec *executionContext) unmarshalNPhantomInput2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐPhantomInputᚄ(ctx context.Context, v any) ([]*model.PhantomInput, error) {
	var vSlice []any
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.PhantomInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNPhantomInput2ᚖmagicᚑhelperᚋgraphᚋmodelᚐPhantomInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNPhantomInput2ᚖmagicᚑhelperᚋgraphᚋmodelᚐPhantomInput(ctx context.Context, v any) (*model.PhantomInput, error) {
	res, err := ec.unmarshalInputPhantomInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNPosition2ᚖmagicᚑhelperᚋgraphᚋmodelᚐPosition(ctx context.Context, sel ast.SelectionSet, v *model.Position) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Position(ctx, sel, v)
}

func (ec *executionContext) unmarshalNPositionInput2ᚖmagicᚑhelperᚋgraphᚋmodelᚐPositionInput(ctx context.Context, v any) (*model.PositionInput, error) {
	res, err := ec.unmarshalInputPositionInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNRatableEntityType2magicᚑhelperᚋgraphᚋmodelᚐRatableEntityType(ctx context.Context, v any) (model.RatableEntityType, error) {
	var res model.RatableEntityType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNRatableEntityType2magicᚑhelperᚋgraphᚋmodelᚐRatableEntityType(ctx context.Context, sel ast.SelectionSet, v model.RatableEntityType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNRateInput2magicᚑhelperᚋgraphᚋmodelᚐRateInput(ctx context.Context, v any) (model.RateInput, error) {
	res, err := ec.unmarshalInputRateInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNRemoveIgnoredCardInput2magicᚑhelperᚋgraphᚋmodelᚐRemoveIgnoredCardInput(ctx context.Context, v any) (model.RemoveIgnoredCardInput, error) {
	res, err := ec.unmarshalInputRemoveIgnoredCardInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNResponse2magicᚑhelperᚋgraphᚋmodelᚐResponse(ctx context.Context, sel ast.SelectionSet, v model.Response) graphql.Marshaler {
	return ec._Response(ctx, sel, &v)
}

func (ec *executionContext) marshalNResponse2ᚖmagicᚑhelperᚋgraphᚋmodelᚐResponse(ctx context.Context, sel ast.SelectionSet, v *model.Response) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Response(ctx, sel, v)
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v any) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNString2ᚕstringᚄ(ctx context.Context, v any) ([]string, error) {
	var vSlice []any
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNString2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNTag2magicᚑhelperᚋgraphᚋmodelᚐTag(ctx context.Context, sel ast.SelectionSet, v model.Tag) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Tag(ctx, sel, v)
}

func (ec *executionContext) marshalNTag2ᚕmagicᚑhelperᚋgraphᚋmodelᚐTagᚄ(ctx context.Context, sel ast.SelectionSet, v []model.Tag) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTag2magicᚑhelperᚋgraphᚋmodelᚐTag(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNTagType2magicᚑhelperᚋgraphᚋmodelᚐTagType(ctx context.Context, v any) (model.TagType, error) {
	var res model.TagType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTagType2magicᚑhelperᚋgraphᚋmodelᚐTagType(ctx context.Context, sel ast.SelectionSet, v model.TagType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNTernaryBoolean2magicᚑhelperᚋgraphᚋmodelᚐTernaryBoolean(ctx context.Context, v any) (model.TernaryBoolean, error) {
	var res model.TernaryBoolean
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTernaryBoolean2magicᚑhelperᚋgraphᚋmodelᚐTernaryBoolean(ctx context.Context, sel ast.SelectionSet, v model.TernaryBoolean) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNUnassignTagInput2magicᚑhelperᚋgraphᚋmodelᚐUnassignTagInput(ctx context.Context, v any) (model.UnassignTagInput, error) {
	res, err := ec.unmarshalInputUnassignTagInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateTagInput2magicᚑhelperᚋgraphᚋmodelᚐUpdateTagInput(ctx context.Context, v any) (model.UpdateTagInput, error) {
	res, err := ec.unmarshalInputUpdateTagInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUser2ᚖmagicᚑhelperᚋgraphᚋmodelᚐUser(ctx context.Context, sel ast.SelectionSet, v *model.User) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._User(ctx, sel, v)
}

func (ec *executionContext) marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirectiveᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v any) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2ᚕstringᚄ(ctx context.Context, v any) ([]string, error) {
	var vSlice []any
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v any) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v any) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	return res
}

func (ec *executionContext) unmarshalOBoolean2ᚖbool(ctx context.Context, v any) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalBoolean(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2ᚖbool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalBoolean(*v)
	return res
}

func (ec *executionContext) unmarshalOFloat2ᚖfloat64(ctx context.Context, v any) (*float64, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalFloatContext(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOFloat2ᚖfloat64(ctx context.Context, sel ast.SelectionSet, v *float64) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalFloatContext(*v)
	return graphql.WrapContextMarshaler(ctx, res)
}

func (ec *executionContext) unmarshalOID2ᚖstring(ctx context.Context, v any) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalID(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOID2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalID(*v)
	return res
}

func (ec *executionContext) unmarshalOInt2ᚖint(ctx context.Context, v any) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalInt(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2ᚖint(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalInt(*v)
	return res
}

func (ec *executionContext) marshalOMTG_CardFace2ᚕᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgCardFaceᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.MtgCardFace) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMTG_CardFace2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgCardFace(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOMTG_Color2ᚕmagicᚑhelperᚋgraphᚋmodelᚐMtgColorᚄ(ctx context.Context, v any) ([]model.MtgColor, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]model.MtgColor, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNMTG_Color2magicᚑhelperᚋgraphᚋmodelᚐMtgColor(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOMTG_Color2ᚕmagicᚑhelperᚋgraphᚋmodelᚐMtgColorᚄ(ctx context.Context, sel ast.SelectionSet, v []model.MtgColor) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMTG_Color2magicᚑhelperᚋgraphᚋmodelᚐMtgColor(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOMTG_DeckCardFrontImageInput2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgDeckCardFrontImageInput(ctx context.Context, v any) (*model.MtgDeckCardFrontImageInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputMTG_DeckCardFrontImageInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOMTG_Deck_CardFrontImage2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgDeckCardFrontImage(ctx context.Context, sel ast.SelectionSet, v *model.MtgDeckCardFrontImage) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._MTG_Deck_CardFrontImage(ctx, sel, v)
}

func (ec *executionContext) marshalOMTG_Image2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgImage(ctx context.Context, sel ast.SelectionSet, v *model.MtgImage) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._MTG_Image(ctx, sel, v)
}

func (ec *executionContext) unmarshalOMTG_Layout2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgLayout(ctx context.Context, v any) (*model.MtgLayout, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.MtgLayout)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOMTG_Layout2ᚖmagicᚑhelperᚋgraphᚋmodelᚐMtgLayout(ctx context.Context, sel ast.SelectionSet, v *model.MtgLayout) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOString2ᚕstringᚄ(ctx context.Context, v any) ([]string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOString2ᚖstring(ctx context.Context, v any) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalString(*v)
	return res
}

func (ec *executionContext) marshalOTag2magicᚑhelperᚋgraphᚋmodelᚐTag(ctx context.Context, sel ast.SelectionSet, v model.Tag) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Tag(ctx, sel, v)
}

func (ec *executionContext) marshalOUserRating2ᚖmagicᚑhelperᚋgraphᚋmodelᚐUserRating(ctx context.Context, sel ast.SelectionSet, v *model.UserRating) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._UserRating(ctx, sel, v)
}

func (ec *executionContext) marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐFieldᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************
