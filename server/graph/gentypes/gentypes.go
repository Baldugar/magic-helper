// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package gentypes

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"magic-helper/graph/model"
	"strconv"
	"sync"
	"sync/atomic"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Mutation() MutationResolver
	Query() QueryResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	CardTag struct {
		Description func(childComplexity int) int
		ID          func(childComplexity int) int
		MyRating    func(childComplexity int) int
		Name        func(childComplexity int) int
	}

	DeckTag struct {
		Colors      func(childComplexity int) int
		Description func(childComplexity int) int
		ID          func(childComplexity int) int
		MyRating    func(childComplexity int) int
		Name        func(childComplexity int) int
	}

	FlowZone struct {
		CardChildren func(childComplexity int) int
		Height       func(childComplexity int) int
		ID           func(childComplexity int) int
		Name         func(childComplexity int) int
		Position     func(childComplexity int) int
		Width        func(childComplexity int) int
		ZoneChildren func(childComplexity int) int
	}

	MTG_Card struct {
		CardTags       func(childComplexity int) int
		Cmc            func(childComplexity int) int
		ColorIdentity  func(childComplexity int) int
		ColorIndicator func(childComplexity int) int
		Colors         func(childComplexity int) int
		DeckTags       func(childComplexity int) int
		EDHRecRank     func(childComplexity int) int
		ID             func(childComplexity int) int
		Keywords       func(childComplexity int) int
		Layout         func(childComplexity int) int
		Loyalty        func(childComplexity int) int
		ManaCost       func(childComplexity int) int
		MyRating       func(childComplexity int) int
		Name           func(childComplexity int) int
		OracleText     func(childComplexity int) int
		Power          func(childComplexity int) int
		ProducedMana   func(childComplexity int) int
		Toughness      func(childComplexity int) int
		TypeLine       func(childComplexity int) int
		Versions       func(childComplexity int) int
	}

	MTG_CardFace struct {
		Artist         func(childComplexity int) int
		Cmc            func(childComplexity int) int
		ColorIndicator func(childComplexity int) int
		Colors         func(childComplexity int) int
		FlavorText     func(childComplexity int) int
		ImageUris      func(childComplexity int) int
		Layout         func(childComplexity int) int
		Loyalty        func(childComplexity int) int
		ManaCost       func(childComplexity int) int
		Name           func(childComplexity int) int
		OracleText     func(childComplexity int) int
		Power          func(childComplexity int) int
		Toughness      func(childComplexity int) int
		TypeLine       func(childComplexity int) int
	}

	MTG_CardFace_Dashboard struct {
		ImageUris func(childComplexity int) int
	}

	MTG_CardPackage struct {
		Cards func(childComplexity int) int
		ID    func(childComplexity int) int
		Name  func(childComplexity int) int
	}

	MTG_CardPackageCard struct {
		Card              func(childComplexity int) int
		Count             func(childComplexity int) int
		MainOrSide        func(childComplexity int) int
		SelectedVersionID func(childComplexity int) int
	}

	MTG_CardVersion struct {
		Artist      func(childComplexity int) int
		CardFaces   func(childComplexity int) int
		FlavorName  func(childComplexity int) int
		FlavorText  func(childComplexity int) int
		Games       func(childComplexity int) int
		ID          func(childComplexity int) int
		ImageUris   func(childComplexity int) int
		IsAlchemy   func(childComplexity int) int
		IsDefault   func(childComplexity int) int
		Lang        func(childComplexity int) int
		Legalities  func(childComplexity int) int
		Rarity      func(childComplexity int) int
		ReleasedAt  func(childComplexity int) int
		Reprint     func(childComplexity int) int
		Set         func(childComplexity int) int
		SetID       func(childComplexity int) int
		SetName     func(childComplexity int) int
		SetType     func(childComplexity int) int
		Variation   func(childComplexity int) int
		VariationOf func(childComplexity int) int
	}

	MTG_CardVersion_Dashboard struct {
		CardFaces func(childComplexity int) int
		ID        func(childComplexity int) int
		ImageUris func(childComplexity int) int
		IsAlchemy func(childComplexity int) int
		IsDefault func(childComplexity int) int
	}

	MTG_Card_Dashboard struct {
		ID       func(childComplexity int) int
		Versions func(childComplexity int) int
	}

	MTG_Deck struct {
		CardFrontImage func(childComplexity int) int
		Cards          func(childComplexity int) int
		ID             func(childComplexity int) int
		IgnoredCards   func(childComplexity int) int
		Name           func(childComplexity int) int
		Zones          func(childComplexity int) int
	}

	MTG_DeckCard struct {
		Card              func(childComplexity int) int
		Count             func(childComplexity int) int
		DeckCardType      func(childComplexity int) int
		MainOrSide        func(childComplexity int) int
		Phantoms          func(childComplexity int) int
		Position          func(childComplexity int) int
		SelectedVersionID func(childComplexity int) int
	}

	MTG_DeckCard_Dashboard struct {
		Card              func(childComplexity int) int
		SelectedVersionID func(childComplexity int) int
	}

	MTG_DeckDashboard struct {
		CardFrontImage func(childComplexity int) int
		Cards          func(childComplexity int) int
		ID             func(childComplexity int) int
		Name           func(childComplexity int) int
	}

	MTG_Deck_CardFrontImage struct {
		CardID    func(childComplexity int) int
		Image     func(childComplexity int) int
		VersionID func(childComplexity int) int
	}

	MTG_Filter_CardTypes struct {
		CardType func(childComplexity int) int
		Subtypes func(childComplexity int) int
	}

	MTG_Filter_Entries struct {
		Expansions func(childComplexity int) int
		Layouts    func(childComplexity int) int
		Legality   func(childComplexity int) int
		Types      func(childComplexity int) int
	}

	MTG_Filter_Expansion struct {
		Games      func(childComplexity int) int
		ImageURL   func(childComplexity int) int
		ReleasedAt func(childComplexity int) int
		Set        func(childComplexity int) int
		SetName    func(childComplexity int) int
		SetType    func(childComplexity int) int
	}

	MTG_Filter_Legality struct {
		Formats        func(childComplexity int) int
		LegalityValues func(childComplexity int) int
	}

	MTG_Filter_Search struct {
		PagedCards func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	MTG_Image struct {
		ArtCrop    func(childComplexity int) int
		BorderCrop func(childComplexity int) int
		Large      func(childComplexity int) int
		Normal     func(childComplexity int) int
		Png        func(childComplexity int) int
		Small      func(childComplexity int) int
	}

	Mutation struct {
		AddIgnoredCard               func(childComplexity int, input model.AddIgnoredCardInput) int
		AddMTGCardToCardPackage      func(childComplexity int, input model.MtgAddCardToCardPackageInput) int
		AssignTag                    func(childComplexity int, input model.AssignTagInput) int
		CreateMTGCardPackage         func(childComplexity int, input model.MtgCreateCardPackageInput) int
		CreateMTGDeck                func(childComplexity int, input model.MtgCreateDeckInput) int
		CreateTag                    func(childComplexity int, input model.CreateTagInput) int
		DeleteMTGCardPackage         func(childComplexity int, input model.MtgDeleteCardPackageInput) int
		DeleteMTGDeck                func(childComplexity int, input model.MtgDeleteDeckInput) int
		DeleteTag                    func(childComplexity int, tagID string) int
		Rate                         func(childComplexity int, input model.RateInput) int
		RemoveIgnoredCard            func(childComplexity int, input model.RemoveIgnoredCardInput) int
		RemoveMTGCardFromCardPackage func(childComplexity int, input model.MtgRemoveCardFromCardPackageInput) int
		SaveMTGDeckAsCopy            func(childComplexity int, input model.MtgUpdateDeckInput) int
		UnassignTag                  func(childComplexity int, input model.UnassignTagInput) int
		UpdateMTGDeck                func(childComplexity int, input model.MtgUpdateDeckInput) int
		UpdateTag                    func(childComplexity int, input model.UpdateTagInput) int
	}

	Phantom struct {
		ID       func(childComplexity int) int
		Position func(childComplexity int) int
	}

	Position struct {
		X func(childComplexity int) int
		Y func(childComplexity int) int
	}

	Query struct {
		CardTags            func(childComplexity int) int
		DeckTags            func(childComplexity int) int
		GetMTGCardPackages  func(childComplexity int, cardPackageID *string) int
		GetMTGCards         func(childComplexity int) int
		GetMTGCardsFiltered func(childComplexity int, filter model.MtgFilterSearchInput, pagination model.MtgFilterPaginationInput, sort []*model.MtgFilterSortInput) int
		GetMTGDeck          func(childComplexity int, deckID string) int
		GetMTGDecks         func(childComplexity int) int
		GetMTGFilters       func(childComplexity int) int
		Tag                 func(childComplexity int, id string) int
		Tags                func(childComplexity int) int
	}

	Response struct {
		Message func(childComplexity int) int
		Status  func(childComplexity int) int
	}

	User struct {
		ID func(childComplexity int) int
	}

	UserRating struct {
		User  func(childComplexity int) int
		Value func(childComplexity int) int
	}
}

type MutationResolver interface {
	CreateMTGDeck(ctx context.Context, input model.MtgCreateDeckInput) (*model.Response, error)
	DeleteMTGDeck(ctx context.Context, input model.MtgDeleteDeckInput) (*model.Response, error)
	UpdateMTGDeck(ctx context.Context, input model.MtgUpdateDeckInput) (*model.Response, error)
	SaveMTGDeckAsCopy(ctx context.Context, input model.MtgUpdateDeckInput) (*model.Response, error)
	CreateMTGCardPackage(ctx context.Context, input model.MtgCreateCardPackageInput) (*model.Response, error)
	DeleteMTGCardPackage(ctx context.Context, input model.MtgDeleteCardPackageInput) (*model.Response, error)
	AddMTGCardToCardPackage(ctx context.Context, input model.MtgAddCardToCardPackageInput) (*model.Response, error)
	RemoveMTGCardFromCardPackage(ctx context.Context, input model.MtgRemoveCardFromCardPackageInput) (*model.Response, error)
	CreateTag(ctx context.Context, input model.CreateTagInput) (*model.Response, error)
	UpdateTag(ctx context.Context, input model.UpdateTagInput) (*model.Response, error)
	DeleteTag(ctx context.Context, tagID string) (*model.Response, error)
	AssignTag(ctx context.Context, input model.AssignTagInput) (*model.Response, error)
	UnassignTag(ctx context.Context, input model.UnassignTagInput) (*model.Response, error)
	Rate(ctx context.Context, input model.RateInput) (*model.Response, error)
	AddIgnoredCard(ctx context.Context, input model.AddIgnoredCardInput) (*model.Response, error)
	RemoveIgnoredCard(ctx context.Context, input model.RemoveIgnoredCardInput) (*model.Response, error)
}
type QueryResolver interface {
	GetMTGCards(ctx context.Context) ([]*model.MtgCard, error)
	GetMTGCardsFiltered(ctx context.Context, filter model.MtgFilterSearchInput, pagination model.MtgFilterPaginationInput, sort []*model.MtgFilterSortInput) (*model.MtgFilterSearch, error)
	GetMTGFilters(ctx context.Context) (*model.MtgFilterEntries, error)
	GetMTGDecks(ctx context.Context) ([]*model.MtgDeckDashboard, error)
	GetMTGDeck(ctx context.Context, deckID string) (*model.MtgDeck, error)
	GetMTGCardPackages(ctx context.Context, cardPackageID *string) ([]*model.MtgCardPackage, error)
	Tags(ctx context.Context) ([]model.Tag, error)
	CardTags(ctx context.Context) ([]*model.CardTag, error)
	DeckTags(ctx context.Context) ([]*model.DeckTag, error)
	Tag(ctx context.Context, id string) (model.Tag, error)
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]any) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "CardTag.description":
		if e.complexity.CardTag.Description == nil {
			break
		}

		return e.complexity.CardTag.Description(childComplexity), true

	case "CardTag.ID":
		if e.complexity.CardTag.ID == nil {
			break
		}

		return e.complexity.CardTag.ID(childComplexity), true

	case "CardTag.myRating":
		if e.complexity.CardTag.MyRating == nil {
			break
		}

		return e.complexity.CardTag.MyRating(childComplexity), true

	case "CardTag.name":
		if e.complexity.CardTag.Name == nil {
			break
		}

		return e.complexity.CardTag.Name(childComplexity), true

	case "DeckTag.colors":
		if e.complexity.DeckTag.Colors == nil {
			break
		}

		return e.complexity.DeckTag.Colors(childComplexity), true

	case "DeckTag.description":
		if e.complexity.DeckTag.Description == nil {
			break
		}

		return e.complexity.DeckTag.Description(childComplexity), true

	case "DeckTag.ID":
		if e.complexity.DeckTag.ID == nil {
			break
		}

		return e.complexity.DeckTag.ID(childComplexity), true

	case "DeckTag.myRating":
		if e.complexity.DeckTag.MyRating == nil {
			break
		}

		return e.complexity.DeckTag.MyRating(childComplexity), true

	case "DeckTag.name":
		if e.complexity.DeckTag.Name == nil {
			break
		}

		return e.complexity.DeckTag.Name(childComplexity), true

	case "FlowZone.cardChildren":
		if e.complexity.FlowZone.CardChildren == nil {
			break
		}

		return e.complexity.FlowZone.CardChildren(childComplexity), true

	case "FlowZone.height":
		if e.complexity.FlowZone.Height == nil {
			break
		}

		return e.complexity.FlowZone.Height(childComplexity), true

	case "FlowZone.ID":
		if e.complexity.FlowZone.ID == nil {
			break
		}

		return e.complexity.FlowZone.ID(childComplexity), true

	case "FlowZone.name":
		if e.complexity.FlowZone.Name == nil {
			break
		}

		return e.complexity.FlowZone.Name(childComplexity), true

	case "FlowZone.position":
		if e.complexity.FlowZone.Position == nil {
			break
		}

		return e.complexity.FlowZone.Position(childComplexity), true

	case "FlowZone.width":
		if e.complexity.FlowZone.Width == nil {
			break
		}

		return e.complexity.FlowZone.Width(childComplexity), true

	case "FlowZone.zoneChildren":
		if e.complexity.FlowZone.ZoneChildren == nil {
			break
		}

		return e.complexity.FlowZone.ZoneChildren(childComplexity), true

	case "MTG_Card.cardTags":
		if e.complexity.MTG_Card.CardTags == nil {
			break
		}

		return e.complexity.MTG_Card.CardTags(childComplexity), true

	case "MTG_Card.CMC":
		if e.complexity.MTG_Card.Cmc == nil {
			break
		}

		return e.complexity.MTG_Card.Cmc(childComplexity), true

	case "MTG_Card.colorIdentity":
		if e.complexity.MTG_Card.ColorIdentity == nil {
			break
		}

		return e.complexity.MTG_Card.ColorIdentity(childComplexity), true

	case "MTG_Card.colorIndicator":
		if e.complexity.MTG_Card.ColorIndicator == nil {
			break
		}

		return e.complexity.MTG_Card.ColorIndicator(childComplexity), true

	case "MTG_Card.colors":
		if e.complexity.MTG_Card.Colors == nil {
			break
		}

		return e.complexity.MTG_Card.Colors(childComplexity), true

	case "MTG_Card.deckTags":
		if e.complexity.MTG_Card.DeckTags == nil {
			break
		}

		return e.complexity.MTG_Card.DeckTags(childComplexity), true

	case "MTG_Card.EDHRecRank":
		if e.complexity.MTG_Card.EDHRecRank == nil {
			break
		}

		return e.complexity.MTG_Card.EDHRecRank(childComplexity), true

	case "MTG_Card.ID":
		if e.complexity.MTG_Card.ID == nil {
			break
		}

		return e.complexity.MTG_Card.ID(childComplexity), true

	case "MTG_Card.keywords":
		if e.complexity.MTG_Card.Keywords == nil {
			break
		}

		return e.complexity.MTG_Card.Keywords(childComplexity), true

	case "MTG_Card.layout":
		if e.complexity.MTG_Card.Layout == nil {
			break
		}

		return e.complexity.MTG_Card.Layout(childComplexity), true

	case "MTG_Card.loyalty":
		if e.complexity.MTG_Card.Loyalty == nil {
			break
		}

		return e.complexity.MTG_Card.Loyalty(childComplexity), true

	case "MTG_Card.manaCost":
		if e.complexity.MTG_Card.ManaCost == nil {
			break
		}

		return e.complexity.MTG_Card.ManaCost(childComplexity), true

	case "MTG_Card.myRating":
		if e.complexity.MTG_Card.MyRating == nil {
			break
		}

		return e.complexity.MTG_Card.MyRating(childComplexity), true

	case "MTG_Card.name":
		if e.complexity.MTG_Card.Name == nil {
			break
		}

		return e.complexity.MTG_Card.Name(childComplexity), true

	case "MTG_Card.oracleText":
		if e.complexity.MTG_Card.OracleText == nil {
			break
		}

		return e.complexity.MTG_Card.OracleText(childComplexity), true

	case "MTG_Card.power":
		if e.complexity.MTG_Card.Power == nil {
			break
		}

		return e.complexity.MTG_Card.Power(childComplexity), true

	case "MTG_Card.producedMana":
		if e.complexity.MTG_Card.ProducedMana == nil {
			break
		}

		return e.complexity.MTG_Card.ProducedMana(childComplexity), true

	case "MTG_Card.toughness":
		if e.complexity.MTG_Card.Toughness == nil {
			break
		}

		return e.complexity.MTG_Card.Toughness(childComplexity), true

	case "MTG_Card.typeLine":
		if e.complexity.MTG_Card.TypeLine == nil {
			break
		}

		return e.complexity.MTG_Card.TypeLine(childComplexity), true

	case "MTG_Card.versions":
		if e.complexity.MTG_Card.Versions == nil {
			break
		}

		return e.complexity.MTG_Card.Versions(childComplexity), true

	case "MTG_CardFace.artist":
		if e.complexity.MTG_CardFace.Artist == nil {
			break
		}

		return e.complexity.MTG_CardFace.Artist(childComplexity), true

	case "MTG_CardFace.CMC":
		if e.complexity.MTG_CardFace.Cmc == nil {
			break
		}

		return e.complexity.MTG_CardFace.Cmc(childComplexity), true

	case "MTG_CardFace.colorIndicator":
		if e.complexity.MTG_CardFace.ColorIndicator == nil {
			break
		}

		return e.complexity.MTG_CardFace.ColorIndicator(childComplexity), true

	case "MTG_CardFace.colors":
		if e.complexity.MTG_CardFace.Colors == nil {
			break
		}

		return e.complexity.MTG_CardFace.Colors(childComplexity), true

	case "MTG_CardFace.flavorText":
		if e.complexity.MTG_CardFace.FlavorText == nil {
			break
		}

		return e.complexity.MTG_CardFace.FlavorText(childComplexity), true

	case "MTG_CardFace.imageUris":
		if e.complexity.MTG_CardFace.ImageUris == nil {
			break
		}

		return e.complexity.MTG_CardFace.ImageUris(childComplexity), true

	case "MTG_CardFace.layout":
		if e.complexity.MTG_CardFace.Layout == nil {
			break
		}

		return e.complexity.MTG_CardFace.Layout(childComplexity), true

	case "MTG_CardFace.loyalty":
		if e.complexity.MTG_CardFace.Loyalty == nil {
			break
		}

		return e.complexity.MTG_CardFace.Loyalty(childComplexity), true

	case "MTG_CardFace.manaCost":
		if e.complexity.MTG_CardFace.ManaCost == nil {
			break
		}

		return e.complexity.MTG_CardFace.ManaCost(childComplexity), true

	case "MTG_CardFace.name":
		if e.complexity.MTG_CardFace.Name == nil {
			break
		}

		return e.complexity.MTG_CardFace.Name(childComplexity), true

	case "MTG_CardFace.oracleText":
		if e.complexity.MTG_CardFace.OracleText == nil {
			break
		}

		return e.complexity.MTG_CardFace.OracleText(childComplexity), true

	case "MTG_CardFace.power":
		if e.complexity.MTG_CardFace.Power == nil {
			break
		}

		return e.complexity.MTG_CardFace.Power(childComplexity), true

	case "MTG_CardFace.toughness":
		if e.complexity.MTG_CardFace.Toughness == nil {
			break
		}

		return e.complexity.MTG_CardFace.Toughness(childComplexity), true

	case "MTG_CardFace.typeLine":
		if e.complexity.MTG_CardFace.TypeLine == nil {
			break
		}

		return e.complexity.MTG_CardFace.TypeLine(childComplexity), true

	case "MTG_CardFace_Dashboard.imageUris":
		if e.complexity.MTG_CardFace_Dashboard.ImageUris == nil {
			break
		}

		return e.complexity.MTG_CardFace_Dashboard.ImageUris(childComplexity), true

	case "MTG_CardPackage.cards":
		if e.complexity.MTG_CardPackage.Cards == nil {
			break
		}

		return e.complexity.MTG_CardPackage.Cards(childComplexity), true

	case "MTG_CardPackage.ID":
		if e.complexity.MTG_CardPackage.ID == nil {
			break
		}

		return e.complexity.MTG_CardPackage.ID(childComplexity), true

	case "MTG_CardPackage.name":
		if e.complexity.MTG_CardPackage.Name == nil {
			break
		}

		return e.complexity.MTG_CardPackage.Name(childComplexity), true

	case "MTG_CardPackageCard.card":
		if e.complexity.MTG_CardPackageCard.Card == nil {
			break
		}

		return e.complexity.MTG_CardPackageCard.Card(childComplexity), true

	case "MTG_CardPackageCard.count":
		if e.complexity.MTG_CardPackageCard.Count == nil {
			break
		}

		return e.complexity.MTG_CardPackageCard.Count(childComplexity), true

	case "MTG_CardPackageCard.mainOrSide":
		if e.complexity.MTG_CardPackageCard.MainOrSide == nil {
			break
		}

		return e.complexity.MTG_CardPackageCard.MainOrSide(childComplexity), true

	case "MTG_CardPackageCard.selectedVersionID":
		if e.complexity.MTG_CardPackageCard.SelectedVersionID == nil {
			break
		}

		return e.complexity.MTG_CardPackageCard.SelectedVersionID(childComplexity), true

	case "MTG_CardVersion.artist":
		if e.complexity.MTG_CardVersion.Artist == nil {
			break
		}

		return e.complexity.MTG_CardVersion.Artist(childComplexity), true

	case "MTG_CardVersion.cardFaces":
		if e.complexity.MTG_CardVersion.CardFaces == nil {
			break
		}

		return e.complexity.MTG_CardVersion.CardFaces(childComplexity), true

	case "MTG_CardVersion.flavorName":
		if e.complexity.MTG_CardVersion.FlavorName == nil {
			break
		}

		return e.complexity.MTG_CardVersion.FlavorName(childComplexity), true

	case "MTG_CardVersion.flavorText":
		if e.complexity.MTG_CardVersion.FlavorText == nil {
			break
		}

		return e.complexity.MTG_CardVersion.FlavorText(childComplexity), true

	case "MTG_CardVersion.games":
		if e.complexity.MTG_CardVersion.Games == nil {
			break
		}

		return e.complexity.MTG_CardVersion.Games(childComplexity), true

	case "MTG_CardVersion.ID":
		if e.complexity.MTG_CardVersion.ID == nil {
			break
		}

		return e.complexity.MTG_CardVersion.ID(childComplexity), true

	case "MTG_CardVersion.imageUris":
		if e.complexity.MTG_CardVersion.ImageUris == nil {
			break
		}

		return e.complexity.MTG_CardVersion.ImageUris(childComplexity), true

	case "MTG_CardVersion.isAlchemy":
		if e.complexity.MTG_CardVersion.IsAlchemy == nil {
			break
		}

		return e.complexity.MTG_CardVersion.IsAlchemy(childComplexity), true

	case "MTG_CardVersion.isDefault":
		if e.complexity.MTG_CardVersion.IsDefault == nil {
			break
		}

		return e.complexity.MTG_CardVersion.IsDefault(childComplexity), true

	case "MTG_CardVersion.lang":
		if e.complexity.MTG_CardVersion.Lang == nil {
			break
		}

		return e.complexity.MTG_CardVersion.Lang(childComplexity), true

	case "MTG_CardVersion.legalities":
		if e.complexity.MTG_CardVersion.Legalities == nil {
			break
		}

		return e.complexity.MTG_CardVersion.Legalities(childComplexity), true

	case "MTG_CardVersion.rarity":
		if e.complexity.MTG_CardVersion.Rarity == nil {
			break
		}

		return e.complexity.MTG_CardVersion.Rarity(childComplexity), true

	case "MTG_CardVersion.releasedAt":
		if e.complexity.MTG_CardVersion.ReleasedAt == nil {
			break
		}

		return e.complexity.MTG_CardVersion.ReleasedAt(childComplexity), true

	case "MTG_CardVersion.reprint":
		if e.complexity.MTG_CardVersion.Reprint == nil {
			break
		}

		return e.complexity.MTG_CardVersion.Reprint(childComplexity), true

	case "MTG_CardVersion.set":
		if e.complexity.MTG_CardVersion.Set == nil {
			break
		}

		return e.complexity.MTG_CardVersion.Set(childComplexity), true

	case "MTG_CardVersion.setID":
		if e.complexity.MTG_CardVersion.SetID == nil {
			break
		}

		return e.complexity.MTG_CardVersion.SetID(childComplexity), true

	case "MTG_CardVersion.setName":
		if e.complexity.MTG_CardVersion.SetName == nil {
			break
		}

		return e.complexity.MTG_CardVersion.SetName(childComplexity), true

	case "MTG_CardVersion.setType":
		if e.complexity.MTG_CardVersion.SetType == nil {
			break
		}

		return e.complexity.MTG_CardVersion.SetType(childComplexity), true

	case "MTG_CardVersion.variation":
		if e.complexity.MTG_CardVersion.Variation == nil {
			break
		}

		return e.complexity.MTG_CardVersion.Variation(childComplexity), true

	case "MTG_CardVersion.variationOf":
		if e.complexity.MTG_CardVersion.VariationOf == nil {
			break
		}

		return e.complexity.MTG_CardVersion.VariationOf(childComplexity), true

	case "MTG_CardVersion_Dashboard.cardFaces":
		if e.complexity.MTG_CardVersion_Dashboard.CardFaces == nil {
			break
		}

		return e.complexity.MTG_CardVersion_Dashboard.CardFaces(childComplexity), true

	case "MTG_CardVersion_Dashboard.ID":
		if e.complexity.MTG_CardVersion_Dashboard.ID == nil {
			break
		}

		return e.complexity.MTG_CardVersion_Dashboard.ID(childComplexity), true

	case "MTG_CardVersion_Dashboard.imageUris":
		if e.complexity.MTG_CardVersion_Dashboard.ImageUris == nil {
			break
		}

		return e.complexity.MTG_CardVersion_Dashboard.ImageUris(childComplexity), true

	case "MTG_CardVersion_Dashboard.isAlchemy":
		if e.complexity.MTG_CardVersion_Dashboard.IsAlchemy == nil {
			break
		}

		return e.complexity.MTG_CardVersion_Dashboard.IsAlchemy(childComplexity), true

	case "MTG_CardVersion_Dashboard.isDefault":
		if e.complexity.MTG_CardVersion_Dashboard.IsDefault == nil {
			break
		}

		return e.complexity.MTG_CardVersion_Dashboard.IsDefault(childComplexity), true

	case "MTG_Card_Dashboard.ID":
		if e.complexity.MTG_Card_Dashboard.ID == nil {
			break
		}

		return e.complexity.MTG_Card_Dashboard.ID(childComplexity), true

	case "MTG_Card_Dashboard.versions":
		if e.complexity.MTG_Card_Dashboard.Versions == nil {
			break
		}

		return e.complexity.MTG_Card_Dashboard.Versions(childComplexity), true

	case "MTG_Deck.cardFrontImage":
		if e.complexity.MTG_Deck.CardFrontImage == nil {
			break
		}

		return e.complexity.MTG_Deck.CardFrontImage(childComplexity), true

	case "MTG_Deck.cards":
		if e.complexity.MTG_Deck.Cards == nil {
			break
		}

		return e.complexity.MTG_Deck.Cards(childComplexity), true

	case "MTG_Deck.ID":
		if e.complexity.MTG_Deck.ID == nil {
			break
		}

		return e.complexity.MTG_Deck.ID(childComplexity), true

	case "MTG_Deck.ignoredCards":
		if e.complexity.MTG_Deck.IgnoredCards == nil {
			break
		}

		return e.complexity.MTG_Deck.IgnoredCards(childComplexity), true

	case "MTG_Deck.name":
		if e.complexity.MTG_Deck.Name == nil {
			break
		}

		return e.complexity.MTG_Deck.Name(childComplexity), true

	case "MTG_Deck.zones":
		if e.complexity.MTG_Deck.Zones == nil {
			break
		}

		return e.complexity.MTG_Deck.Zones(childComplexity), true

	case "MTG_DeckCard.card":
		if e.complexity.MTG_DeckCard.Card == nil {
			break
		}

		return e.complexity.MTG_DeckCard.Card(childComplexity), true

	case "MTG_DeckCard.count":
		if e.complexity.MTG_DeckCard.Count == nil {
			break
		}

		return e.complexity.MTG_DeckCard.Count(childComplexity), true

	case "MTG_DeckCard.deckCardType":
		if e.complexity.MTG_DeckCard.DeckCardType == nil {
			break
		}

		return e.complexity.MTG_DeckCard.DeckCardType(childComplexity), true

	case "MTG_DeckCard.mainOrSide":
		if e.complexity.MTG_DeckCard.MainOrSide == nil {
			break
		}

		return e.complexity.MTG_DeckCard.MainOrSide(childComplexity), true

	case "MTG_DeckCard.phantoms":
		if e.complexity.MTG_DeckCard.Phantoms == nil {
			break
		}

		return e.complexity.MTG_DeckCard.Phantoms(childComplexity), true

	case "MTG_DeckCard.position":
		if e.complexity.MTG_DeckCard.Position == nil {
			break
		}

		return e.complexity.MTG_DeckCard.Position(childComplexity), true

	case "MTG_DeckCard.selectedVersionID":
		if e.complexity.MTG_DeckCard.SelectedVersionID == nil {
			break
		}

		return e.complexity.MTG_DeckCard.SelectedVersionID(childComplexity), true

	case "MTG_DeckCard_Dashboard.card":
		if e.complexity.MTG_DeckCard_Dashboard.Card == nil {
			break
		}

		return e.complexity.MTG_DeckCard_Dashboard.Card(childComplexity), true

	case "MTG_DeckCard_Dashboard.selectedVersionID":
		if e.complexity.MTG_DeckCard_Dashboard.SelectedVersionID == nil {
			break
		}

		return e.complexity.MTG_DeckCard_Dashboard.SelectedVersionID(childComplexity), true

	case "MTG_DeckDashboard.cardFrontImage":
		if e.complexity.MTG_DeckDashboard.CardFrontImage == nil {
			break
		}

		return e.complexity.MTG_DeckDashboard.CardFrontImage(childComplexity), true

	case "MTG_DeckDashboard.cards":
		if e.complexity.MTG_DeckDashboard.Cards == nil {
			break
		}

		return e.complexity.MTG_DeckDashboard.Cards(childComplexity), true

	case "MTG_DeckDashboard.ID":
		if e.complexity.MTG_DeckDashboard.ID == nil {
			break
		}

		return e.complexity.MTG_DeckDashboard.ID(childComplexity), true

	case "MTG_DeckDashboard.name":
		if e.complexity.MTG_DeckDashboard.Name == nil {
			break
		}

		return e.complexity.MTG_DeckDashboard.Name(childComplexity), true

	case "MTG_Deck_CardFrontImage.cardID":
		if e.complexity.MTG_Deck_CardFrontImage.CardID == nil {
			break
		}

		return e.complexity.MTG_Deck_CardFrontImage.CardID(childComplexity), true

	case "MTG_Deck_CardFrontImage.image":
		if e.complexity.MTG_Deck_CardFrontImage.Image == nil {
			break
		}

		return e.complexity.MTG_Deck_CardFrontImage.Image(childComplexity), true

	case "MTG_Deck_CardFrontImage.versionID":
		if e.complexity.MTG_Deck_CardFrontImage.VersionID == nil {
			break
		}

		return e.complexity.MTG_Deck_CardFrontImage.VersionID(childComplexity), true

	case "MTG_Filter_CardTypes.cardType":
		if e.complexity.MTG_Filter_CardTypes.CardType == nil {
			break
		}

		return e.complexity.MTG_Filter_CardTypes.CardType(childComplexity), true

	case "MTG_Filter_CardTypes.subtypes":
		if e.complexity.MTG_Filter_CardTypes.Subtypes == nil {
			break
		}

		return e.complexity.MTG_Filter_CardTypes.Subtypes(childComplexity), true

	case "MTG_Filter_Entries.expansions":
		if e.complexity.MTG_Filter_Entries.Expansions == nil {
			break
		}

		return e.complexity.MTG_Filter_Entries.Expansions(childComplexity), true

	case "MTG_Filter_Entries.layouts":
		if e.complexity.MTG_Filter_Entries.Layouts == nil {
			break
		}

		return e.complexity.MTG_Filter_Entries.Layouts(childComplexity), true

	case "MTG_Filter_Entries.legality":
		if e.complexity.MTG_Filter_Entries.Legality == nil {
			break
		}

		return e.complexity.MTG_Filter_Entries.Legality(childComplexity), true

	case "MTG_Filter_Entries.types":
		if e.complexity.MTG_Filter_Entries.Types == nil {
			break
		}

		return e.complexity.MTG_Filter_Entries.Types(childComplexity), true

	case "MTG_Filter_Expansion.games":
		if e.complexity.MTG_Filter_Expansion.Games == nil {
			break
		}

		return e.complexity.MTG_Filter_Expansion.Games(childComplexity), true

	case "MTG_Filter_Expansion.imageURL":
		if e.complexity.MTG_Filter_Expansion.ImageURL == nil {
			break
		}

		return e.complexity.MTG_Filter_Expansion.ImageURL(childComplexity), true

	case "MTG_Filter_Expansion.releasedAt":
		if e.complexity.MTG_Filter_Expansion.ReleasedAt == nil {
			break
		}

		return e.complexity.MTG_Filter_Expansion.ReleasedAt(childComplexity), true

	case "MTG_Filter_Expansion.set":
		if e.complexity.MTG_Filter_Expansion.Set == nil {
			break
		}

		return e.complexity.MTG_Filter_Expansion.Set(childComplexity), true

	case "MTG_Filter_Expansion.setName":
		if e.complexity.MTG_Filter_Expansion.SetName == nil {
			break
		}

		return e.complexity.MTG_Filter_Expansion.SetName(childComplexity), true

	case "MTG_Filter_Expansion.setType":
		if e.complexity.MTG_Filter_Expansion.SetType == nil {
			break
		}

		return e.complexity.MTG_Filter_Expansion.SetType(childComplexity), true

	case "MTG_Filter_Legality.formats":
		if e.complexity.MTG_Filter_Legality.Formats == nil {
			break
		}

		return e.complexity.MTG_Filter_Legality.Formats(childComplexity), true

	case "MTG_Filter_Legality.legalityValues":
		if e.complexity.MTG_Filter_Legality.LegalityValues == nil {
			break
		}

		return e.complexity.MTG_Filter_Legality.LegalityValues(childComplexity), true

	case "MTG_Filter_Search.pagedCards":
		if e.complexity.MTG_Filter_Search.PagedCards == nil {
			break
		}

		return e.complexity.MTG_Filter_Search.PagedCards(childComplexity), true

	case "MTG_Filter_Search.totalCount":
		if e.complexity.MTG_Filter_Search.TotalCount == nil {
			break
		}

		return e.complexity.MTG_Filter_Search.TotalCount(childComplexity), true

	case "MTG_Image.artCrop":
		if e.complexity.MTG_Image.ArtCrop == nil {
			break
		}

		return e.complexity.MTG_Image.ArtCrop(childComplexity), true

	case "MTG_Image.borderCrop":
		if e.complexity.MTG_Image.BorderCrop == nil {
			break
		}

		return e.complexity.MTG_Image.BorderCrop(childComplexity), true

	case "MTG_Image.large":
		if e.complexity.MTG_Image.Large == nil {
			break
		}

		return e.complexity.MTG_Image.Large(childComplexity), true

	case "MTG_Image.normal":
		if e.complexity.MTG_Image.Normal == nil {
			break
		}

		return e.complexity.MTG_Image.Normal(childComplexity), true

	case "MTG_Image.PNG":
		if e.complexity.MTG_Image.Png == nil {
			break
		}

		return e.complexity.MTG_Image.Png(childComplexity), true

	case "MTG_Image.small":
		if e.complexity.MTG_Image.Small == nil {
			break
		}

		return e.complexity.MTG_Image.Small(childComplexity), true

	case "Mutation.addIgnoredCard":
		if e.complexity.Mutation.AddIgnoredCard == nil {
			break
		}

		args, err := ec.field_Mutation_addIgnoredCard_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddIgnoredCard(childComplexity, args["input"].(model.AddIgnoredCardInput)), true

	case "Mutation.addMTGCardToCardPackage":
		if e.complexity.Mutation.AddMTGCardToCardPackage == nil {
			break
		}

		args, err := ec.field_Mutation_addMTGCardToCardPackage_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddMTGCardToCardPackage(childComplexity, args["input"].(model.MtgAddCardToCardPackageInput)), true

	case "Mutation.assignTag":
		if e.complexity.Mutation.AssignTag == nil {
			break
		}

		args, err := ec.field_Mutation_assignTag_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AssignTag(childComplexity, args["input"].(model.AssignTagInput)), true

	case "Mutation.createMTGCardPackage":
		if e.complexity.Mutation.CreateMTGCardPackage == nil {
			break
		}

		args, err := ec.field_Mutation_createMTGCardPackage_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateMTGCardPackage(childComplexity, args["input"].(model.MtgCreateCardPackageInput)), true

	case "Mutation.createMTGDeck":
		if e.complexity.Mutation.CreateMTGDeck == nil {
			break
		}

		args, err := ec.field_Mutation_createMTGDeck_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateMTGDeck(childComplexity, args["input"].(model.MtgCreateDeckInput)), true

	case "Mutation.createTag":
		if e.complexity.Mutation.CreateTag == nil {
			break
		}

		args, err := ec.field_Mutation_createTag_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateTag(childComplexity, args["input"].(model.CreateTagInput)), true

	case "Mutation.deleteMTGCardPackage":
		if e.complexity.Mutation.DeleteMTGCardPackage == nil {
			break
		}

		args, err := ec.field_Mutation_deleteMTGCardPackage_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteMTGCardPackage(childComplexity, args["input"].(model.MtgDeleteCardPackageInput)), true

	case "Mutation.deleteMTGDeck":
		if e.complexity.Mutation.DeleteMTGDeck == nil {
			break
		}

		args, err := ec.field_Mutation_deleteMTGDeck_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteMTGDeck(childComplexity, args["input"].(model.MtgDeleteDeckInput)), true

	case "Mutation.deleteTag":
		if e.complexity.Mutation.DeleteTag == nil {
			break
		}

		args, err := ec.field_Mutation_deleteTag_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteTag(childComplexity, args["tagID"].(string)), true

	case "Mutation.rate":
		if e.complexity.Mutation.Rate == nil {
			break
		}

		args, err := ec.field_Mutation_rate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.Rate(childComplexity, args["input"].(model.RateInput)), true

	case "Mutation.removeIgnoredCard":
		if e.complexity.Mutation.RemoveIgnoredCard == nil {
			break
		}

		args, err := ec.field_Mutation_removeIgnoredCard_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RemoveIgnoredCard(childComplexity, args["input"].(model.RemoveIgnoredCardInput)), true

	case "Mutation.removeMTGCardFromCardPackage":
		if e.complexity.Mutation.RemoveMTGCardFromCardPackage == nil {
			break
		}

		args, err := ec.field_Mutation_removeMTGCardFromCardPackage_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RemoveMTGCardFromCardPackage(childComplexity, args["input"].(model.MtgRemoveCardFromCardPackageInput)), true

	case "Mutation.saveMTGDeckAsCopy":
		if e.complexity.Mutation.SaveMTGDeckAsCopy == nil {
			break
		}

		args, err := ec.field_Mutation_saveMTGDeckAsCopy_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SaveMTGDeckAsCopy(childComplexity, args["input"].(model.MtgUpdateDeckInput)), true

	case "Mutation.unassignTag":
		if e.complexity.Mutation.UnassignTag == nil {
			break
		}

		args, err := ec.field_Mutation_unassignTag_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UnassignTag(childComplexity, args["input"].(model.UnassignTagInput)), true

	case "Mutation.updateMTGDeck":
		if e.complexity.Mutation.UpdateMTGDeck == nil {
			break
		}

		args, err := ec.field_Mutation_updateMTGDeck_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateMTGDeck(childComplexity, args["input"].(model.MtgUpdateDeckInput)), true

	case "Mutation.updateTag":
		if e.complexity.Mutation.UpdateTag == nil {
			break
		}

		args, err := ec.field_Mutation_updateTag_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateTag(childComplexity, args["input"].(model.UpdateTagInput)), true

	case "Phantom.ID":
		if e.complexity.Phantom.ID == nil {
			break
		}

		return e.complexity.Phantom.ID(childComplexity), true

	case "Phantom.position":
		if e.complexity.Phantom.Position == nil {
			break
		}

		return e.complexity.Phantom.Position(childComplexity), true

	case "Position.x":
		if e.complexity.Position.X == nil {
			break
		}

		return e.complexity.Position.X(childComplexity), true

	case "Position.y":
		if e.complexity.Position.Y == nil {
			break
		}

		return e.complexity.Position.Y(childComplexity), true

	case "Query.cardTags":
		if e.complexity.Query.CardTags == nil {
			break
		}

		return e.complexity.Query.CardTags(childComplexity), true

	case "Query.deckTags":
		if e.complexity.Query.DeckTags == nil {
			break
		}

		return e.complexity.Query.DeckTags(childComplexity), true

	case "Query.getMTGCardPackages":
		if e.complexity.Query.GetMTGCardPackages == nil {
			break
		}

		args, err := ec.field_Query_getMTGCardPackages_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetMTGCardPackages(childComplexity, args["cardPackageID"].(*string)), true

	case "Query.getMTGCards":
		if e.complexity.Query.GetMTGCards == nil {
			break
		}

		return e.complexity.Query.GetMTGCards(childComplexity), true

	case "Query.getMTGCardsFiltered":
		if e.complexity.Query.GetMTGCardsFiltered == nil {
			break
		}

		args, err := ec.field_Query_getMTGCardsFiltered_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetMTGCardsFiltered(childComplexity, args["filter"].(model.MtgFilterSearchInput), args["pagination"].(model.MtgFilterPaginationInput), args["sort"].([]*model.MtgFilterSortInput)), true

	case "Query.getMTGDeck":
		if e.complexity.Query.GetMTGDeck == nil {
			break
		}

		args, err := ec.field_Query_getMTGDeck_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetMTGDeck(childComplexity, args["deckID"].(string)), true

	case "Query.getMTGDecks":
		if e.complexity.Query.GetMTGDecks == nil {
			break
		}

		return e.complexity.Query.GetMTGDecks(childComplexity), true

	case "Query.getMTGFilters":
		if e.complexity.Query.GetMTGFilters == nil {
			break
		}

		return e.complexity.Query.GetMTGFilters(childComplexity), true

	case "Query.tag":
		if e.complexity.Query.Tag == nil {
			break
		}

		args, err := ec.field_Query_tag_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Tag(childComplexity, args["id"].(string)), true

	case "Query.tags":
		if e.complexity.Query.Tags == nil {
			break
		}

		return e.complexity.Query.Tags(childComplexity), true

	case "Response.message":
		if e.complexity.Response.Message == nil {
			break
		}

		return e.complexity.Response.Message(childComplexity), true

	case "Response.status":
		if e.complexity.Response.Status == nil {
			break
		}

		return e.complexity.Response.Status(childComplexity), true

	case "User.ID":
		if e.complexity.User.ID == nil {
			break
		}

		return e.complexity.User.ID(childComplexity), true

	case "UserRating.user":
		if e.complexity.UserRating.User == nil {
			break
		}

		return e.complexity.UserRating.User(childComplexity), true

	case "UserRating.value":
		if e.complexity.UserRating.Value == nil {
			break
		}

		return e.complexity.UserRating.Value(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	opCtx := graphql.GetOperationContext(ctx)
	ec := executionContext{opCtx, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputAddIgnoredCardInput,
		ec.unmarshalInputAssignTagInput,
		ec.unmarshalInputCreateTagInput,
		ec.unmarshalInputFlowZoneInput,
		ec.unmarshalInputMTG_AddCardToCardPackageInput,
		ec.unmarshalInputMTG_CardPackageCardInput,
		ec.unmarshalInputMTG_CreateCardPackageInput,
		ec.unmarshalInputMTG_CreateDeckInput,
		ec.unmarshalInputMTG_DeckCardFrontImageInput,
		ec.unmarshalInputMTG_DeckCardInput,
		ec.unmarshalInputMTG_DeleteCardPackageInput,
		ec.unmarshalInputMTG_DeleteDeckInput,
		ec.unmarshalInputMTG_Filter_CardTypeInput,
		ec.unmarshalInputMTG_Filter_ColorInput,
		ec.unmarshalInputMTG_Filter_GameInput,
		ec.unmarshalInputMTG_Filter_LayoutInput,
		ec.unmarshalInputMTG_Filter_LegalityEntryInput,
		ec.unmarshalInputMTG_Filter_LegalityInput,
		ec.unmarshalInputMTG_Filter_ManaCostInput,
		ec.unmarshalInputMTG_Filter_PaginationInput,
		ec.unmarshalInputMTG_Filter_RarityInput,
		ec.unmarshalInputMTG_Filter_RatingInput,
		ec.unmarshalInputMTG_Filter_SearchInput,
		ec.unmarshalInputMTG_Filter_SetInput,
		ec.unmarshalInputMTG_Filter_SortInput,
		ec.unmarshalInputMTG_Filter_SubtypeInput,
		ec.unmarshalInputMTG_Filter_TagInput,
		ec.unmarshalInputMTG_RemoveCardFromCardPackageInput,
		ec.unmarshalInputMTG_UpdateDeckInput,
		ec.unmarshalInputPhantomInput,
		ec.unmarshalInputPositionInput,
		ec.unmarshalInputRateInput,
		ec.unmarshalInputRemoveIgnoredCardInput,
		ec.unmarshalInputUnassignTagInput,
		ec.unmarshalInputUpdateTagInput,
	)
	first := true

	switch opCtx.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, opCtx.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, opCtx.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../../../graphql/Flow/input.graphqls", Input: `input FlowZoneInput {
    ID: ID!
    name: String!
    position: PositionInput!
    width: Float!
    height: Float!
    cardChildren: [ID!]!
    zoneChildren: [ID!]!
}

input PositionInput {
    x: Float!
    y: Float!
}
`, BuiltIn: false},
	{Name: "../../../graphql/Flow/type.graphqls", Input: `type FlowZone {
    ID: ID!
    name: String!
    position: Position!
    width: Float!
    height: Float!
    cardChildren: [ID!]!
    zoneChildren: [ID!]!
}

type Position {
    x: Float!
    y: Float!
}
`, BuiltIn: false},
	{Name: "../../../graphql/MTG/Card/enum.graphqls", Input: `enum MTG_Color {
    C
    W
    U
    B
    R
    G
}

enum MTG_Rarity {
    common
    uncommon
    rare
    mythic
}

enum MTG_Layout {
    normal
    split
    flip
    transform
    modal_dfc
    meld
    leveler
    class
    case
    saga
    adventure
    mutate
    prototype
    battle
    planar
    scheme
    vanguard
    token
    double_faced_token
    emblem
    augment
    host
    art_series
    reversible_card
}

enum MTG_Game {
    paper
    mtgo
    arena
}
`, BuiltIn: false},
	{Name: "../../../graphql/MTG/Card/type.graphqls", Input: `type MTG_Card {
    ID: ID! @goTag(key: "json", value: "_key")
    layout: MTG_Layout!
    CMC: Float!
    colorIdentity: [MTG_Color!]!
    colorIndicator: [String!]
    colors: [MTG_Color!]
    EDHRecRank: Int
    keywords: [String!]!
    loyalty: String
    manaCost: String
    name: String!
    oracleText: String
    power: String
    producedMana: [MTG_Color!]
    toughness: String
    typeLine: String!
    versions: [MTG_CardVersion!]!
    myRating: UserRating
    cardTags: [CardTag!]!
    deckTags: [DeckTag!]!
}

type MTG_CardVersion {
    ID: ID!
    isDefault: Boolean!
    isAlchemy: Boolean!
    artist: String
    lang: String!
    flavorName: String
    flavorText: String
    cardFaces: [MTG_CardFace!]
    legalities: Map!
    games: [MTG_Game!]!
    imageUris: MTG_Image
    rarity: MTG_Rarity!
    releasedAt: String!
    reprint: Boolean!
    setName: String!
    setType: String!
    set: String!
    setID: String!
    variation: Boolean!
    variationOf: String
}

type MTG_CardFace {
    artist: String
    CMC: Float
    colorIndicator: [String!]
    colors: [MTG_Color!]
    flavorText: String
    imageUris: MTG_Image
    layout: MTG_Layout
    loyalty: String
    manaCost: String!
    name: String!
    oracleText: String
    power: String
    toughness: String
    typeLine: String
}

type MTG_Image {
    artCrop: String!
    borderCrop: String!
    large: String!
    normal: String!
    PNG: String!
    small: String!
}

type MTG_Card_Dashboard {
    ID: ID! @goTag(key: "json", value: "_key")
    versions: [MTG_CardVersion_Dashboard!]!
}

type MTG_CardVersion_Dashboard {
    ID: ID!
    isDefault: Boolean!
    isAlchemy: Boolean!
    cardFaces: [MTG_CardFace_Dashboard!]!
    imageUris: MTG_Image
}

type MTG_CardFace_Dashboard {
    imageUris: MTG_Image
}
`, BuiltIn: false},
	{Name: "../../../graphql/MTG/CardPackage/input.graphqls", Input: `input MTG_CreateCardPackageInput {
    name: String!
}

input MTG_DeleteCardPackageInput {
    cardPackageID: ID!
}

input MTG_AddCardToCardPackageInput {
    cardPackageID: ID!
    card: ID!
    count: Int!
}

input MTG_RemoveCardFromCardPackageInput {
    cardPackageID: ID!
    card: ID!
}

input MTG_CardPackageCardInput {
    card: ID!
    selectedVersionID: String
    count: Int!
    mainOrSide: MainOrSide!
}
`, BuiltIn: false},
	{Name: "../../../graphql/MTG/CardPackage/type.graphqls", Input: `type MTG_CardPackage {
    ID: ID! @goTag(key: "json", value: "_key")
    name: String!
    cards: [MTG_CardPackageCard!]!
    # zones: [FlowZone!]! TODO: Add zones to card package in the future
}

type MTG_CardPackageCard {
    card: MTG_Card!
    selectedVersionID: String
    count: Int!
    mainOrSide: MainOrSide!
}
`, BuiltIn: false},
	{Name: "../../../graphql/MTG/Deck/enum.graphqls", Input: `enum DeckType {
    # STANDARD
    BRAWL_60
    BRAWL_100
}

enum MainOrSide {
    MAIN
    SIDEBOARD
}

enum MTG_DeckCardType {
    NORMAL
    COMMANDER
}
`, BuiltIn: false},
	{Name: "../../../graphql/MTG/Deck/input.graphqls", Input: `input MTG_CreateDeckInput {
    name: String!
}

input MTG_DeleteDeckInput {
    deckID: ID!
}

input MTG_UpdateDeckInput {
    deckID: ID!
    name: String!
    cardFrontImage: MTG_DeckCardFrontImageInput
    cards: [MTG_DeckCardInput!]!
    zones: [FlowZoneInput!]!
}

input MTG_DeckCardFrontImageInput {
    cardID: ID!
    versionID: ID!
}

input MTG_DeckCardInput {
    ID: ID!
    card: ID!
    selectedVersionID: String
    count: Int!
    position: PositionInput!
    mainOrSide: MainOrSide!
    deckCardType: MTG_DeckCardType!
    phantoms: [PhantomInput!]!
}

input PhantomInput {
    ID: ID!
    position: PositionInput!
}
`, BuiltIn: false},
	{Name: "../../../graphql/MTG/Deck/type.graphqls", Input: `type MTG_Deck {
    ID: ID! @goTag(key: "json", value: "_key")
    name: String!
    cardFrontImage: MTG_Deck_CardFrontImage
    cards: [MTG_DeckCard!]!
    zones: [FlowZone!]!
    ignoredCards: [String!]!
}

type MTG_DeckCard {
    card: MTG_Card!
    selectedVersionID: String
    count: Int!
    position: Position!
    mainOrSide: MainOrSide!
    deckCardType: MTG_DeckCardType!
    phantoms: [Phantom!]!
}

type Phantom {
    position: Position!
    ID: ID!
}

type MTG_DeckDashboard {
    ID: ID! @goTag(key: "json", value: "_key")
    name: String!
    cardFrontImage: MTG_Deck_CardFrontImage
    cards: [MTG_DeckCard_Dashboard!]!
}

type MTG_Deck_CardFrontImage {
    cardID: ID!
    versionID: ID!
    image: String!
}

type MTG_DeckCard_Dashboard {
    card: MTG_Card_Dashboard!
    selectedVersionID: String
}
`, BuiltIn: false},
	{Name: "../../../graphql/MTG/Filter/enum.graphqls", Input: `enum TernaryBoolean {
    TRUE
    FALSE
    UNSET
}

enum MTG_Filter_SortBy {
    NAME
    CMC
    RARITY
    COLOR
    TYPE
    SET
    RELEASED_AT
}

enum MTG_Filter_SortDirection {
    ASC
    DESC
}
`, BuiltIn: false},
	{Name: "../../../graphql/MTG/Filter/input.graphqls", Input: `input MTG_Filter_SearchInput {
    searchString: String
    rarity: [MTG_Filter_RarityInput!]!
    color: [MTG_Filter_ColorInput!]!
    multiColor: TernaryBoolean!
    manaCosts: [MTG_Filter_ManaCostInput!]!
    cardTypes: [MTG_Filter_CardTypeInput!]!
    subtypes: [MTG_Filter_SubtypeInput!]!
    sets: [MTG_Filter_SetInput!]!
    legalities: [MTG_Filter_LegalityInput!]!
    layouts: [MTG_Filter_LayoutInput!]!
    games: [MTG_Filter_GameInput!]!
    hideIgnored: Boolean!
    tags: [MTG_Filter_TagInput!]!
    rating: MTG_Filter_RatingInput!
    commander: ID
    deckID: ID
    isSelectingCommander: Boolean!
}

input MTG_Filter_RarityInput {
    rarity: MTG_Rarity!
    value: TernaryBoolean!
}

input MTG_Filter_ColorInput {
    color: MTG_Color!
    value: TernaryBoolean!
}

input MTG_Filter_ManaCostInput {
    manaCost: String!
    value: TernaryBoolean!
}

input MTG_Filter_CardTypeInput {
    cardType: String!
    value: TernaryBoolean!
}

input MTG_Filter_SubtypeInput {
    subtype: String!
    value: TernaryBoolean!
}

input MTG_Filter_SetInput {
    set: String!
    value: TernaryBoolean!
}

input MTG_Filter_LegalityEntryInput {
    legalityValue: String!
    value: TernaryBoolean!
}

input MTG_Filter_LegalityInput {
    format: String!
    legalityEntries: [MTG_Filter_LegalityEntryInput!]!
}

input MTG_Filter_LayoutInput {
    layout: MTG_Layout!
    value: TernaryBoolean!
}

input MTG_Filter_GameInput {
    game: MTG_Game!
    value: TernaryBoolean!
}

input MTG_Filter_TagInput {
    tag: String!
    value: TernaryBoolean!
}

input MTG_Filter_RatingInput {
    min: Int
    max: Int
}

input MTG_Filter_PaginationInput {
    page: Int!
    pageSize: Int!
}

input MTG_Filter_SortInput {
    sortBy: MTG_Filter_SortBy!
    sortDirection: MTG_Filter_SortDirection!
    enabled: Boolean!
}
`, BuiltIn: false},
	{Name: "../../../graphql/MTG/Filter/type.graphqls", Input: `type MTG_Filter_Entries {
    types: [MTG_Filter_CardTypes!]!
    expansions: [MTG_Filter_Expansion!]!
    legality: MTG_Filter_Legality!
    layouts: [MTG_Layout!]!
}

type MTG_Filter_CardTypes {
    cardType: String!
    subtypes: [String!]!
}

type MTG_Filter_Legality {
    formats: [String!]!
    legalityValues: [String!]!
}

type MTG_Filter_Expansion {
    set: String!
    setName: String!
    releasedAt: Int!
    imageURL: String!
    setType: String!
    games: [MTG_Game!]!
}

type MTG_Filter_Search {
    pagedCards: [MTG_Card!]!
    totalCount: Int!
}
`, BuiltIn: false},
	{Name: "../../../graphql/MTG/IgnoredCard/input.graphqls", Input: `input AddIgnoredCardInput {
    cardID: ID!
    deckID: ID!
}

input RemoveIgnoredCardInput {
    cardID: ID!
    deckID: ID!
}
`, BuiltIn: false},
	{Name: "../../../graphql/MTG/Tag/type.graphqls", Input: `type DeckTag implements Tag {
    ID: ID! @goTag(key: "json", value: "_key")
    name: String!
    description: String
    # aggregatedRating: AggregatedRating!
    # ratings: [UserRating!]!
    myRating: UserRating
    colors: [MTG_Color!]!
}
`, BuiltIn: false},
	{Name: "../../../graphql/mutation.graphqls", Input: `type Mutation {
    # Decks
    createMTGDeck(input: MTG_CreateDeckInput!): Response!
    deleteMTGDeck(input: MTG_DeleteDeckInput!): Response!
    updateMTGDeck(input: MTG_UpdateDeckInput!): Response!
    saveMTGDeckAsCopy(input: MTG_UpdateDeckInput!): Response!
    # Card Packages
    createMTGCardPackage(input: MTG_CreateCardPackageInput!): Response!
    deleteMTGCardPackage(input: MTG_DeleteCardPackageInput!): Response!
    addMTGCardToCardPackage(input: MTG_AddCardToCardPackageInput!): Response!
    removeMTGCardFromCardPackage(input: MTG_RemoveCardFromCardPackageInput!): Response!
    # Tags
    createTag(input: CreateTagInput!): Response!
    updateTag(input: UpdateTagInput!): Response!
    deleteTag(tagID: ID!): Response!
    assignTag(input: AssignTagInput!): Response!
    unassignTag(input: UnassignTagInput!): Response!
    # Ratings
    rate(input: RateInput!): Response!
    # Ignored Cards
    addIgnoredCard(input: AddIgnoredCardInput!): Response!
    removeIgnoredCard(input: RemoveIgnoredCardInput!): Response!
}
`, BuiltIn: false},
	{Name: "../../../graphql/query.graphqls", Input: `type Query {
    # Cards
    getMTGCards: [MTG_Card!]!
    getMTGCardsFiltered(
        filter: MTG_Filter_SearchInput!
        pagination: MTG_Filter_PaginationInput!
        sort: [MTG_Filter_SortInput!]!
    ): MTG_Filter_Search!
    getMTGFilters: MTG_Filter_Entries!
    # Decks
    getMTGDecks: [MTG_DeckDashboard!]!
    getMTGDeck(deckID: ID!): MTG_Deck!
    # Card Packages
    getMTGCardPackages(cardPackageID: ID): [MTG_CardPackage!]!
    # Tags
    tags: [Tag!]!
    cardTags: [CardTag!]!
    deckTags: [DeckTag!]!
    tag(id: ID!): Tag
}
`, BuiltIn: false},
	{Name: "../../../graphql/Rating/enum.graphqls", Input: `enum RatableEntityType {
    CARD
    TAG
}
`, BuiltIn: false},
	{Name: "../../../graphql/Rating/input.graphqls", Input: `input RateInput {
    entityID: ID!
    entityType: RatableEntityType!
    value: Int!
}
`, BuiltIn: false},
	{Name: "../../../graphql/Rating/type.graphqls", Input: `type UserRating {
    user: User!
    value: Int!
}
`, BuiltIn: false},
	{Name: "../../../graphql/Tag/enum.graphqls", Input: `enum TagType {
    CardTag
    DeckTag
}
`, BuiltIn: false},
	{Name: "../../../graphql/Tag/input.graphqls", Input: `input CreateTagInput {
    type: TagType!
    name: String!
    description: String
    colors: [MTG_Color!]
    cardID: ID
}

input UpdateTagInput {
    ID: ID!
    name: String
    description: String
    colors: [MTG_Color!]
}

input AssignTagInput {
    tagID: ID!
    cardID: ID!
}

input UnassignTagInput {
    tagID: ID!
    cardID: ID!
}
`, BuiltIn: false},
	{Name: "../../../graphql/Tag/type.graphqls", Input: `interface Tag {
    ID: ID! @goTag(key: "json", value: "_key")
    name: String!
    description: String
    myRating: UserRating
}

type CardTag implements Tag {
    ID: ID! @goTag(key: "json", value: "_key")
    name: String!
    description: String
    myRating: UserRating
}
`, BuiltIn: false},
	{Name: "../../../graphql/type.base.graphqls", Input: `directive @goTag(key: String!, value: String) on INPUT_FIELD_DEFINITION | FIELD_DEFINITION
scalar Map

type Response {
    status: Boolean!
    message: String
}
`, BuiltIn: false},
	{Name: "../../../graphql/User/type.graphqls", Input: `type User {
    ID: ID! @goTag(key: "json", value: "_key")
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) field_Mutation_addIgnoredCard_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_addIgnoredCard_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_addIgnoredCard_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.AddIgnoredCardInput, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal model.AddIgnoredCardInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNAddIgnoredCardInput2magichelpergraphmodelAddIgnoredCardInput(ctx, tmp)
	}

	var zeroVal model.AddIgnoredCardInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_addMTGCardToCardPackage_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_addMTGCardToCardPackage_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_addMTGCardToCardPackage_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.MtgAddCardToCardPackageInput, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal model.MtgAddCardToCardPackageInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNMTG_AddCardToCardPackageInput2magichelpergraphmodelMtgAddCardToCardPackageInput(ctx, tmp)
	}

	var zeroVal model.MtgAddCardToCardPackageInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_assignTag_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_assignTag_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_assignTag_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.AssignTagInput, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal model.AssignTagInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNAssignTagInput2magichelpergraphmodelAssignTagInput(ctx, tmp)
	}

	var zeroVal model.AssignTagInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_createMTGCardPackage_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_createMTGCardPackage_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_createMTGCardPackage_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.MtgCreateCardPackageInput, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal model.MtgCreateCardPackageInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNMTG_CreateCardPackageInput2magichelpergraphmodelMtgCreateCardPackageInput(ctx, tmp)
	}

	var zeroVal model.MtgCreateCardPackageInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_createMTGDeck_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_createMTGDeck_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_createMTGDeck_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.MtgCreateDeckInput, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal model.MtgCreateDeckInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNMTG_CreateDeckInput2magichelpergraphmodelMtgCreateDeckInput(ctx, tmp)
	}

	var zeroVal model.MtgCreateDeckInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_createTag_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_createTag_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_createTag_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.CreateTagInput, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal model.CreateTagInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNCreateTagInput2magichelpergraphmodelCreateTagInput(ctx, tmp)
	}

	var zeroVal model.CreateTagInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_deleteMTGCardPackage_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_deleteMTGCardPackage_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_deleteMTGCardPackage_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.MtgDeleteCardPackageInput, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal model.MtgDeleteCardPackageInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNMTG_DeleteCardPackageInput2magichelpergraphmodelMtgDeleteCardPackageInput(ctx, tmp)
	}

	var zeroVal model.MtgDeleteCardPackageInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_deleteMTGDeck_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_deleteMTGDeck_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_deleteMTGDeck_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.MtgDeleteDeckInput, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal model.MtgDeleteDeckInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNMTG_DeleteDeckInput2magichelpergraphmodelMtgDeleteDeckInput(ctx, tmp)
	}

	var zeroVal model.MtgDeleteDeckInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_deleteTag_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_deleteTag_argsTagID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["tagID"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_deleteTag_argsTagID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["tagID"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("tagID"))
	if tmp, ok := rawArgs["tagID"]; ok {
		return ec.unmarshalNID2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_rate_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_rate_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_rate_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.RateInput, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal model.RateInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNRateInput2magichelpergraphmodelRateInput(ctx, tmp)
	}

	var zeroVal model.RateInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_removeIgnoredCard_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_removeIgnoredCard_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_removeIgnoredCard_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.RemoveIgnoredCardInput, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal model.RemoveIgnoredCardInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNRemoveIgnoredCardInput2magichelpergraphmodelRemoveIgnoredCardInput(ctx, tmp)
	}

	var zeroVal model.RemoveIgnoredCardInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_removeMTGCardFromCardPackage_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_removeMTGCardFromCardPackage_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_removeMTGCardFromCardPackage_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.MtgRemoveCardFromCardPackageInput, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal model.MtgRemoveCardFromCardPackageInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNMTG_RemoveCardFromCardPackageInput2magichelpergraphmodelMtgRemoveCardFromCardPackageInput(ctx, tmp)
	}

	var zeroVal model.MtgRemoveCardFromCardPackageInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_saveMTGDeckAsCopy_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_saveMTGDeckAsCopy_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_saveMTGDeckAsCopy_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.MtgUpdateDeckInput, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal model.MtgUpdateDeckInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNMTG_UpdateDeckInput2magichelpergraphmodelMtgUpdateDeckInput(ctx, tmp)
	}

	var zeroVal model.MtgUpdateDeckInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_unassignTag_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_unassignTag_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_unassignTag_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.UnassignTagInput, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal model.UnassignTagInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNUnassignTagInput2magichelpergraphmodelUnassignTagInput(ctx, tmp)
	}

	var zeroVal model.UnassignTagInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_updateMTGDeck_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_updateMTGDeck_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_updateMTGDeck_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.MtgUpdateDeckInput, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal model.MtgUpdateDeckInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNMTG_UpdateDeckInput2magichelpergraphmodelMtgUpdateDeckInput(ctx, tmp)
	}

	var zeroVal model.MtgUpdateDeckInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_updateTag_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_updateTag_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_updateTag_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.UpdateTagInput, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal model.UpdateTagInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNUpdateTagInput2magichelpergraphmodelUpdateTagInput(ctx, tmp)
	}

	var zeroVal model.UpdateTagInput
	return zeroVal, nil
}

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query___type_argsName(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["name"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query___type_argsName(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["name"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
	if tmp, ok := rawArgs["name"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getMTGCardPackages_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_getMTGCardPackages_argsCardPackageID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["cardPackageID"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_getMTGCardPackages_argsCardPackageID(
	ctx context.Context,
	rawArgs map[string]any,
) (*string, error) {
	if _, ok := rawArgs["cardPackageID"]; !ok {
		var zeroVal *string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("cardPackageID"))
	if tmp, ok := rawArgs["cardPackageID"]; ok {
		return ec.unmarshalOID2string(ctx, tmp)
	}

	var zeroVal *string
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getMTGCardsFiltered_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_getMTGCardsFiltered_argsFilter(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["filter"] = arg0
	arg1, err := ec.field_Query_getMTGCardsFiltered_argsPagination(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["pagination"] = arg1
	arg2, err := ec.field_Query_getMTGCardsFiltered_argsSort(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["sort"] = arg2
	return args, nil
}
func (ec *executionContext) field_Query_getMTGCardsFiltered_argsFilter(
	ctx context.Context,
	rawArgs map[string]any,
) (model.MtgFilterSearchInput, error) {
	if _, ok := rawArgs["filter"]; !ok {
		var zeroVal model.MtgFilterSearchInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
	if tmp, ok := rawArgs["filter"]; ok {
		return ec.unmarshalNMTG_Filter_SearchInput2magichelpergraphmodelMtgFilterSearchInput(ctx, tmp)
	}

	var zeroVal model.MtgFilterSearchInput
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getMTGCardsFiltered_argsPagination(
	ctx context.Context,
	rawArgs map[string]any,
) (model.MtgFilterPaginationInput, error) {
	if _, ok := rawArgs["pagination"]; !ok {
		var zeroVal model.MtgFilterPaginationInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("pagination"))
	if tmp, ok := rawArgs["pagination"]; ok {
		return ec.unmarshalNMTG_Filter_PaginationInput2magichelpergraphmodelMtgFilterPaginationInput(ctx, tmp)
	}

	var zeroVal model.MtgFilterPaginationInput
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getMTGCardsFiltered_argsSort(
	ctx context.Context,
	rawArgs map[string]any,
) ([]*model.MtgFilterSortInput, error) {
	if _, ok := rawArgs["sort"]; !ok {
		var zeroVal []*model.MtgFilterSortInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("sort"))
	if tmp, ok := rawArgs["sort"]; ok {
		return ec.unmarshalNMTG_Filter_SortInput2magichelpergraphmodelMtgFilterSortInput(ctx, tmp)
	}

	var zeroVal []*model.MtgFilterSortInput
	return zeroVal, nil
}

func (ec *executionContext) field_Query_getMTGDeck_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_getMTGDeck_argsDeckID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["deckID"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_getMTGDeck_argsDeckID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["deckID"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("deckID"))
	if tmp, ok := rawArgs["deckID"]; ok {
		return ec.unmarshalNID2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Query_tag_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_tag_argsID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_tag_argsID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["id"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
	if tmp, ok := rawArgs["id"]; ok {
		return ec.unmarshalNID2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field___Directive_args_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field___Directive_args_argsIncludeDeprecated(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}
func (ec *executionContext) field___Directive_args_argsIncludeDeprecated(
	ctx context.Context,
	rawArgs map[string]any,
) (*bool, error) {
	if _, ok := rawArgs["includeDeprecated"]; !ok {
		var zeroVal *bool
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		return ec.unmarshalOBoolean2bool(ctx, tmp)
	}

	var zeroVal *bool
	return zeroVal, nil
}

func (ec *executionContext) field___Field_args_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field___Field_args_argsIncludeDeprecated(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}
func (ec *executionContext) field___Field_args_argsIncludeDeprecated(
	ctx context.Context,
	rawArgs map[string]any,
) (*bool, error) {
	if _, ok := rawArgs["includeDeprecated"]; !ok {
		var zeroVal *bool
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		return ec.unmarshalOBoolean2bool(ctx, tmp)
	}

	var zeroVal *bool
	return zeroVal, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field___Type_enumValues_argsIncludeDeprecated(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}
func (ec *executionContext) field___Type_enumValues_argsIncludeDeprecated(
	ctx context.Context,
	rawArgs map[string]any,
) (bool, error) {
	if _, ok := rawArgs["includeDeprecated"]; !ok {
		var zeroVal bool
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		return ec.unmarshalOBoolean2bool(ctx, tmp)
	}

	var zeroVal bool
	return zeroVal, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field___Type_fields_argsIncludeDeprecated(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}
func (ec *executionContext) field___Type_fields_argsIncludeDeprecated(
	ctx context.Context,
	rawArgs map[string]any,
) (bool, error) {
	if _, ok := rawArgs["includeDeprecated"]; !ok {
		var zeroVal bool
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		return ec.unmarshalOBoolean2bool(ctx, tmp)
	}

	var zeroVal bool
	return zeroVal, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _CardTag_ID(ctx context.Context, field graphql.CollectedField, obj *model.CardTag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CardTag_ID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CardTag_ID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CardTag",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CardTag_name(ctx context.Context, field graphql.CollectedField, obj *model.CardTag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CardTag_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CardTag_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CardTag",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CardTag_description(ctx context.Context, field graphql.CollectedField, obj *model.CardTag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CardTag_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CardTag_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CardTag",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CardTag_myRating(ctx context.Context, field graphql.CollectedField, obj *model.CardTag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CardTag_myRating(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MyRating, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.UserRating)
	fc.Result = res
	return ec.marshalOUserRating2magichelpergraphmodelUserRating(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CardTag_myRating(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CardTag",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "user":
				return ec.fieldContext_UserRating_user(ctx, field)
			case "value":
				return ec.fieldContext_UserRating_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserRating", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeckTag_ID(ctx context.Context, field graphql.CollectedField, obj *model.DeckTag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeckTag_ID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeckTag_ID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeckTag",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeckTag_name(ctx context.Context, field graphql.CollectedField, obj *model.DeckTag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeckTag_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeckTag_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeckTag",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeckTag_description(ctx context.Context, field graphql.CollectedField, obj *model.DeckTag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeckTag_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeckTag_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeckTag",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeckTag_myRating(ctx context.Context, field graphql.CollectedField, obj *model.DeckTag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeckTag_myRating(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MyRating, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.UserRating)
	fc.Result = res
	return ec.marshalOUserRating2magichelpergraphmodelUserRating(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeckTag_myRating(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeckTag",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "user":
				return ec.fieldContext_UserRating_user(ctx, field)
			case "value":
				return ec.fieldContext_UserRating_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserRating", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeckTag_colors(ctx context.Context, field graphql.CollectedField, obj *model.DeckTag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeckTag_colors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Colors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.MtgColor)
	fc.Result = res
	return ec.marshalNMTG_Color2magichelpergraphmodelMtgColor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeckTag_colors(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeckTag",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type MTG_Color does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FlowZone_ID(ctx context.Context, field graphql.CollectedField, obj *model.FlowZone) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FlowZone_ID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FlowZone_ID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FlowZone",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FlowZone_name(ctx context.Context, field graphql.CollectedField, obj *model.FlowZone) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FlowZone_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FlowZone_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FlowZone",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FlowZone_position(ctx context.Context, field graphql.CollectedField, obj *model.FlowZone) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FlowZone_position(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Position, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Position)
	fc.Result = res
	return ec.marshalNPosition2magichelpergraphmodelPosition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FlowZone_position(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FlowZone",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "x":
				return ec.fieldContext_Position_x(ctx, field)
			case "y":
				return ec.fieldContext_Position_y(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Position", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FlowZone_width(ctx context.Context, field graphql.CollectedField, obj *model.FlowZone) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FlowZone_width(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Width, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FlowZone_width(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FlowZone",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FlowZone_height(ctx context.Context, field graphql.CollectedField, obj *model.FlowZone) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FlowZone_height(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Height, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FlowZone_height(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FlowZone",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FlowZone_cardChildren(ctx context.Context, field graphql.CollectedField, obj *model.FlowZone) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FlowZone_cardChildren(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CardChildren, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FlowZone_cardChildren(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FlowZone",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FlowZone_zoneChildren(ctx context.Context, field graphql.CollectedField, obj *model.FlowZone) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FlowZone_zoneChildren(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ZoneChildren, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FlowZone_zoneChildren(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FlowZone",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Card_ID(ctx context.Context, field graphql.CollectedField, obj *model.MtgCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Card_ID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Card_ID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Card",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Card_layout(ctx context.Context, field graphql.CollectedField, obj *model.MtgCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Card_layout(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Layout, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.MtgLayout)
	fc.Result = res
	return ec.marshalNMTG_Layout2magichelpergraphmodelMtgLayout(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Card_layout(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Card",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type MTG_Layout does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Card_CMC(ctx context.Context, field graphql.CollectedField, obj *model.MtgCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Card_CMC(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cmc, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Card_CMC(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Card",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Card_colorIdentity(ctx context.Context, field graphql.CollectedField, obj *model.MtgCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Card_colorIdentity(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ColorIdentity, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.MtgColor)
	fc.Result = res
	return ec.marshalNMTG_Color2magichelpergraphmodelMtgColor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Card_colorIdentity(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Card",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type MTG_Color does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Card_colorIndicator(ctx context.Context, field graphql.CollectedField, obj *model.MtgCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Card_colorIndicator(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ColorIndicator, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Card_colorIndicator(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Card",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Card_colors(ctx context.Context, field graphql.CollectedField, obj *model.MtgCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Card_colors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Colors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.MtgColor)
	fc.Result = res
	return ec.marshalOMTG_Color2magichelpergraphmodelMtgColor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Card_colors(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Card",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type MTG_Color does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Card_EDHRecRank(ctx context.Context, field graphql.CollectedField, obj *model.MtgCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Card_EDHRecRank(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EDHRecRank, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Card_EDHRecRank(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Card",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Card_keywords(ctx context.Context, field graphql.CollectedField, obj *model.MtgCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Card_keywords(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Keywords, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Card_keywords(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Card",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Card_loyalty(ctx context.Context, field graphql.CollectedField, obj *model.MtgCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Card_loyalty(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Loyalty, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Card_loyalty(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Card",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Card_manaCost(ctx context.Context, field graphql.CollectedField, obj *model.MtgCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Card_manaCost(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ManaCost, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Card_manaCost(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Card",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Card_name(ctx context.Context, field graphql.CollectedField, obj *model.MtgCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Card_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Card_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Card",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Card_oracleText(ctx context.Context, field graphql.CollectedField, obj *model.MtgCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Card_oracleText(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OracleText, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Card_oracleText(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Card",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Card_power(ctx context.Context, field graphql.CollectedField, obj *model.MtgCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Card_power(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Power, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Card_power(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Card",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Card_producedMana(ctx context.Context, field graphql.CollectedField, obj *model.MtgCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Card_producedMana(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProducedMana, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.MtgColor)
	fc.Result = res
	return ec.marshalOMTG_Color2magichelpergraphmodelMtgColor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Card_producedMana(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Card",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type MTG_Color does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Card_toughness(ctx context.Context, field graphql.CollectedField, obj *model.MtgCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Card_toughness(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Toughness, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Card_toughness(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Card",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Card_typeLine(ctx context.Context, field graphql.CollectedField, obj *model.MtgCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Card_typeLine(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TypeLine, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Card_typeLine(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Card",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Card_versions(ctx context.Context, field graphql.CollectedField, obj *model.MtgCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Card_versions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Versions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.MtgCardVersion)
	fc.Result = res
	return ec.marshalNMTG_CardVersion2magichelpergraphmodelMtgCardVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Card_versions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Card",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ID":
				return ec.fieldContext_MTG_CardVersion_ID(ctx, field)
			case "isDefault":
				return ec.fieldContext_MTG_CardVersion_isDefault(ctx, field)
			case "isAlchemy":
				return ec.fieldContext_MTG_CardVersion_isAlchemy(ctx, field)
			case "artist":
				return ec.fieldContext_MTG_CardVersion_artist(ctx, field)
			case "lang":
				return ec.fieldContext_MTG_CardVersion_lang(ctx, field)
			case "flavorName":
				return ec.fieldContext_MTG_CardVersion_flavorName(ctx, field)
			case "flavorText":
				return ec.fieldContext_MTG_CardVersion_flavorText(ctx, field)
			case "cardFaces":
				return ec.fieldContext_MTG_CardVersion_cardFaces(ctx, field)
			case "legalities":
				return ec.fieldContext_MTG_CardVersion_legalities(ctx, field)
			case "games":
				return ec.fieldContext_MTG_CardVersion_games(ctx, field)
			case "imageUris":
				return ec.fieldContext_MTG_CardVersion_imageUris(ctx, field)
			case "rarity":
				return ec.fieldContext_MTG_CardVersion_rarity(ctx, field)
			case "releasedAt":
				return ec.fieldContext_MTG_CardVersion_releasedAt(ctx, field)
			case "reprint":
				return ec.fieldContext_MTG_CardVersion_reprint(ctx, field)
			case "setName":
				return ec.fieldContext_MTG_CardVersion_setName(ctx, field)
			case "setType":
				return ec.fieldContext_MTG_CardVersion_setType(ctx, field)
			case "set":
				return ec.fieldContext_MTG_CardVersion_set(ctx, field)
			case "setID":
				return ec.fieldContext_MTG_CardVersion_setID(ctx, field)
			case "variation":
				return ec.fieldContext_MTG_CardVersion_variation(ctx, field)
			case "variationOf":
				return ec.fieldContext_MTG_CardVersion_variationOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MTG_CardVersion", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Card_myRating(ctx context.Context, field graphql.CollectedField, obj *model.MtgCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Card_myRating(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MyRating, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.UserRating)
	fc.Result = res
	return ec.marshalOUserRating2magichelpergraphmodelUserRating(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Card_myRating(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Card",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "user":
				return ec.fieldContext_UserRating_user(ctx, field)
			case "value":
				return ec.fieldContext_UserRating_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserRating", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Card_cardTags(ctx context.Context, field graphql.CollectedField, obj *model.MtgCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Card_cardTags(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CardTags, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.CardTag)
	fc.Result = res
	return ec.marshalNCardTag2magichelpergraphmodelCardTag(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Card_cardTags(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Card",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ID":
				return ec.fieldContext_CardTag_ID(ctx, field)
			case "name":
				return ec.fieldContext_CardTag_name(ctx, field)
			case "description":
				return ec.fieldContext_CardTag_description(ctx, field)
			case "myRating":
				return ec.fieldContext_CardTag_myRating(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CardTag", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Card_deckTags(ctx context.Context, field graphql.CollectedField, obj *model.MtgCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Card_deckTags(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeckTags, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.DeckTag)
	fc.Result = res
	return ec.marshalNDeckTag2magichelpergraphmodelDeckTag(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Card_deckTags(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Card",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ID":
				return ec.fieldContext_DeckTag_ID(ctx, field)
			case "name":
				return ec.fieldContext_DeckTag_name(ctx, field)
			case "description":
				return ec.fieldContext_DeckTag_description(ctx, field)
			case "myRating":
				return ec.fieldContext_DeckTag_myRating(ctx, field)
			case "colors":
				return ec.fieldContext_DeckTag_colors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DeckTag", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardFace_artist(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardFace) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardFace_artist(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Artist, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardFace_artist(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardFace",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardFace_CMC(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardFace) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardFace_CMC(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cmc, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardFace_CMC(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardFace",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardFace_colorIndicator(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardFace) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardFace_colorIndicator(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ColorIndicator, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardFace_colorIndicator(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardFace",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardFace_colors(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardFace) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardFace_colors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Colors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.MtgColor)
	fc.Result = res
	return ec.marshalOMTG_Color2magichelpergraphmodelMtgColor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardFace_colors(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardFace",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type MTG_Color does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardFace_flavorText(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardFace) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardFace_flavorText(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FlavorText, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardFace_flavorText(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardFace",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardFace_imageUris(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardFace) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardFace_imageUris(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ImageUris, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.MtgImage)
	fc.Result = res
	return ec.marshalOMTG_Image2magichelpergraphmodelMtgImage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardFace_imageUris(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardFace",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "artCrop":
				return ec.fieldContext_MTG_Image_artCrop(ctx, field)
			case "borderCrop":
				return ec.fieldContext_MTG_Image_borderCrop(ctx, field)
			case "large":
				return ec.fieldContext_MTG_Image_large(ctx, field)
			case "normal":
				return ec.fieldContext_MTG_Image_normal(ctx, field)
			case "PNG":
				return ec.fieldContext_MTG_Image_PNG(ctx, field)
			case "small":
				return ec.fieldContext_MTG_Image_small(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MTG_Image", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardFace_layout(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardFace) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardFace_layout(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Layout, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.MtgLayout)
	fc.Result = res
	return ec.marshalOMTG_Layout2magichelpergraphmodelMtgLayout(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardFace_layout(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardFace",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type MTG_Layout does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardFace_loyalty(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardFace) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardFace_loyalty(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Loyalty, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardFace_loyalty(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardFace",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardFace_manaCost(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardFace) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardFace_manaCost(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ManaCost, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardFace_manaCost(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardFace",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardFace_name(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardFace) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardFace_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardFace_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardFace",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardFace_oracleText(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardFace) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardFace_oracleText(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OracleText, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardFace_oracleText(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardFace",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardFace_power(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardFace) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardFace_power(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Power, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardFace_power(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardFace",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardFace_toughness(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardFace) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardFace_toughness(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Toughness, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardFace_toughness(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardFace",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardFace_typeLine(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardFace) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardFace_typeLine(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TypeLine, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardFace_typeLine(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardFace",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardFace_Dashboard_imageUris(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardFaceDashboard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardFace_Dashboard_imageUris(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ImageUris, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.MtgImage)
	fc.Result = res
	return ec.marshalOMTG_Image2magichelpergraphmodelMtgImage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardFace_Dashboard_imageUris(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardFace_Dashboard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "artCrop":
				return ec.fieldContext_MTG_Image_artCrop(ctx, field)
			case "borderCrop":
				return ec.fieldContext_MTG_Image_borderCrop(ctx, field)
			case "large":
				return ec.fieldContext_MTG_Image_large(ctx, field)
			case "normal":
				return ec.fieldContext_MTG_Image_normal(ctx, field)
			case "PNG":
				return ec.fieldContext_MTG_Image_PNG(ctx, field)
			case "small":
				return ec.fieldContext_MTG_Image_small(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MTG_Image", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardPackage_ID(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardPackage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardPackage_ID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardPackage_ID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardPackage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardPackage_name(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardPackage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardPackage_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardPackage_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardPackage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardPackage_cards(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardPackage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardPackage_cards(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cards, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.MtgCardPackageCard)
	fc.Result = res
	return ec.marshalNMTG_CardPackageCard2magichelpergraphmodelMtgCardPackageCard(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardPackage_cards(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardPackage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "card":
				return ec.fieldContext_MTG_CardPackageCard_card(ctx, field)
			case "selectedVersionID":
				return ec.fieldContext_MTG_CardPackageCard_selectedVersionID(ctx, field)
			case "count":
				return ec.fieldContext_MTG_CardPackageCard_count(ctx, field)
			case "mainOrSide":
				return ec.fieldContext_MTG_CardPackageCard_mainOrSide(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MTG_CardPackageCard", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardPackageCard_card(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardPackageCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardPackageCard_card(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Card, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.MtgCard)
	fc.Result = res
	return ec.marshalNMTG_Card2magichelpergraphmodelMtgCard(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardPackageCard_card(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardPackageCard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ID":
				return ec.fieldContext_MTG_Card_ID(ctx, field)
			case "layout":
				return ec.fieldContext_MTG_Card_layout(ctx, field)
			case "CMC":
				return ec.fieldContext_MTG_Card_CMC(ctx, field)
			case "colorIdentity":
				return ec.fieldContext_MTG_Card_colorIdentity(ctx, field)
			case "colorIndicator":
				return ec.fieldContext_MTG_Card_colorIndicator(ctx, field)
			case "colors":
				return ec.fieldContext_MTG_Card_colors(ctx, field)
			case "EDHRecRank":
				return ec.fieldContext_MTG_Card_EDHRecRank(ctx, field)
			case "keywords":
				return ec.fieldContext_MTG_Card_keywords(ctx, field)
			case "loyalty":
				return ec.fieldContext_MTG_Card_loyalty(ctx, field)
			case "manaCost":
				return ec.fieldContext_MTG_Card_manaCost(ctx, field)
			case "name":
				return ec.fieldContext_MTG_Card_name(ctx, field)
			case "oracleText":
				return ec.fieldContext_MTG_Card_oracleText(ctx, field)
			case "power":
				return ec.fieldContext_MTG_Card_power(ctx, field)
			case "producedMana":
				return ec.fieldContext_MTG_Card_producedMana(ctx, field)
			case "toughness":
				return ec.fieldContext_MTG_Card_toughness(ctx, field)
			case "typeLine":
				return ec.fieldContext_MTG_Card_typeLine(ctx, field)
			case "versions":
				return ec.fieldContext_MTG_Card_versions(ctx, field)
			case "myRating":
				return ec.fieldContext_MTG_Card_myRating(ctx, field)
			case "cardTags":
				return ec.fieldContext_MTG_Card_cardTags(ctx, field)
			case "deckTags":
				return ec.fieldContext_MTG_Card_deckTags(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MTG_Card", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardPackageCard_selectedVersionID(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardPackageCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardPackageCard_selectedVersionID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SelectedVersionID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardPackageCard_selectedVersionID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardPackageCard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardPackageCard_count(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardPackageCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardPackageCard_count(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardPackageCard_count(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardPackageCard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardPackageCard_mainOrSide(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardPackageCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardPackageCard_mainOrSide(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MainOrSide, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.MainOrSide)
	fc.Result = res
	return ec.marshalNMainOrSide2magichelpergraphmodelMainOrSide(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardPackageCard_mainOrSide(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardPackageCard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type MainOrSide does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardVersion_ID(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardVersion_ID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardVersion_ID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardVersion_isDefault(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardVersion_isDefault(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDefault, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardVersion_isDefault(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardVersion_isAlchemy(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardVersion_isAlchemy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsAlchemy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardVersion_isAlchemy(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardVersion_artist(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardVersion_artist(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Artist, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardVersion_artist(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardVersion_lang(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardVersion_lang(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Lang, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardVersion_lang(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardVersion_flavorName(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardVersion_flavorName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FlavorName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardVersion_flavorName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardVersion_flavorText(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardVersion_flavorText(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FlavorText, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardVersion_flavorText(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardVersion_cardFaces(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardVersion_cardFaces(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CardFaces, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.MtgCardFace)
	fc.Result = res
	return ec.marshalOMTG_CardFace2magichelpergraphmodelMtgCardFace(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardVersion_cardFaces(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "artist":
				return ec.fieldContext_MTG_CardFace_artist(ctx, field)
			case "CMC":
				return ec.fieldContext_MTG_CardFace_CMC(ctx, field)
			case "colorIndicator":
				return ec.fieldContext_MTG_CardFace_colorIndicator(ctx, field)
			case "colors":
				return ec.fieldContext_MTG_CardFace_colors(ctx, field)
			case "flavorText":
				return ec.fieldContext_MTG_CardFace_flavorText(ctx, field)
			case "imageUris":
				return ec.fieldContext_MTG_CardFace_imageUris(ctx, field)
			case "layout":
				return ec.fieldContext_MTG_CardFace_layout(ctx, field)
			case "loyalty":
				return ec.fieldContext_MTG_CardFace_loyalty(ctx, field)
			case "manaCost":
				return ec.fieldContext_MTG_CardFace_manaCost(ctx, field)
			case "name":
				return ec.fieldContext_MTG_CardFace_name(ctx, field)
			case "oracleText":
				return ec.fieldContext_MTG_CardFace_oracleText(ctx, field)
			case "power":
				return ec.fieldContext_MTG_CardFace_power(ctx, field)
			case "toughness":
				return ec.fieldContext_MTG_CardFace_toughness(ctx, field)
			case "typeLine":
				return ec.fieldContext_MTG_CardFace_typeLine(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MTG_CardFace", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardVersion_legalities(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardVersion_legalities(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Legalities, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(map[string]any)
	fc.Result = res
	return ec.marshalNMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardVersion_legalities(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardVersion_games(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardVersion_games(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Games, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.MtgGame)
	fc.Result = res
	return ec.marshalNMTG_Game2magichelpergraphmodelMtgGame(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardVersion_games(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type MTG_Game does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardVersion_imageUris(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardVersion_imageUris(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ImageUris, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.MtgImage)
	fc.Result = res
	return ec.marshalOMTG_Image2magichelpergraphmodelMtgImage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardVersion_imageUris(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "artCrop":
				return ec.fieldContext_MTG_Image_artCrop(ctx, field)
			case "borderCrop":
				return ec.fieldContext_MTG_Image_borderCrop(ctx, field)
			case "large":
				return ec.fieldContext_MTG_Image_large(ctx, field)
			case "normal":
				return ec.fieldContext_MTG_Image_normal(ctx, field)
			case "PNG":
				return ec.fieldContext_MTG_Image_PNG(ctx, field)
			case "small":
				return ec.fieldContext_MTG_Image_small(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MTG_Image", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardVersion_rarity(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardVersion_rarity(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Rarity, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.MtgRarity)
	fc.Result = res
	return ec.marshalNMTG_Rarity2magichelpergraphmodelMtgRarity(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardVersion_rarity(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type MTG_Rarity does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardVersion_releasedAt(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardVersion_releasedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ReleasedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardVersion_releasedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardVersion_reprint(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardVersion_reprint(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Reprint, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardVersion_reprint(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardVersion_setName(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardVersion_setName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SetName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardVersion_setName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardVersion_setType(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardVersion_setType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SetType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardVersion_setType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardVersion_set(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardVersion_set(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Set, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardVersion_set(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardVersion_setID(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardVersion_setID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SetID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardVersion_setID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardVersion_variation(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardVersion_variation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Variation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardVersion_variation(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardVersion_variationOf(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardVersion_variationOf(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.VariationOf, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardVersion_variationOf(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardVersion_Dashboard_ID(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardVersionDashboard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardVersion_Dashboard_ID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardVersion_Dashboard_ID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardVersion_Dashboard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardVersion_Dashboard_isDefault(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardVersionDashboard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardVersion_Dashboard_isDefault(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDefault, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardVersion_Dashboard_isDefault(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardVersion_Dashboard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardVersion_Dashboard_isAlchemy(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardVersionDashboard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardVersion_Dashboard_isAlchemy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsAlchemy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardVersion_Dashboard_isAlchemy(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardVersion_Dashboard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardVersion_Dashboard_cardFaces(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardVersionDashboard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardVersion_Dashboard_cardFaces(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CardFaces, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.MtgCardFaceDashboard)
	fc.Result = res
	return ec.marshalNMTG_CardFace_Dashboard2magichelpergraphmodelMtgCardFaceDashboard(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardVersion_Dashboard_cardFaces(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardVersion_Dashboard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "imageUris":
				return ec.fieldContext_MTG_CardFace_Dashboard_imageUris(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MTG_CardFace_Dashboard", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_CardVersion_Dashboard_imageUris(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardVersionDashboard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_CardVersion_Dashboard_imageUris(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ImageUris, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.MtgImage)
	fc.Result = res
	return ec.marshalOMTG_Image2magichelpergraphmodelMtgImage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_CardVersion_Dashboard_imageUris(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_CardVersion_Dashboard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "artCrop":
				return ec.fieldContext_MTG_Image_artCrop(ctx, field)
			case "borderCrop":
				return ec.fieldContext_MTG_Image_borderCrop(ctx, field)
			case "large":
				return ec.fieldContext_MTG_Image_large(ctx, field)
			case "normal":
				return ec.fieldContext_MTG_Image_normal(ctx, field)
			case "PNG":
				return ec.fieldContext_MTG_Image_PNG(ctx, field)
			case "small":
				return ec.fieldContext_MTG_Image_small(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MTG_Image", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Card_Dashboard_ID(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardDashboard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Card_Dashboard_ID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Card_Dashboard_ID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Card_Dashboard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Card_Dashboard_versions(ctx context.Context, field graphql.CollectedField, obj *model.MtgCardDashboard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Card_Dashboard_versions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Versions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.MtgCardVersionDashboard)
	fc.Result = res
	return ec.marshalNMTG_CardVersion_Dashboard2magichelpergraphmodelMtgCardVersionDashboard(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Card_Dashboard_versions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Card_Dashboard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ID":
				return ec.fieldContext_MTG_CardVersion_Dashboard_ID(ctx, field)
			case "isDefault":
				return ec.fieldContext_MTG_CardVersion_Dashboard_isDefault(ctx, field)
			case "isAlchemy":
				return ec.fieldContext_MTG_CardVersion_Dashboard_isAlchemy(ctx, field)
			case "cardFaces":
				return ec.fieldContext_MTG_CardVersion_Dashboard_cardFaces(ctx, field)
			case "imageUris":
				return ec.fieldContext_MTG_CardVersion_Dashboard_imageUris(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MTG_CardVersion_Dashboard", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Deck_ID(ctx context.Context, field graphql.CollectedField, obj *model.MtgDeck) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Deck_ID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Deck_ID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Deck",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Deck_name(ctx context.Context, field graphql.CollectedField, obj *model.MtgDeck) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Deck_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Deck_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Deck",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Deck_cardFrontImage(ctx context.Context, field graphql.CollectedField, obj *model.MtgDeck) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Deck_cardFrontImage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CardFrontImage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.MtgDeckCardFrontImage)
	fc.Result = res
	return ec.marshalOMTG_Deck_CardFrontImage2magichelpergraphmodelMtgDeckCardFrontImage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Deck_cardFrontImage(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Deck",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cardID":
				return ec.fieldContext_MTG_Deck_CardFrontImage_cardID(ctx, field)
			case "versionID":
				return ec.fieldContext_MTG_Deck_CardFrontImage_versionID(ctx, field)
			case "image":
				return ec.fieldContext_MTG_Deck_CardFrontImage_image(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MTG_Deck_CardFrontImage", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Deck_cards(ctx context.Context, field graphql.CollectedField, obj *model.MtgDeck) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Deck_cards(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cards, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.MtgDeckCard)
	fc.Result = res
	return ec.marshalNMTG_DeckCard2magichelpergraphmodelMtgDeckCard(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Deck_cards(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Deck",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "card":
				return ec.fieldContext_MTG_DeckCard_card(ctx, field)
			case "selectedVersionID":
				return ec.fieldContext_MTG_DeckCard_selectedVersionID(ctx, field)
			case "count":
				return ec.fieldContext_MTG_DeckCard_count(ctx, field)
			case "position":
				return ec.fieldContext_MTG_DeckCard_position(ctx, field)
			case "mainOrSide":
				return ec.fieldContext_MTG_DeckCard_mainOrSide(ctx, field)
			case "deckCardType":
				return ec.fieldContext_MTG_DeckCard_deckCardType(ctx, field)
			case "phantoms":
				return ec.fieldContext_MTG_DeckCard_phantoms(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MTG_DeckCard", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Deck_zones(ctx context.Context, field graphql.CollectedField, obj *model.MtgDeck) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Deck_zones(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Zones, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.FlowZone)
	fc.Result = res
	return ec.marshalNFlowZone2magichelpergraphmodelFlowZone(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Deck_zones(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Deck",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ID":
				return ec.fieldContext_FlowZone_ID(ctx, field)
			case "name":
				return ec.fieldContext_FlowZone_name(ctx, field)
			case "position":
				return ec.fieldContext_FlowZone_position(ctx, field)
			case "width":
				return ec.fieldContext_FlowZone_width(ctx, field)
			case "height":
				return ec.fieldContext_FlowZone_height(ctx, field)
			case "cardChildren":
				return ec.fieldContext_FlowZone_cardChildren(ctx, field)
			case "zoneChildren":
				return ec.fieldContext_FlowZone_zoneChildren(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FlowZone", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Deck_ignoredCards(ctx context.Context, field graphql.CollectedField, obj *model.MtgDeck) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Deck_ignoredCards(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IgnoredCards, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Deck_ignoredCards(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Deck",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_DeckCard_card(ctx context.Context, field graphql.CollectedField, obj *model.MtgDeckCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_DeckCard_card(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Card, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.MtgCard)
	fc.Result = res
	return ec.marshalNMTG_Card2magichelpergraphmodelMtgCard(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_DeckCard_card(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_DeckCard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ID":
				return ec.fieldContext_MTG_Card_ID(ctx, field)
			case "layout":
				return ec.fieldContext_MTG_Card_layout(ctx, field)
			case "CMC":
				return ec.fieldContext_MTG_Card_CMC(ctx, field)
			case "colorIdentity":
				return ec.fieldContext_MTG_Card_colorIdentity(ctx, field)
			case "colorIndicator":
				return ec.fieldContext_MTG_Card_colorIndicator(ctx, field)
			case "colors":
				return ec.fieldContext_MTG_Card_colors(ctx, field)
			case "EDHRecRank":
				return ec.fieldContext_MTG_Card_EDHRecRank(ctx, field)
			case "keywords":
				return ec.fieldContext_MTG_Card_keywords(ctx, field)
			case "loyalty":
				return ec.fieldContext_MTG_Card_loyalty(ctx, field)
			case "manaCost":
				return ec.fieldContext_MTG_Card_manaCost(ctx, field)
			case "name":
				return ec.fieldContext_MTG_Card_name(ctx, field)
			case "oracleText":
				return ec.fieldContext_MTG_Card_oracleText(ctx, field)
			case "power":
				return ec.fieldContext_MTG_Card_power(ctx, field)
			case "producedMana":
				return ec.fieldContext_MTG_Card_producedMana(ctx, field)
			case "toughness":
				return ec.fieldContext_MTG_Card_toughness(ctx, field)
			case "typeLine":
				return ec.fieldContext_MTG_Card_typeLine(ctx, field)
			case "versions":
				return ec.fieldContext_MTG_Card_versions(ctx, field)
			case "myRating":
				return ec.fieldContext_MTG_Card_myRating(ctx, field)
			case "cardTags":
				return ec.fieldContext_MTG_Card_cardTags(ctx, field)
			case "deckTags":
				return ec.fieldContext_MTG_Card_deckTags(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MTG_Card", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_DeckCard_selectedVersionID(ctx context.Context, field graphql.CollectedField, obj *model.MtgDeckCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_DeckCard_selectedVersionID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SelectedVersionID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_DeckCard_selectedVersionID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_DeckCard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_DeckCard_count(ctx context.Context, field graphql.CollectedField, obj *model.MtgDeckCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_DeckCard_count(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_DeckCard_count(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_DeckCard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_DeckCard_position(ctx context.Context, field graphql.CollectedField, obj *model.MtgDeckCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_DeckCard_position(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Position, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Position)
	fc.Result = res
	return ec.marshalNPosition2magichelpergraphmodelPosition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_DeckCard_position(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_DeckCard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "x":
				return ec.fieldContext_Position_x(ctx, field)
			case "y":
				return ec.fieldContext_Position_y(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Position", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_DeckCard_mainOrSide(ctx context.Context, field graphql.CollectedField, obj *model.MtgDeckCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_DeckCard_mainOrSide(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MainOrSide, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.MainOrSide)
	fc.Result = res
	return ec.marshalNMainOrSide2magichelpergraphmodelMainOrSide(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_DeckCard_mainOrSide(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_DeckCard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type MainOrSide does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_DeckCard_deckCardType(ctx context.Context, field graphql.CollectedField, obj *model.MtgDeckCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_DeckCard_deckCardType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeckCardType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.MtgDeckCardType)
	fc.Result = res
	return ec.marshalNMTG_DeckCardType2magichelpergraphmodelMtgDeckCardType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_DeckCard_deckCardType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_DeckCard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type MTG_DeckCardType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_DeckCard_phantoms(ctx context.Context, field graphql.CollectedField, obj *model.MtgDeckCard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_DeckCard_phantoms(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Phantoms, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Phantom)
	fc.Result = res
	return ec.marshalNPhantom2magichelpergraphmodelPhantom(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_DeckCard_phantoms(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_DeckCard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "position":
				return ec.fieldContext_Phantom_position(ctx, field)
			case "ID":
				return ec.fieldContext_Phantom_ID(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Phantom", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_DeckCard_Dashboard_card(ctx context.Context, field graphql.CollectedField, obj *model.MtgDeckCardDashboard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_DeckCard_Dashboard_card(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Card, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.MtgCardDashboard)
	fc.Result = res
	return ec.marshalNMTG_Card_Dashboard2magichelpergraphmodelMtgCardDashboard(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_DeckCard_Dashboard_card(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_DeckCard_Dashboard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ID":
				return ec.fieldContext_MTG_Card_Dashboard_ID(ctx, field)
			case "versions":
				return ec.fieldContext_MTG_Card_Dashboard_versions(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MTG_Card_Dashboard", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_DeckCard_Dashboard_selectedVersionID(ctx context.Context, field graphql.CollectedField, obj *model.MtgDeckCardDashboard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_DeckCard_Dashboard_selectedVersionID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SelectedVersionID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_DeckCard_Dashboard_selectedVersionID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_DeckCard_Dashboard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_DeckDashboard_ID(ctx context.Context, field graphql.CollectedField, obj *model.MtgDeckDashboard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_DeckDashboard_ID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_DeckDashboard_ID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_DeckDashboard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_DeckDashboard_name(ctx context.Context, field graphql.CollectedField, obj *model.MtgDeckDashboard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_DeckDashboard_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_DeckDashboard_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_DeckDashboard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_DeckDashboard_cardFrontImage(ctx context.Context, field graphql.CollectedField, obj *model.MtgDeckDashboard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_DeckDashboard_cardFrontImage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CardFrontImage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.MtgDeckCardFrontImage)
	fc.Result = res
	return ec.marshalOMTG_Deck_CardFrontImage2magichelpergraphmodelMtgDeckCardFrontImage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_DeckDashboard_cardFrontImage(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_DeckDashboard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cardID":
				return ec.fieldContext_MTG_Deck_CardFrontImage_cardID(ctx, field)
			case "versionID":
				return ec.fieldContext_MTG_Deck_CardFrontImage_versionID(ctx, field)
			case "image":
				return ec.fieldContext_MTG_Deck_CardFrontImage_image(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MTG_Deck_CardFrontImage", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_DeckDashboard_cards(ctx context.Context, field graphql.CollectedField, obj *model.MtgDeckDashboard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_DeckDashboard_cards(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cards, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.MtgDeckCardDashboard)
	fc.Result = res
	return ec.marshalNMTG_DeckCard_Dashboard2magichelpergraphmodelMtgDeckCardDashboard(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_DeckDashboard_cards(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_DeckDashboard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "card":
				return ec.fieldContext_MTG_DeckCard_Dashboard_card(ctx, field)
			case "selectedVersionID":
				return ec.fieldContext_MTG_DeckCard_Dashboard_selectedVersionID(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MTG_DeckCard_Dashboard", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Deck_CardFrontImage_cardID(ctx context.Context, field graphql.CollectedField, obj *model.MtgDeckCardFrontImage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Deck_CardFrontImage_cardID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CardID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Deck_CardFrontImage_cardID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Deck_CardFrontImage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Deck_CardFrontImage_versionID(ctx context.Context, field graphql.CollectedField, obj *model.MtgDeckCardFrontImage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Deck_CardFrontImage_versionID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.VersionID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Deck_CardFrontImage_versionID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Deck_CardFrontImage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Deck_CardFrontImage_image(ctx context.Context, field graphql.CollectedField, obj *model.MtgDeckCardFrontImage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Deck_CardFrontImage_image(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Image, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Deck_CardFrontImage_image(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Deck_CardFrontImage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Filter_CardTypes_cardType(ctx context.Context, field graphql.CollectedField, obj *model.MtgFilterCardTypes) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Filter_CardTypes_cardType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CardType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Filter_CardTypes_cardType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Filter_CardTypes",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Filter_CardTypes_subtypes(ctx context.Context, field graphql.CollectedField, obj *model.MtgFilterCardTypes) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Filter_CardTypes_subtypes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Subtypes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Filter_CardTypes_subtypes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Filter_CardTypes",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Filter_Entries_types(ctx context.Context, field graphql.CollectedField, obj *model.MtgFilterEntries) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Filter_Entries_types(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.MtgFilterCardTypes)
	fc.Result = res
	return ec.marshalNMTG_Filter_CardTypes2magichelpergraphmodelMtgFilterCardTypes(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Filter_Entries_types(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Filter_Entries",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "cardType":
				return ec.fieldContext_MTG_Filter_CardTypes_cardType(ctx, field)
			case "subtypes":
				return ec.fieldContext_MTG_Filter_CardTypes_subtypes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MTG_Filter_CardTypes", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Filter_Entries_expansions(ctx context.Context, field graphql.CollectedField, obj *model.MtgFilterEntries) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Filter_Entries_expansions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Expansions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.MtgFilterExpansion)
	fc.Result = res
	return ec.marshalNMTG_Filter_Expansion2magichelpergraphmodelMtgFilterExpansion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Filter_Entries_expansions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Filter_Entries",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "set":
				return ec.fieldContext_MTG_Filter_Expansion_set(ctx, field)
			case "setName":
				return ec.fieldContext_MTG_Filter_Expansion_setName(ctx, field)
			case "releasedAt":
				return ec.fieldContext_MTG_Filter_Expansion_releasedAt(ctx, field)
			case "imageURL":
				return ec.fieldContext_MTG_Filter_Expansion_imageURL(ctx, field)
			case "setType":
				return ec.fieldContext_MTG_Filter_Expansion_setType(ctx, field)
			case "games":
				return ec.fieldContext_MTG_Filter_Expansion_games(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MTG_Filter_Expansion", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Filter_Entries_legality(ctx context.Context, field graphql.CollectedField, obj *model.MtgFilterEntries) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Filter_Entries_legality(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Legality, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.MtgFilterLegality)
	fc.Result = res
	return ec.marshalNMTG_Filter_Legality2magichelpergraphmodelMtgFilterLegality(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Filter_Entries_legality(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Filter_Entries",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "formats":
				return ec.fieldContext_MTG_Filter_Legality_formats(ctx, field)
			case "legalityValues":
				return ec.fieldContext_MTG_Filter_Legality_legalityValues(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MTG_Filter_Legality", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Filter_Entries_layouts(ctx context.Context, field graphql.CollectedField, obj *model.MtgFilterEntries) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Filter_Entries_layouts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Layouts, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.MtgLayout)
	fc.Result = res
	return ec.marshalNMTG_Layout2magichelpergraphmodelMtgLayout(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Filter_Entries_layouts(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Filter_Entries",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type MTG_Layout does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Filter_Expansion_set(ctx context.Context, field graphql.CollectedField, obj *model.MtgFilterExpansion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Filter_Expansion_set(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Set, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Filter_Expansion_set(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Filter_Expansion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Filter_Expansion_setName(ctx context.Context, field graphql.CollectedField, obj *model.MtgFilterExpansion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Filter_Expansion_setName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SetName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Filter_Expansion_setName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Filter_Expansion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Filter_Expansion_releasedAt(ctx context.Context, field graphql.CollectedField, obj *model.MtgFilterExpansion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Filter_Expansion_releasedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ReleasedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Filter_Expansion_releasedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Filter_Expansion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Filter_Expansion_imageURL(ctx context.Context, field graphql.CollectedField, obj *model.MtgFilterExpansion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Filter_Expansion_imageURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ImageURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Filter_Expansion_imageURL(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Filter_Expansion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Filter_Expansion_setType(ctx context.Context, field graphql.CollectedField, obj *model.MtgFilterExpansion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Filter_Expansion_setType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SetType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Filter_Expansion_setType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Filter_Expansion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Filter_Expansion_games(ctx context.Context, field graphql.CollectedField, obj *model.MtgFilterExpansion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Filter_Expansion_games(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Games, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.MtgGame)
	fc.Result = res
	return ec.marshalNMTG_Game2magichelpergraphmodelMtgGame(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Filter_Expansion_games(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Filter_Expansion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type MTG_Game does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Filter_Legality_formats(ctx context.Context, field graphql.CollectedField, obj *model.MtgFilterLegality) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Filter_Legality_formats(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Formats, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Filter_Legality_formats(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Filter_Legality",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Filter_Legality_legalityValues(ctx context.Context, field graphql.CollectedField, obj *model.MtgFilterLegality) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Filter_Legality_legalityValues(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LegalityValues, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Filter_Legality_legalityValues(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Filter_Legality",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Filter_Search_pagedCards(ctx context.Context, field graphql.CollectedField, obj *model.MtgFilterSearch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Filter_Search_pagedCards(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PagedCards, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.MtgCard)
	fc.Result = res
	return ec.marshalNMTG_Card2magichelpergraphmodelMtgCard(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Filter_Search_pagedCards(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Filter_Search",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ID":
				return ec.fieldContext_MTG_Card_ID(ctx, field)
			case "layout":
				return ec.fieldContext_MTG_Card_layout(ctx, field)
			case "CMC":
				return ec.fieldContext_MTG_Card_CMC(ctx, field)
			case "colorIdentity":
				return ec.fieldContext_MTG_Card_colorIdentity(ctx, field)
			case "colorIndicator":
				return ec.fieldContext_MTG_Card_colorIndicator(ctx, field)
			case "colors":
				return ec.fieldContext_MTG_Card_colors(ctx, field)
			case "EDHRecRank":
				return ec.fieldContext_MTG_Card_EDHRecRank(ctx, field)
			case "keywords":
				return ec.fieldContext_MTG_Card_keywords(ctx, field)
			case "loyalty":
				return ec.fieldContext_MTG_Card_loyalty(ctx, field)
			case "manaCost":
				return ec.fieldContext_MTG_Card_manaCost(ctx, field)
			case "name":
				return ec.fieldContext_MTG_Card_name(ctx, field)
			case "oracleText":
				return ec.fieldContext_MTG_Card_oracleText(ctx, field)
			case "power":
				return ec.fieldContext_MTG_Card_power(ctx, field)
			case "producedMana":
				return ec.fieldContext_MTG_Card_producedMana(ctx, field)
			case "toughness":
				return ec.fieldContext_MTG_Card_toughness(ctx, field)
			case "typeLine":
				return ec.fieldContext_MTG_Card_typeLine(ctx, field)
			case "versions":
				return ec.fieldContext_MTG_Card_versions(ctx, field)
			case "myRating":
				return ec.fieldContext_MTG_Card_myRating(ctx, field)
			case "cardTags":
				return ec.fieldContext_MTG_Card_cardTags(ctx, field)
			case "deckTags":
				return ec.fieldContext_MTG_Card_deckTags(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MTG_Card", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Filter_Search_totalCount(ctx context.Context, field graphql.CollectedField, obj *model.MtgFilterSearch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Filter_Search_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Filter_Search_totalCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Filter_Search",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Image_artCrop(ctx context.Context, field graphql.CollectedField, obj *model.MtgImage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Image_artCrop(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ArtCrop, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Image_artCrop(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Image",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Image_borderCrop(ctx context.Context, field graphql.CollectedField, obj *model.MtgImage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Image_borderCrop(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BorderCrop, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Image_borderCrop(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Image",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Image_large(ctx context.Context, field graphql.CollectedField, obj *model.MtgImage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Image_large(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Large, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Image_large(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Image",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Image_normal(ctx context.Context, field graphql.CollectedField, obj *model.MtgImage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Image_normal(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Normal, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Image_normal(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Image",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Image_PNG(ctx context.Context, field graphql.CollectedField, obj *model.MtgImage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Image_PNG(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Png, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Image_PNG(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Image",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MTG_Image_small(ctx context.Context, field graphql.CollectedField, obj *model.MtgImage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MTG_Image_small(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Small, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MTG_Image_small(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MTG_Image",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createMTGDeck(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createMTGDeck(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateMTGDeck(rctx, fc.Args["input"].(model.MtgCreateDeckInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Response)
	fc.Result = res
	return ec.marshalNResponse2magichelpergraphmodelResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createMTGDeck(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "status":
				return ec.fieldContext_Response_status(ctx, field)
			case "message":
				return ec.fieldContext_Response_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Response", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createMTGDeck_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteMTGDeck(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteMTGDeck(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteMTGDeck(rctx, fc.Args["input"].(model.MtgDeleteDeckInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Response)
	fc.Result = res
	return ec.marshalNResponse2magichelpergraphmodelResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteMTGDeck(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "status":
				return ec.fieldContext_Response_status(ctx, field)
			case "message":
				return ec.fieldContext_Response_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Response", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteMTGDeck_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateMTGDeck(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateMTGDeck(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateMTGDeck(rctx, fc.Args["input"].(model.MtgUpdateDeckInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Response)
	fc.Result = res
	return ec.marshalNResponse2magichelpergraphmodelResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateMTGDeck(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "status":
				return ec.fieldContext_Response_status(ctx, field)
			case "message":
				return ec.fieldContext_Response_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Response", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateMTGDeck_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_saveMTGDeckAsCopy(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_saveMTGDeckAsCopy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().SaveMTGDeckAsCopy(rctx, fc.Args["input"].(model.MtgUpdateDeckInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Response)
	fc.Result = res
	return ec.marshalNResponse2magichelpergraphmodelResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_saveMTGDeckAsCopy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "status":
				return ec.fieldContext_Response_status(ctx, field)
			case "message":
				return ec.fieldContext_Response_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Response", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_saveMTGDeckAsCopy_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createMTGCardPackage(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createMTGCardPackage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateMTGCardPackage(rctx, fc.Args["input"].(model.MtgCreateCardPackageInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Response)
	fc.Result = res
	return ec.marshalNResponse2magichelpergraphmodelResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createMTGCardPackage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "status":
				return ec.fieldContext_Response_status(ctx, field)
			case "message":
				return ec.fieldContext_Response_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Response", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createMTGCardPackage_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteMTGCardPackage(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteMTGCardPackage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteMTGCardPackage(rctx, fc.Args["input"].(model.MtgDeleteCardPackageInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Response)
	fc.Result = res
	return ec.marshalNResponse2magichelpergraphmodelResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteMTGCardPackage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "status":
				return ec.fieldContext_Response_status(ctx, field)
			case "message":
				return ec.fieldContext_Response_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Response", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteMTGCardPackage_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_addMTGCardToCardPackage(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_addMTGCardToCardPackage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().AddMTGCardToCardPackage(rctx, fc.Args["input"].(model.MtgAddCardToCardPackageInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Response)
	fc.Result = res
	return ec.marshalNResponse2magichelpergraphmodelResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_addMTGCardToCardPackage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "status":
				return ec.fieldContext_Response_status(ctx, field)
			case "message":
				return ec.fieldContext_Response_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Response", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_addMTGCardToCardPackage_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_removeMTGCardFromCardPackage(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_removeMTGCardFromCardPackage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().RemoveMTGCardFromCardPackage(rctx, fc.Args["input"].(model.MtgRemoveCardFromCardPackageInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Response)
	fc.Result = res
	return ec.marshalNResponse2magichelpergraphmodelResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_removeMTGCardFromCardPackage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "status":
				return ec.fieldContext_Response_status(ctx, field)
			case "message":
				return ec.fieldContext_Response_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Response", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_removeMTGCardFromCardPackage_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createTag(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createTag(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateTag(rctx, fc.Args["input"].(model.CreateTagInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Response)
	fc.Result = res
	return ec.marshalNResponse2magichelpergraphmodelResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createTag(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "status":
				return ec.fieldContext_Response_status(ctx, field)
			case "message":
				return ec.fieldContext_Response_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Response", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createTag_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateTag(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateTag(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateTag(rctx, fc.Args["input"].(model.UpdateTagInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Response)
	fc.Result = res
	return ec.marshalNResponse2magichelpergraphmodelResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateTag(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "status":
				return ec.fieldContext_Response_status(ctx, field)
			case "message":
				return ec.fieldContext_Response_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Response", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateTag_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteTag(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteTag(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteTag(rctx, fc.Args["tagID"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Response)
	fc.Result = res
	return ec.marshalNResponse2magichelpergraphmodelResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteTag(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "status":
				return ec.fieldContext_Response_status(ctx, field)
			case "message":
				return ec.fieldContext_Response_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Response", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteTag_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_assignTag(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_assignTag(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().AssignTag(rctx, fc.Args["input"].(model.AssignTagInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Response)
	fc.Result = res
	return ec.marshalNResponse2magichelpergraphmodelResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_assignTag(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "status":
				return ec.fieldContext_Response_status(ctx, field)
			case "message":
				return ec.fieldContext_Response_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Response", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_assignTag_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_unassignTag(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_unassignTag(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UnassignTag(rctx, fc.Args["input"].(model.UnassignTagInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Response)
	fc.Result = res
	return ec.marshalNResponse2magichelpergraphmodelResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_unassignTag(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "status":
				return ec.fieldContext_Response_status(ctx, field)
			case "message":
				return ec.fieldContext_Response_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Response", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_unassignTag_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_rate(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_rate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().Rate(rctx, fc.Args["input"].(model.RateInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Response)
	fc.Result = res
	return ec.marshalNResponse2magichelpergraphmodelResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_rate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "status":
				return ec.fieldContext_Response_status(ctx, field)
			case "message":
				return ec.fieldContext_Response_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Response", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_rate_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_addIgnoredCard(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_addIgnoredCard(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().AddIgnoredCard(rctx, fc.Args["input"].(model.AddIgnoredCardInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Response)
	fc.Result = res
	return ec.marshalNResponse2magichelpergraphmodelResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_addIgnoredCard(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "status":
				return ec.fieldContext_Response_status(ctx, field)
			case "message":
				return ec.fieldContext_Response_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Response", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_addIgnoredCard_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_removeIgnoredCard(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_removeIgnoredCard(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().RemoveIgnoredCard(rctx, fc.Args["input"].(model.RemoveIgnoredCardInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Response)
	fc.Result = res
	return ec.marshalNResponse2magichelpergraphmodelResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_removeIgnoredCard(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "status":
				return ec.fieldContext_Response_status(ctx, field)
			case "message":
				return ec.fieldContext_Response_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Response", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_removeIgnoredCard_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Phantom_position(ctx context.Context, field graphql.CollectedField, obj *model.Phantom) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Phantom_position(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Position, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Position)
	fc.Result = res
	return ec.marshalNPosition2magichelpergraphmodelPosition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Phantom_position(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Phantom",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "x":
				return ec.fieldContext_Position_x(ctx, field)
			case "y":
				return ec.fieldContext_Position_y(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Position", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Phantom_ID(ctx context.Context, field graphql.CollectedField, obj *model.Phantom) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Phantom_ID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Phantom_ID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Phantom",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Position_x(ctx context.Context, field graphql.CollectedField, obj *model.Position) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Position_x(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.X, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Position_x(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Position",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Position_y(ctx context.Context, field graphql.CollectedField, obj *model.Position) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Position_y(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Y, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Position_y(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Position",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_getMTGCards(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getMTGCards(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GetMTGCards(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.MtgCard)
	fc.Result = res
	return ec.marshalNMTG_Card2magichelpergraphmodelMtgCard(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getMTGCards(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ID":
				return ec.fieldContext_MTG_Card_ID(ctx, field)
			case "layout":
				return ec.fieldContext_MTG_Card_layout(ctx, field)
			case "CMC":
				return ec.fieldContext_MTG_Card_CMC(ctx, field)
			case "colorIdentity":
				return ec.fieldContext_MTG_Card_colorIdentity(ctx, field)
			case "colorIndicator":
				return ec.fieldContext_MTG_Card_colorIndicator(ctx, field)
			case "colors":
				return ec.fieldContext_MTG_Card_colors(ctx, field)
			case "EDHRecRank":
				return ec.fieldContext_MTG_Card_EDHRecRank(ctx, field)
			case "keywords":
				return ec.fieldContext_MTG_Card_keywords(ctx, field)
			case "loyalty":
				return ec.fieldContext_MTG_Card_loyalty(ctx, field)
			case "manaCost":
				return ec.fieldContext_MTG_Card_manaCost(ctx, field)
			case "name":
				return ec.fieldContext_MTG_Card_name(ctx, field)
			case "oracleText":
				return ec.fieldContext_MTG_Card_oracleText(ctx, field)
			case "power":
				return ec.fieldContext_MTG_Card_power(ctx, field)
			case "producedMana":
				return ec.fieldContext_MTG_Card_producedMana(ctx, field)
			case "toughness":
				return ec.fieldContext_MTG_Card_toughness(ctx, field)
			case "typeLine":
				return ec.fieldContext_MTG_Card_typeLine(ctx, field)
			case "versions":
				return ec.fieldContext_MTG_Card_versions(ctx, field)
			case "myRating":
				return ec.fieldContext_MTG_Card_myRating(ctx, field)
			case "cardTags":
				return ec.fieldContext_MTG_Card_cardTags(ctx, field)
			case "deckTags":
				return ec.fieldContext_MTG_Card_deckTags(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MTG_Card", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_getMTGCardsFiltered(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getMTGCardsFiltered(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GetMTGCardsFiltered(rctx, fc.Args["filter"].(model.MtgFilterSearchInput), fc.Args["pagination"].(model.MtgFilterPaginationInput), fc.Args["sort"].([]*model.MtgFilterSortInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.MtgFilterSearch)
	fc.Result = res
	return ec.marshalNMTG_Filter_Search2magichelpergraphmodelMtgFilterSearch(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getMTGCardsFiltered(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pagedCards":
				return ec.fieldContext_MTG_Filter_Search_pagedCards(ctx, field)
			case "totalCount":
				return ec.fieldContext_MTG_Filter_Search_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MTG_Filter_Search", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getMTGCardsFiltered_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_getMTGFilters(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getMTGFilters(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GetMTGFilters(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.MtgFilterEntries)
	fc.Result = res
	return ec.marshalNMTG_Filter_Entries2magichelpergraphmodelMtgFilterEntries(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getMTGFilters(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "types":
				return ec.fieldContext_MTG_Filter_Entries_types(ctx, field)
			case "expansions":
				return ec.fieldContext_MTG_Filter_Entries_expansions(ctx, field)
			case "legality":
				return ec.fieldContext_MTG_Filter_Entries_legality(ctx, field)
			case "layouts":
				return ec.fieldContext_MTG_Filter_Entries_layouts(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MTG_Filter_Entries", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_getMTGDecks(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getMTGDecks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GetMTGDecks(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.MtgDeckDashboard)
	fc.Result = res
	return ec.marshalNMTG_DeckDashboard2magichelpergraphmodelMtgDeckDashboard(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getMTGDecks(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ID":
				return ec.fieldContext_MTG_DeckDashboard_ID(ctx, field)
			case "name":
				return ec.fieldContext_MTG_DeckDashboard_name(ctx, field)
			case "cardFrontImage":
				return ec.fieldContext_MTG_DeckDashboard_cardFrontImage(ctx, field)
			case "cards":
				return ec.fieldContext_MTG_DeckDashboard_cards(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MTG_DeckDashboard", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_getMTGDeck(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getMTGDeck(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GetMTGDeck(rctx, fc.Args["deckID"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.MtgDeck)
	fc.Result = res
	return ec.marshalNMTG_Deck2magichelpergraphmodelMtgDeck(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getMTGDeck(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ID":
				return ec.fieldContext_MTG_Deck_ID(ctx, field)
			case "name":
				return ec.fieldContext_MTG_Deck_name(ctx, field)
			case "cardFrontImage":
				return ec.fieldContext_MTG_Deck_cardFrontImage(ctx, field)
			case "cards":
				return ec.fieldContext_MTG_Deck_cards(ctx, field)
			case "zones":
				return ec.fieldContext_MTG_Deck_zones(ctx, field)
			case "ignoredCards":
				return ec.fieldContext_MTG_Deck_ignoredCards(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MTG_Deck", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getMTGDeck_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_getMTGCardPackages(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_getMTGCardPackages(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GetMTGCardPackages(rctx, fc.Args["cardPackageID"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.MtgCardPackage)
	fc.Result = res
	return ec.marshalNMTG_CardPackage2magichelpergraphmodelMtgCardPackage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_getMTGCardPackages(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ID":
				return ec.fieldContext_MTG_CardPackage_ID(ctx, field)
			case "name":
				return ec.fieldContext_MTG_CardPackage_name(ctx, field)
			case "cards":
				return ec.fieldContext_MTG_CardPackage_cards(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MTG_CardPackage", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_getMTGCardPackages_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_tags(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_tags(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Tags(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.Tag)
	fc.Result = res
	return ec.marshalNTag2magichelpergraphmodelTag(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_tags(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_cardTags(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_cardTags(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().CardTags(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.CardTag)
	fc.Result = res
	return ec.marshalNCardTag2magichelpergraphmodelCardTag(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_cardTags(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ID":
				return ec.fieldContext_CardTag_ID(ctx, field)
			case "name":
				return ec.fieldContext_CardTag_name(ctx, field)
			case "description":
				return ec.fieldContext_CardTag_description(ctx, field)
			case "myRating":
				return ec.fieldContext_CardTag_myRating(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CardTag", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_deckTags(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_deckTags(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().DeckTags(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.DeckTag)
	fc.Result = res
	return ec.marshalNDeckTag2magichelpergraphmodelDeckTag(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_deckTags(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ID":
				return ec.fieldContext_DeckTag_ID(ctx, field)
			case "name":
				return ec.fieldContext_DeckTag_name(ctx, field)
			case "description":
				return ec.fieldContext_DeckTag_description(ctx, field)
			case "myRating":
				return ec.fieldContext_DeckTag_myRating(ctx, field)
			case "colors":
				return ec.fieldContext_DeckTag_colors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DeckTag", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_tag(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_tag(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Tag(rctx, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.Tag)
	fc.Result = res
	return ec.marshalOTag2magichelpergraphmodelTag(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_tag(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_tag_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(fc.Args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query___type_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___schema(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	fc.Result = res
	return ec.marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___schema(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "description":
				return ec.fieldContext___Schema_description(ctx, field)
			case "types":
				return ec.fieldContext___Schema_types(ctx, field)
			case "queryType":
				return ec.fieldContext___Schema_queryType(ctx, field)
			case "mutationType":
				return ec.fieldContext___Schema_mutationType(ctx, field)
			case "subscriptionType":
				return ec.fieldContext___Schema_subscriptionType(ctx, field)
			case "directives":
				return ec.fieldContext___Schema_directives(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Schema", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Response_status(ctx context.Context, field graphql.CollectedField, obj *model.Response) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Response_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Response_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Response",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Response_message(ctx context.Context, field graphql.CollectedField, obj *model.Response) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Response_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Response_message(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Response",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_ID(ctx context.Context, field graphql.CollectedField, obj *model.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_ID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_ID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserRating_user(ctx context.Context, field graphql.CollectedField, obj *model.UserRating) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserRating_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.User, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.User)
	fc.Result = res
	return ec.marshalNUser2magichelpergraphmodelUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserRating_user(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserRating",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ID":
				return ec.fieldContext_User_ID(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserRating_value(ctx context.Context, field graphql.CollectedField, obj *model.UserRating) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserRating_value(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Value, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserRating_value(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserRating",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_locations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalN__DirectiveLocation2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_locations(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __DirectiveLocation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___InputValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___InputValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Directive_args_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_isRepeatable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRepeatable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_isRepeatable(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_isDeprecated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_deprecationReason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___InputValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___InputValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Field_args_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_isDeprecated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_deprecationReason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_defaultValue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_defaultValue(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_isDeprecated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_deprecationReason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_types(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_types(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_queryType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_queryType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_mutationType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_mutationType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_subscriptionType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_subscriptionType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_directives(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	fc.Result = res
	return ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_directives(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Directive_name(ctx, field)
			case "description":
				return ec.fieldContext___Directive_description(ctx, field)
			case "locations":
				return ec.fieldContext___Directive_locations(ctx, field)
			case "args":
				return ec.fieldContext___Directive_args(ctx, field)
			case "isRepeatable":
				return ec.fieldContext___Directive_isRepeatable(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Directive", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_kind(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalN__TypeKind2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_kind(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __TypeKind does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_fields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	fc.Result = res
	return ec.marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_fields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Field_name(ctx, field)
			case "description":
				return ec.fieldContext___Field_description(ctx, field)
			case "args":
				return ec.fieldContext___Field_args(ctx, field)
			case "type":
				return ec.fieldContext___Field_type(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___Field_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___Field_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Field", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_fields_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_interfaces(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_interfaces(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_possibleTypes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_possibleTypes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_enumValues(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	fc.Result = res
	return ec.marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_enumValues(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___EnumValue_name(ctx, field)
			case "description":
				return ec.fieldContext___EnumValue_description(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___EnumValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___EnumValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __EnumValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_enumValues_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_inputFields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_inputFields(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___InputValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___InputValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_ofType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_ofType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_specifiedByURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpecifiedByURL(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_specifiedByURL(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_isOneOf(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_isOneOf(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsOneOf(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_isOneOf(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputAddIgnoredCardInput(ctx context.Context, obj any) (model.AddIgnoredCardInput, error) {
	var it model.AddIgnoredCardInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"cardID", "deckID"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "cardID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cardID"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CardID = data
		case "deckID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deckID"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeckID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputAssignTagInput(ctx context.Context, obj any) (model.AssignTagInput, error) {
	var it model.AssignTagInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"tagID", "cardID"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "tagID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tagID"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TagID = data
		case "cardID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cardID"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CardID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateTagInput(ctx context.Context, obj any) (model.CreateTagInput, error) {
	var it model.CreateTagInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"type", "name", "description", "colors", "cardID"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalNTagType2magichelpergraphmodelTagType(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "colors":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("colors"))
			data, err := ec.unmarshalOMTG_Color2magichelpergraphmodelMtgColor(ctx, v)
			if err != nil {
				return it, err
			}
			it.Colors = data
		case "cardID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cardID"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CardID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputFlowZoneInput(ctx context.Context, obj any) (model.FlowZoneInput, error) {
	var it model.FlowZoneInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"ID", "name", "position", "width", "height", "cardChildren", "zoneChildren"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "ID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ID"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "position":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("position"))
			data, err := ec.unmarshalNPositionInput2magichelpergraphmodelPositionInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Position = data
		case "width":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("width"))
			data, err := ec.unmarshalNFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Width = data
		case "height":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("height"))
			data, err := ec.unmarshalNFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Height = data
		case "cardChildren":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cardChildren"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CardChildren = data
		case "zoneChildren":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("zoneChildren"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ZoneChildren = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMTG_AddCardToCardPackageInput(ctx context.Context, obj any) (model.MtgAddCardToCardPackageInput, error) {
	var it model.MtgAddCardToCardPackageInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"cardPackageID", "card", "count"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "cardPackageID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cardPackageID"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CardPackageID = data
		case "card":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("card"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Card = data
		case "count":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("count"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Count = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMTG_CardPackageCardInput(ctx context.Context, obj any) (model.MtgCardPackageCardInput, error) {
	var it model.MtgCardPackageCardInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"card", "selectedVersionID", "count", "mainOrSide"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "card":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("card"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Card = data
		case "selectedVersionID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("selectedVersionID"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SelectedVersionID = data
		case "count":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("count"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Count = data
		case "mainOrSide":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("mainOrSide"))
			data, err := ec.unmarshalNMainOrSide2magichelpergraphmodelMainOrSide(ctx, v)
			if err != nil {
				return it, err
			}
			it.MainOrSide = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMTG_CreateCardPackageInput(ctx context.Context, obj any) (model.MtgCreateCardPackageInput, error) {
	var it model.MtgCreateCardPackageInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMTG_CreateDeckInput(ctx context.Context, obj any) (model.MtgCreateDeckInput, error) {
	var it model.MtgCreateDeckInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMTG_DeckCardFrontImageInput(ctx context.Context, obj any) (model.MtgDeckCardFrontImageInput, error) {
	var it model.MtgDeckCardFrontImageInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"cardID", "versionID"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "cardID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cardID"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CardID = data
		case "versionID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("versionID"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.VersionID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMTG_DeckCardInput(ctx context.Context, obj any) (model.MtgDeckCardInput, error) {
	var it model.MtgDeckCardInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"ID", "card", "selectedVersionID", "count", "position", "mainOrSide", "deckCardType", "phantoms"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "ID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ID"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "card":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("card"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Card = data
		case "selectedVersionID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("selectedVersionID"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SelectedVersionID = data
		case "count":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("count"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Count = data
		case "position":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("position"))
			data, err := ec.unmarshalNPositionInput2magichelpergraphmodelPositionInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Position = data
		case "mainOrSide":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("mainOrSide"))
			data, err := ec.unmarshalNMainOrSide2magichelpergraphmodelMainOrSide(ctx, v)
			if err != nil {
				return it, err
			}
			it.MainOrSide = data
		case "deckCardType":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deckCardType"))
			data, err := ec.unmarshalNMTG_DeckCardType2magichelpergraphmodelMtgDeckCardType(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeckCardType = data
		case "phantoms":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("phantoms"))
			data, err := ec.unmarshalNPhantomInput2magichelpergraphmodelPhantomInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Phantoms = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMTG_DeleteCardPackageInput(ctx context.Context, obj any) (model.MtgDeleteCardPackageInput, error) {
	var it model.MtgDeleteCardPackageInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"cardPackageID"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "cardPackageID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cardPackageID"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CardPackageID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMTG_DeleteDeckInput(ctx context.Context, obj any) (model.MtgDeleteDeckInput, error) {
	var it model.MtgDeleteDeckInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"deckID"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "deckID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deckID"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeckID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMTG_Filter_CardTypeInput(ctx context.Context, obj any) (model.MtgFilterCardTypeInput, error) {
	var it model.MtgFilterCardTypeInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"cardType", "value"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "cardType":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cardType"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CardType = data
		case "value":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalNTernaryBoolean2magichelpergraphmodelTernaryBoolean(ctx, v)
			if err != nil {
				return it, err
			}
			it.Value = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMTG_Filter_ColorInput(ctx context.Context, obj any) (model.MtgFilterColorInput, error) {
	var it model.MtgFilterColorInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"color", "value"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "color":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("color"))
			data, err := ec.unmarshalNMTG_Color2magichelpergraphmodelMtgColor(ctx, v)
			if err != nil {
				return it, err
			}
			it.Color = data
		case "value":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalNTernaryBoolean2magichelpergraphmodelTernaryBoolean(ctx, v)
			if err != nil {
				return it, err
			}
			it.Value = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMTG_Filter_GameInput(ctx context.Context, obj any) (model.MtgFilterGameInput, error) {
	var it model.MtgFilterGameInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"game", "value"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "game":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("game"))
			data, err := ec.unmarshalNMTG_Game2magichelpergraphmodelMtgGame(ctx, v)
			if err != nil {
				return it, err
			}
			it.Game = data
		case "value":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalNTernaryBoolean2magichelpergraphmodelTernaryBoolean(ctx, v)
			if err != nil {
				return it, err
			}
			it.Value = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMTG_Filter_LayoutInput(ctx context.Context, obj any) (model.MtgFilterLayoutInput, error) {
	var it model.MtgFilterLayoutInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"layout", "value"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "layout":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("layout"))
			data, err := ec.unmarshalNMTG_Layout2magichelpergraphmodelMtgLayout(ctx, v)
			if err != nil {
				return it, err
			}
			it.Layout = data
		case "value":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalNTernaryBoolean2magichelpergraphmodelTernaryBoolean(ctx, v)
			if err != nil {
				return it, err
			}
			it.Value = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMTG_Filter_LegalityEntryInput(ctx context.Context, obj any) (model.MtgFilterLegalityEntryInput, error) {
	var it model.MtgFilterLegalityEntryInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"legalityValue", "value"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "legalityValue":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("legalityValue"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.LegalityValue = data
		case "value":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalNTernaryBoolean2magichelpergraphmodelTernaryBoolean(ctx, v)
			if err != nil {
				return it, err
			}
			it.Value = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMTG_Filter_LegalityInput(ctx context.Context, obj any) (model.MtgFilterLegalityInput, error) {
	var it model.MtgFilterLegalityInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"format", "legalityEntries"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "format":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("format"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Format = data
		case "legalityEntries":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("legalityEntries"))
			data, err := ec.unmarshalNMTG_Filter_LegalityEntryInput2magichelpergraphmodelMtgFilterLegalityEntryInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.LegalityEntries = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMTG_Filter_ManaCostInput(ctx context.Context, obj any) (model.MtgFilterManaCostInput, error) {
	var it model.MtgFilterManaCostInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"manaCost", "value"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "manaCost":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("manaCost"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ManaCost = data
		case "value":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalNTernaryBoolean2magichelpergraphmodelTernaryBoolean(ctx, v)
			if err != nil {
				return it, err
			}
			it.Value = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMTG_Filter_PaginationInput(ctx context.Context, obj any) (model.MtgFilterPaginationInput, error) {
	var it model.MtgFilterPaginationInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"page", "pageSize"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "page":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("page"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Page = data
		case "pageSize":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pageSize"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.PageSize = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMTG_Filter_RarityInput(ctx context.Context, obj any) (model.MtgFilterRarityInput, error) {
	var it model.MtgFilterRarityInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"rarity", "value"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "rarity":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rarity"))
			data, err := ec.unmarshalNMTG_Rarity2magichelpergraphmodelMtgRarity(ctx, v)
			if err != nil {
				return it, err
			}
			it.Rarity = data
		case "value":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalNTernaryBoolean2magichelpergraphmodelTernaryBoolean(ctx, v)
			if err != nil {
				return it, err
			}
			it.Value = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMTG_Filter_RatingInput(ctx context.Context, obj any) (model.MtgFilterRatingInput, error) {
	var it model.MtgFilterRatingInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"min", "max"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "min":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("min"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Min = data
		case "max":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("max"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Max = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMTG_Filter_SearchInput(ctx context.Context, obj any) (model.MtgFilterSearchInput, error) {
	var it model.MtgFilterSearchInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"searchString", "rarity", "color", "multiColor", "manaCosts", "cardTypes", "subtypes", "sets", "legalities", "layouts", "games", "hideIgnored", "tags", "rating", "commander", "deckID", "isSelectingCommander"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "searchString":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("searchString"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.SearchString = data
		case "rarity":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rarity"))
			data, err := ec.unmarshalNMTG_Filter_RarityInput2magichelpergraphmodelMtgFilterRarityInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Rarity = data
		case "color":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("color"))
			data, err := ec.unmarshalNMTG_Filter_ColorInput2magichelpergraphmodelMtgFilterColorInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Color = data
		case "multiColor":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("multiColor"))
			data, err := ec.unmarshalNTernaryBoolean2magichelpergraphmodelTernaryBoolean(ctx, v)
			if err != nil {
				return it, err
			}
			it.MultiColor = data
		case "manaCosts":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("manaCosts"))
			data, err := ec.unmarshalNMTG_Filter_ManaCostInput2magichelpergraphmodelMtgFilterManaCostInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.ManaCosts = data
		case "cardTypes":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cardTypes"))
			data, err := ec.unmarshalNMTG_Filter_CardTypeInput2magichelpergraphmodelMtgFilterCardTypeInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.CardTypes = data
		case "subtypes":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subtypes"))
			data, err := ec.unmarshalNMTG_Filter_SubtypeInput2magichelpergraphmodelMtgFilterSubtypeInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Subtypes = data
		case "sets":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sets"))
			data, err := ec.unmarshalNMTG_Filter_SetInput2magichelpergraphmodelMtgFilterSetInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Sets = data
		case "legalities":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("legalities"))
			data, err := ec.unmarshalNMTG_Filter_LegalityInput2magichelpergraphmodelMtgFilterLegalityInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Legalities = data
		case "layouts":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("layouts"))
			data, err := ec.unmarshalNMTG_Filter_LayoutInput2magichelpergraphmodelMtgFilterLayoutInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Layouts = data
		case "games":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("games"))
			data, err := ec.unmarshalNMTG_Filter_GameInput2magichelpergraphmodelMtgFilterGameInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Games = data
		case "hideIgnored":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hideIgnored"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HideIgnored = data
		case "tags":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tags"))
			data, err := ec.unmarshalNMTG_Filter_TagInput2magichelpergraphmodelMtgFilterTagInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Tags = data
		case "rating":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rating"))
			data, err := ec.unmarshalNMTG_Filter_RatingInput2magichelpergraphmodelMtgFilterRatingInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Rating = data
		case "commander":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("commander"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Commander = data
		case "deckID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deckID"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeckID = data
		case "isSelectingCommander":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isSelectingCommander"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsSelectingCommander = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMTG_Filter_SetInput(ctx context.Context, obj any) (model.MtgFilterSetInput, error) {
	var it model.MtgFilterSetInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"set", "value"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "set":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("set"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Set = data
		case "value":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalNTernaryBoolean2magichelpergraphmodelTernaryBoolean(ctx, v)
			if err != nil {
				return it, err
			}
			it.Value = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMTG_Filter_SortInput(ctx context.Context, obj any) (model.MtgFilterSortInput, error) {
	var it model.MtgFilterSortInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"sortBy", "sortDirection", "enabled"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "sortBy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sortBy"))
			data, err := ec.unmarshalNMTG_Filter_SortBy2magichelpergraphmodelMtgFilterSortBy(ctx, v)
			if err != nil {
				return it, err
			}
			it.SortBy = data
		case "sortDirection":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sortDirection"))
			data, err := ec.unmarshalNMTG_Filter_SortDirection2magichelpergraphmodelMtgFilterSortDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.SortDirection = data
		case "enabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("enabled"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Enabled = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMTG_Filter_SubtypeInput(ctx context.Context, obj any) (model.MtgFilterSubtypeInput, error) {
	var it model.MtgFilterSubtypeInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"subtype", "value"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "subtype":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subtype"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Subtype = data
		case "value":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalNTernaryBoolean2magichelpergraphmodelTernaryBoolean(ctx, v)
			if err != nil {
				return it, err
			}
			it.Value = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMTG_Filter_TagInput(ctx context.Context, obj any) (model.MtgFilterTagInput, error) {
	var it model.MtgFilterTagInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"tag", "value"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "tag":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tag"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Tag = data
		case "value":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalNTernaryBoolean2magichelpergraphmodelTernaryBoolean(ctx, v)
			if err != nil {
				return it, err
			}
			it.Value = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMTG_RemoveCardFromCardPackageInput(ctx context.Context, obj any) (model.MtgRemoveCardFromCardPackageInput, error) {
	var it model.MtgRemoveCardFromCardPackageInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"cardPackageID", "card"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "cardPackageID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cardPackageID"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CardPackageID = data
		case "card":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("card"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Card = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMTG_UpdateDeckInput(ctx context.Context, obj any) (model.MtgUpdateDeckInput, error) {
	var it model.MtgUpdateDeckInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"deckID", "name", "cardFrontImage", "cards", "zones"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "deckID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deckID"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeckID = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "cardFrontImage":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cardFrontImage"))
			data, err := ec.unmarshalOMTG_DeckCardFrontImageInput2magichelpergraphmodelMtgDeckCardFrontImageInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.CardFrontImage = data
		case "cards":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cards"))
			data, err := ec.unmarshalNMTG_DeckCardInput2magichelpergraphmodelMtgDeckCardInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Cards = data
		case "zones":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("zones"))
			data, err := ec.unmarshalNFlowZoneInput2magichelpergraphmodelFlowZoneInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Zones = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPhantomInput(ctx context.Context, obj any) (model.PhantomInput, error) {
	var it model.PhantomInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"ID", "position"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "ID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ID"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "position":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("position"))
			data, err := ec.unmarshalNPositionInput2magichelpergraphmodelPositionInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Position = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPositionInput(ctx context.Context, obj any) (model.PositionInput, error) {
	var it model.PositionInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"x", "y"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "x":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("x"))
			data, err := ec.unmarshalNFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.X = data
		case "y":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("y"))
			data, err := ec.unmarshalNFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Y = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRateInput(ctx context.Context, obj any) (model.RateInput, error) {
	var it model.RateInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"entityID", "entityType", "value"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "entityID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("entityID"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.EntityID = data
		case "entityType":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("entityType"))
			data, err := ec.unmarshalNRatableEntityType2magichelpergraphmodelRatableEntityType(ctx, v)
			if err != nil {
				return it, err
			}
			it.EntityType = data
		case "value":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Value = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRemoveIgnoredCardInput(ctx context.Context, obj any) (model.RemoveIgnoredCardInput, error) {
	var it model.RemoveIgnoredCardInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"cardID", "deckID"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "cardID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cardID"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CardID = data
		case "deckID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deckID"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeckID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUnassignTagInput(ctx context.Context, obj any) (model.UnassignTagInput, error) {
	var it model.UnassignTagInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"tagID", "cardID"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "tagID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tagID"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TagID = data
		case "cardID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cardID"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CardID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateTagInput(ctx context.Context, obj any) (model.UpdateTagInput, error) {
	var it model.UpdateTagInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"ID", "name", "description", "colors"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "ID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ID"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "colors":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("colors"))
			data, err := ec.unmarshalOMTG_Color2magichelpergraphmodelMtgColor(ctx, v)
			if err != nil {
				return it, err
			}
			it.Colors = data
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

func (ec *executionContext) _Tag(ctx context.Context, sel ast.SelectionSet, obj model.Tag) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.DeckTag:
		return ec._DeckTag(ctx, sel, &obj)
	case *model.DeckTag:
		if obj == nil {
			return graphql.Null
		}
		return ec._DeckTag(ctx, sel, obj)
	case model.CardTag:
		return ec._CardTag(ctx, sel, &obj)
	case *model.CardTag:
		if obj == nil {
			return graphql.Null
		}
		return ec._CardTag(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var cardTagImplementors = []string{"CardTag", "Tag"}

func (ec *executionContext) _CardTag(ctx context.Context, sel ast.SelectionSet, obj *model.CardTag) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, cardTagImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CardTag")
		case "ID":
			out.Values[i] = ec._CardTag_ID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._CardTag_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec._CardTag_description(ctx, field, obj)
		case "myRating":
			out.Values[i] = ec._CardTag_myRating(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var deckTagImplementors = []string{"DeckTag", "Tag"}

func (ec *executionContext) _DeckTag(ctx context.Context, sel ast.SelectionSet, obj *model.DeckTag) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, deckTagImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DeckTag")
		case "ID":
			out.Values[i] = ec._DeckTag_ID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._DeckTag_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec._DeckTag_description(ctx, field, obj)
		case "myRating":
			out.Values[i] = ec._DeckTag_myRating(ctx, field, obj)
		case "colors":
			out.Values[i] = ec._DeckTag_colors(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var flowZoneImplementors = []string{"FlowZone"}

func (ec *executionContext) _FlowZone(ctx context.Context, sel ast.SelectionSet, obj *model.FlowZone) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, flowZoneImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FlowZone")
		case "ID":
			out.Values[i] = ec._FlowZone_ID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._FlowZone_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "position":
			out.Values[i] = ec._FlowZone_position(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "width":
			out.Values[i] = ec._FlowZone_width(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "height":
			out.Values[i] = ec._FlowZone_height(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "cardChildren":
			out.Values[i] = ec._FlowZone_cardChildren(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "zoneChildren":
			out.Values[i] = ec._FlowZone_zoneChildren(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mTG_CardImplementors = []string{"MTG_Card"}

func (ec *executionContext) _MTG_Card(ctx context.Context, sel ast.SelectionSet, obj *model.MtgCard) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mTG_CardImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MTG_Card")
		case "ID":
			out.Values[i] = ec._MTG_Card_ID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "layout":
			out.Values[i] = ec._MTG_Card_layout(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "CMC":
			out.Values[i] = ec._MTG_Card_CMC(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "colorIdentity":
			out.Values[i] = ec._MTG_Card_colorIdentity(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "colorIndicator":
			out.Values[i] = ec._MTG_Card_colorIndicator(ctx, field, obj)
		case "colors":
			out.Values[i] = ec._MTG_Card_colors(ctx, field, obj)
		case "EDHRecRank":
			out.Values[i] = ec._MTG_Card_EDHRecRank(ctx, field, obj)
		case "keywords":
			out.Values[i] = ec._MTG_Card_keywords(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "loyalty":
			out.Values[i] = ec._MTG_Card_loyalty(ctx, field, obj)
		case "manaCost":
			out.Values[i] = ec._MTG_Card_manaCost(ctx, field, obj)
		case "name":
			out.Values[i] = ec._MTG_Card_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "oracleText":
			out.Values[i] = ec._MTG_Card_oracleText(ctx, field, obj)
		case "power":
			out.Values[i] = ec._MTG_Card_power(ctx, field, obj)
		case "producedMana":
			out.Values[i] = ec._MTG_Card_producedMana(ctx, field, obj)
		case "toughness":
			out.Values[i] = ec._MTG_Card_toughness(ctx, field, obj)
		case "typeLine":
			out.Values[i] = ec._MTG_Card_typeLine(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "versions":
			out.Values[i] = ec._MTG_Card_versions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "myRating":
			out.Values[i] = ec._MTG_Card_myRating(ctx, field, obj)
		case "cardTags":
			out.Values[i] = ec._MTG_Card_cardTags(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deckTags":
			out.Values[i] = ec._MTG_Card_deckTags(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mTG_CardFaceImplementors = []string{"MTG_CardFace"}

func (ec *executionContext) _MTG_CardFace(ctx context.Context, sel ast.SelectionSet, obj *model.MtgCardFace) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mTG_CardFaceImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MTG_CardFace")
		case "artist":
			out.Values[i] = ec._MTG_CardFace_artist(ctx, field, obj)
		case "CMC":
			out.Values[i] = ec._MTG_CardFace_CMC(ctx, field, obj)
		case "colorIndicator":
			out.Values[i] = ec._MTG_CardFace_colorIndicator(ctx, field, obj)
		case "colors":
			out.Values[i] = ec._MTG_CardFace_colors(ctx, field, obj)
		case "flavorText":
			out.Values[i] = ec._MTG_CardFace_flavorText(ctx, field, obj)
		case "imageUris":
			out.Values[i] = ec._MTG_CardFace_imageUris(ctx, field, obj)
		case "layout":
			out.Values[i] = ec._MTG_CardFace_layout(ctx, field, obj)
		case "loyalty":
			out.Values[i] = ec._MTG_CardFace_loyalty(ctx, field, obj)
		case "manaCost":
			out.Values[i] = ec._MTG_CardFace_manaCost(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._MTG_CardFace_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "oracleText":
			out.Values[i] = ec._MTG_CardFace_oracleText(ctx, field, obj)
		case "power":
			out.Values[i] = ec._MTG_CardFace_power(ctx, field, obj)
		case "toughness":
			out.Values[i] = ec._MTG_CardFace_toughness(ctx, field, obj)
		case "typeLine":
			out.Values[i] = ec._MTG_CardFace_typeLine(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mTG_CardFace_DashboardImplementors = []string{"MTG_CardFace_Dashboard"}

func (ec *executionContext) _MTG_CardFace_Dashboard(ctx context.Context, sel ast.SelectionSet, obj *model.MtgCardFaceDashboard) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mTG_CardFace_DashboardImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MTG_CardFace_Dashboard")
		case "imageUris":
			out.Values[i] = ec._MTG_CardFace_Dashboard_imageUris(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mTG_CardPackageImplementors = []string{"MTG_CardPackage"}

func (ec *executionContext) _MTG_CardPackage(ctx context.Context, sel ast.SelectionSet, obj *model.MtgCardPackage) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mTG_CardPackageImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MTG_CardPackage")
		case "ID":
			out.Values[i] = ec._MTG_CardPackage_ID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._MTG_CardPackage_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "cards":
			out.Values[i] = ec._MTG_CardPackage_cards(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mTG_CardPackageCardImplementors = []string{"MTG_CardPackageCard"}

func (ec *executionContext) _MTG_CardPackageCard(ctx context.Context, sel ast.SelectionSet, obj *model.MtgCardPackageCard) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mTG_CardPackageCardImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MTG_CardPackageCard")
		case "card":
			out.Values[i] = ec._MTG_CardPackageCard_card(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "selectedVersionID":
			out.Values[i] = ec._MTG_CardPackageCard_selectedVersionID(ctx, field, obj)
		case "count":
			out.Values[i] = ec._MTG_CardPackageCard_count(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "mainOrSide":
			out.Values[i] = ec._MTG_CardPackageCard_mainOrSide(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mTG_CardVersionImplementors = []string{"MTG_CardVersion"}

func (ec *executionContext) _MTG_CardVersion(ctx context.Context, sel ast.SelectionSet, obj *model.MtgCardVersion) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mTG_CardVersionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MTG_CardVersion")
		case "ID":
			out.Values[i] = ec._MTG_CardVersion_ID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isDefault":
			out.Values[i] = ec._MTG_CardVersion_isDefault(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isAlchemy":
			out.Values[i] = ec._MTG_CardVersion_isAlchemy(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "artist":
			out.Values[i] = ec._MTG_CardVersion_artist(ctx, field, obj)
		case "lang":
			out.Values[i] = ec._MTG_CardVersion_lang(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "flavorName":
			out.Values[i] = ec._MTG_CardVersion_flavorName(ctx, field, obj)
		case "flavorText":
			out.Values[i] = ec._MTG_CardVersion_flavorText(ctx, field, obj)
		case "cardFaces":
			out.Values[i] = ec._MTG_CardVersion_cardFaces(ctx, field, obj)
		case "legalities":
			out.Values[i] = ec._MTG_CardVersion_legalities(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "games":
			out.Values[i] = ec._MTG_CardVersion_games(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "imageUris":
			out.Values[i] = ec._MTG_CardVersion_imageUris(ctx, field, obj)
		case "rarity":
			out.Values[i] = ec._MTG_CardVersion_rarity(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "releasedAt":
			out.Values[i] = ec._MTG_CardVersion_releasedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "reprint":
			out.Values[i] = ec._MTG_CardVersion_reprint(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "setName":
			out.Values[i] = ec._MTG_CardVersion_setName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "setType":
			out.Values[i] = ec._MTG_CardVersion_setType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "set":
			out.Values[i] = ec._MTG_CardVersion_set(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "setID":
			out.Values[i] = ec._MTG_CardVersion_setID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "variation":
			out.Values[i] = ec._MTG_CardVersion_variation(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "variationOf":
			out.Values[i] = ec._MTG_CardVersion_variationOf(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mTG_CardVersion_DashboardImplementors = []string{"MTG_CardVersion_Dashboard"}

func (ec *executionContext) _MTG_CardVersion_Dashboard(ctx context.Context, sel ast.SelectionSet, obj *model.MtgCardVersionDashboard) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mTG_CardVersion_DashboardImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MTG_CardVersion_Dashboard")
		case "ID":
			out.Values[i] = ec._MTG_CardVersion_Dashboard_ID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isDefault":
			out.Values[i] = ec._MTG_CardVersion_Dashboard_isDefault(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isAlchemy":
			out.Values[i] = ec._MTG_CardVersion_Dashboard_isAlchemy(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "cardFaces":
			out.Values[i] = ec._MTG_CardVersion_Dashboard_cardFaces(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "imageUris":
			out.Values[i] = ec._MTG_CardVersion_Dashboard_imageUris(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mTG_Card_DashboardImplementors = []string{"MTG_Card_Dashboard"}

func (ec *executionContext) _MTG_Card_Dashboard(ctx context.Context, sel ast.SelectionSet, obj *model.MtgCardDashboard) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mTG_Card_DashboardImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MTG_Card_Dashboard")
		case "ID":
			out.Values[i] = ec._MTG_Card_Dashboard_ID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "versions":
			out.Values[i] = ec._MTG_Card_Dashboard_versions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mTG_DeckImplementors = []string{"MTG_Deck"}

func (ec *executionContext) _MTG_Deck(ctx context.Context, sel ast.SelectionSet, obj *model.MtgDeck) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mTG_DeckImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MTG_Deck")
		case "ID":
			out.Values[i] = ec._MTG_Deck_ID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._MTG_Deck_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "cardFrontImage":
			out.Values[i] = ec._MTG_Deck_cardFrontImage(ctx, field, obj)
		case "cards":
			out.Values[i] = ec._MTG_Deck_cards(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "zones":
			out.Values[i] = ec._MTG_Deck_zones(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "ignoredCards":
			out.Values[i] = ec._MTG_Deck_ignoredCards(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mTG_DeckCardImplementors = []string{"MTG_DeckCard"}

func (ec *executionContext) _MTG_DeckCard(ctx context.Context, sel ast.SelectionSet, obj *model.MtgDeckCard) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mTG_DeckCardImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MTG_DeckCard")
		case "card":
			out.Values[i] = ec._MTG_DeckCard_card(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "selectedVersionID":
			out.Values[i] = ec._MTG_DeckCard_selectedVersionID(ctx, field, obj)
		case "count":
			out.Values[i] = ec._MTG_DeckCard_count(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "position":
			out.Values[i] = ec._MTG_DeckCard_position(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "mainOrSide":
			out.Values[i] = ec._MTG_DeckCard_mainOrSide(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deckCardType":
			out.Values[i] = ec._MTG_DeckCard_deckCardType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "phantoms":
			out.Values[i] = ec._MTG_DeckCard_phantoms(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mTG_DeckCard_DashboardImplementors = []string{"MTG_DeckCard_Dashboard"}

func (ec *executionContext) _MTG_DeckCard_Dashboard(ctx context.Context, sel ast.SelectionSet, obj *model.MtgDeckCardDashboard) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mTG_DeckCard_DashboardImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MTG_DeckCard_Dashboard")
		case "card":
			out.Values[i] = ec._MTG_DeckCard_Dashboard_card(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "selectedVersionID":
			out.Values[i] = ec._MTG_DeckCard_Dashboard_selectedVersionID(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mTG_DeckDashboardImplementors = []string{"MTG_DeckDashboard"}

func (ec *executionContext) _MTG_DeckDashboard(ctx context.Context, sel ast.SelectionSet, obj *model.MtgDeckDashboard) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mTG_DeckDashboardImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MTG_DeckDashboard")
		case "ID":
			out.Values[i] = ec._MTG_DeckDashboard_ID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._MTG_DeckDashboard_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "cardFrontImage":
			out.Values[i] = ec._MTG_DeckDashboard_cardFrontImage(ctx, field, obj)
		case "cards":
			out.Values[i] = ec._MTG_DeckDashboard_cards(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mTG_Deck_CardFrontImageImplementors = []string{"MTG_Deck_CardFrontImage"}

func (ec *executionContext) _MTG_Deck_CardFrontImage(ctx context.Context, sel ast.SelectionSet, obj *model.MtgDeckCardFrontImage) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mTG_Deck_CardFrontImageImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MTG_Deck_CardFrontImage")
		case "cardID":
			out.Values[i] = ec._MTG_Deck_CardFrontImage_cardID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "versionID":
			out.Values[i] = ec._MTG_Deck_CardFrontImage_versionID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "image":
			out.Values[i] = ec._MTG_Deck_CardFrontImage_image(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mTG_Filter_CardTypesImplementors = []string{"MTG_Filter_CardTypes"}

func (ec *executionContext) _MTG_Filter_CardTypes(ctx context.Context, sel ast.SelectionSet, obj *model.MtgFilterCardTypes) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mTG_Filter_CardTypesImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MTG_Filter_CardTypes")
		case "cardType":
			out.Values[i] = ec._MTG_Filter_CardTypes_cardType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "subtypes":
			out.Values[i] = ec._MTG_Filter_CardTypes_subtypes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mTG_Filter_EntriesImplementors = []string{"MTG_Filter_Entries"}

func (ec *executionContext) _MTG_Filter_Entries(ctx context.Context, sel ast.SelectionSet, obj *model.MtgFilterEntries) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mTG_Filter_EntriesImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MTG_Filter_Entries")
		case "types":
			out.Values[i] = ec._MTG_Filter_Entries_types(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "expansions":
			out.Values[i] = ec._MTG_Filter_Entries_expansions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "legality":
			out.Values[i] = ec._MTG_Filter_Entries_legality(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "layouts":
			out.Values[i] = ec._MTG_Filter_Entries_layouts(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mTG_Filter_ExpansionImplementors = []string{"MTG_Filter_Expansion"}

func (ec *executionContext) _MTG_Filter_Expansion(ctx context.Context, sel ast.SelectionSet, obj *model.MtgFilterExpansion) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mTG_Filter_ExpansionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MTG_Filter_Expansion")
		case "set":
			out.Values[i] = ec._MTG_Filter_Expansion_set(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "setName":
			out.Values[i] = ec._MTG_Filter_Expansion_setName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "releasedAt":
			out.Values[i] = ec._MTG_Filter_Expansion_releasedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "imageURL":
			out.Values[i] = ec._MTG_Filter_Expansion_imageURL(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "setType":
			out.Values[i] = ec._MTG_Filter_Expansion_setType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "games":
			out.Values[i] = ec._MTG_Filter_Expansion_games(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mTG_Filter_LegalityImplementors = []string{"MTG_Filter_Legality"}

func (ec *executionContext) _MTG_Filter_Legality(ctx context.Context, sel ast.SelectionSet, obj *model.MtgFilterLegality) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mTG_Filter_LegalityImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MTG_Filter_Legality")
		case "formats":
			out.Values[i] = ec._MTG_Filter_Legality_formats(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "legalityValues":
			out.Values[i] = ec._MTG_Filter_Legality_legalityValues(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mTG_Filter_SearchImplementors = []string{"MTG_Filter_Search"}

func (ec *executionContext) _MTG_Filter_Search(ctx context.Context, sel ast.SelectionSet, obj *model.MtgFilterSearch) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mTG_Filter_SearchImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MTG_Filter_Search")
		case "pagedCards":
			out.Values[i] = ec._MTG_Filter_Search_pagedCards(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._MTG_Filter_Search_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mTG_ImageImplementors = []string{"MTG_Image"}

func (ec *executionContext) _MTG_Image(ctx context.Context, sel ast.SelectionSet, obj *model.MtgImage) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mTG_ImageImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MTG_Image")
		case "artCrop":
			out.Values[i] = ec._MTG_Image_artCrop(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "borderCrop":
			out.Values[i] = ec._MTG_Image_borderCrop(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "large":
			out.Values[i] = ec._MTG_Image_large(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "normal":
			out.Values[i] = ec._MTG_Image_normal(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "PNG":
			out.Values[i] = ec._MTG_Image_PNG(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "small":
			out.Values[i] = ec._MTG_Image_small(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mutationImplementors = []string{"Mutation"}

func (ec *executionContext) _Mutation(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mutationImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Mutation",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mutation")
		case "createMTGDeck":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createMTGDeck(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteMTGDeck":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteMTGDeck(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateMTGDeck":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateMTGDeck(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "saveMTGDeckAsCopy":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_saveMTGDeckAsCopy(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createMTGCardPackage":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createMTGCardPackage(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteMTGCardPackage":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteMTGCardPackage(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "addMTGCardToCardPackage":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_addMTGCardToCardPackage(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "removeMTGCardFromCardPackage":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_removeMTGCardFromCardPackage(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createTag":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createTag(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateTag":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateTag(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteTag":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteTag(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "assignTag":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_assignTag(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "unassignTag":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_unassignTag(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "rate":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_rate(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "addIgnoredCard":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_addIgnoredCard(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "removeIgnoredCard":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_removeIgnoredCard(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var phantomImplementors = []string{"Phantom"}

func (ec *executionContext) _Phantom(ctx context.Context, sel ast.SelectionSet, obj *model.Phantom) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, phantomImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Phantom")
		case "position":
			out.Values[i] = ec._Phantom_position(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "ID":
			out.Values[i] = ec._Phantom_ID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var positionImplementors = []string{"Position"}

func (ec *executionContext) _Position(ctx context.Context, sel ast.SelectionSet, obj *model.Position) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, positionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Position")
		case "x":
			out.Values[i] = ec._Position_x(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "y":
			out.Values[i] = ec._Position_y(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "getMTGCards":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getMTGCards(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getMTGCardsFiltered":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getMTGCardsFiltered(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getMTGFilters":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getMTGFilters(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getMTGDecks":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getMTGDecks(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getMTGDeck":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getMTGDeck(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "getMTGCardPackages":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_getMTGCardPackages(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "tags":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_tags(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "cardTags":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_cardTags(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "deckTags":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_deckTags(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "tag":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_tag(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "__type":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___type(ctx, field)
			})
		case "__schema":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___schema(ctx, field)
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var responseImplementors = []string{"Response"}

func (ec *executionContext) _Response(ctx context.Context, sel ast.SelectionSet, obj *model.Response) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, responseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Response")
		case "status":
			out.Values[i] = ec._Response_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._Response_message(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var userImplementors = []string{"User"}

func (ec *executionContext) _User(ctx context.Context, sel ast.SelectionSet, obj *model.User) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("User")
		case "ID":
			out.Values[i] = ec._User_ID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var userRatingImplementors = []string{"UserRating"}

func (ec *executionContext) _UserRating(ctx context.Context, sel ast.SelectionSet, obj *model.UserRating) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userRatingImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UserRating")
		case "user":
			out.Values[i] = ec._UserRating_user(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "value":
			out.Values[i] = ec._UserRating_value(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __DirectiveImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Directive_description(ctx, field, obj)
		case "locations":
			out.Values[i] = ec.___Directive_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "args":
			out.Values[i] = ec.___Directive_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isRepeatable":
			out.Values[i] = ec.___Directive_isRepeatable(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __EnumValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __FieldImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Field_description(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Field_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec.___Field_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __InputValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___InputValue_description(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___InputValue_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___InputValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___InputValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __SchemaImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "description":
			out.Values[i] = ec.___Schema_description(ctx, field, obj)
		case "types":
			out.Values[i] = ec.___Schema_types(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)
		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)
		case "directives":
			out.Values[i] = ec.___Schema_directives(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __TypeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec.___Type_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Type_description(ctx, field, obj)
		case "fields":
			out.Values[i] = ec.___Type_fields(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)
		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)
		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)
		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)
		case "ofType":
			out.Values[i] = ec.___Type_ofType(ctx, field, obj)
		case "specifiedByURL":
			out.Values[i] = ec.___Type_specifiedByURL(ctx, field, obj)
		case "isOneOf":
			out.Values[i] = ec.___Type_isOneOf(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) unmarshalNAddIgnoredCardInput2magichelpergraphmodelAddIgnoredCardInput(ctx context.Context, v any) (model.AddIgnoredCardInput, error) {
	res, err := ec.unmarshalInputAddIgnoredCardInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNAssignTagInput2magichelpergraphmodelAssignTagInput(ctx context.Context, v any) (model.AssignTagInput, error) {
	res, err := ec.unmarshalInputAssignTagInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v any) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNCardTag2magichelpergraphmodelCardTag(ctx context.Context, sel ast.SelectionSet, v []*model.CardTag) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNCardTag2magichelpergraphmodelCardTag(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNCardTag2magichelpergraphmodelCardTag(ctx context.Context, sel ast.SelectionSet, v *model.CardTag) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CardTag(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCreateTagInput2magichelpergraphmodelCreateTagInput(ctx context.Context, v any) (model.CreateTagInput, error) {
	res, err := ec.unmarshalInputCreateTagInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDeckTag2magichelpergraphmodelDeckTag(ctx context.Context, sel ast.SelectionSet, v []*model.DeckTag) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNDeckTag2magichelpergraphmodelDeckTag(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNDeckTag2magichelpergraphmodelDeckTag(ctx context.Context, sel ast.SelectionSet, v *model.DeckTag) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._DeckTag(ctx, sel, v)
}

func (ec *executionContext) unmarshalNFloat2float64(ctx context.Context, v any) (float64, error) {
	res, err := graphql.UnmarshalFloatContext(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFloat2float64(ctx context.Context, sel ast.SelectionSet, v float64) graphql.Marshaler {
	res := graphql.MarshalFloatContext(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return graphql.WrapContextMarshaler(ctx, res)
}

func (ec *executionContext) marshalNFlowZone2magichelpergraphmodelFlowZone(ctx context.Context, sel ast.SelectionSet, v []*model.FlowZone) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNFlowZone2magichelpergraphmodelFlowZone(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNFlowZone2magichelpergraphmodelFlowZone(ctx context.Context, sel ast.SelectionSet, v *model.FlowZone) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._FlowZone(ctx, sel, v)
}

func (ec *executionContext) unmarshalNFlowZoneInput2magichelpergraphmodelFlowZoneInput(ctx context.Context, v any) ([]*model.FlowZoneInput, error) {
	var vSlice []any
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.FlowZoneInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNFlowZoneInput2magichelpergraphmodelFlowZoneInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNFlowZoneInput2magichelpergraphmodelFlowZoneInput(ctx context.Context, v any) (*model.FlowZoneInput, error) {
	res, err := ec.unmarshalInputFlowZoneInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNID2string(ctx context.Context, v any) (string, error) {
	res, err := graphql.UnmarshalID(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNID2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalID(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNID2string(ctx context.Context, v any) ([]string, error) {
	var vSlice []any
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNID2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNID2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNID2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v any) (int, error) {
	res, err := graphql.UnmarshalInt(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	res := graphql.MarshalInt(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNMTG_AddCardToCardPackageInput2magichelpergraphmodelMtgAddCardToCardPackageInput(ctx context.Context, v any) (model.MtgAddCardToCardPackageInput, error) {
	res, err := ec.unmarshalInputMTG_AddCardToCardPackageInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNMTG_Card2magichelpergraphmodelMtgCard(ctx context.Context, sel ast.SelectionSet, v []*model.MtgCard) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMTG_Card2magichelpergraphmodelMtgCard(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNMTG_Card2magichelpergraphmodelMtgCard(ctx context.Context, sel ast.SelectionSet, v *model.MtgCard) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._MTG_Card(ctx, sel, v)
}

func (ec *executionContext) marshalNMTG_CardFace2magichelpergraphmodelMtgCardFace(ctx context.Context, sel ast.SelectionSet, v *model.MtgCardFace) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._MTG_CardFace(ctx, sel, v)
}

func (ec *executionContext) marshalNMTG_CardFace_Dashboard2magichelpergraphmodelMtgCardFaceDashboard(ctx context.Context, sel ast.SelectionSet, v []*model.MtgCardFaceDashboard) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMTG_CardFace_Dashboard2magichelpergraphmodelMtgCardFaceDashboard(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNMTG_CardFace_Dashboard2magichelpergraphmodelMtgCardFaceDashboard(ctx context.Context, sel ast.SelectionSet, v *model.MtgCardFaceDashboard) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._MTG_CardFace_Dashboard(ctx, sel, v)
}

func (ec *executionContext) marshalNMTG_CardPackage2magichelpergraphmodelMtgCardPackage(ctx context.Context, sel ast.SelectionSet, v []*model.MtgCardPackage) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMTG_CardPackage2magichelpergraphmodelMtgCardPackage(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNMTG_CardPackage2magichelpergraphmodelMtgCardPackage(ctx context.Context, sel ast.SelectionSet, v *model.MtgCardPackage) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._MTG_CardPackage(ctx, sel, v)
}

func (ec *executionContext) marshalNMTG_CardPackageCard2magichelpergraphmodelMtgCardPackageCard(ctx context.Context, sel ast.SelectionSet, v []*model.MtgCardPackageCard) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMTG_CardPackageCard2magichelpergraphmodelMtgCardPackageCard(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNMTG_CardPackageCard2magichelpergraphmodelMtgCardPackageCard(ctx context.Context, sel ast.SelectionSet, v *model.MtgCardPackageCard) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._MTG_CardPackageCard(ctx, sel, v)
}

func (ec *executionContext) marshalNMTG_CardVersion2magichelpergraphmodelMtgCardVersion(ctx context.Context, sel ast.SelectionSet, v []*model.MtgCardVersion) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMTG_CardVersion2magichelpergraphmodelMtgCardVersion(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNMTG_CardVersion2magichelpergraphmodelMtgCardVersion(ctx context.Context, sel ast.SelectionSet, v *model.MtgCardVersion) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._MTG_CardVersion(ctx, sel, v)
}

func (ec *executionContext) marshalNMTG_CardVersion_Dashboard2magichelpergraphmodelMtgCardVersionDashboard(ctx context.Context, sel ast.SelectionSet, v []*model.MtgCardVersionDashboard) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMTG_CardVersion_Dashboard2magichelpergraphmodelMtgCardVersionDashboard(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNMTG_CardVersion_Dashboard2magichelpergraphmodelMtgCardVersionDashboard(ctx context.Context, sel ast.SelectionSet, v *model.MtgCardVersionDashboard) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._MTG_CardVersion_Dashboard(ctx, sel, v)
}

func (ec *executionContext) marshalNMTG_Card_Dashboard2magichelpergraphmodelMtgCardDashboard(ctx context.Context, sel ast.SelectionSet, v *model.MtgCardDashboard) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._MTG_Card_Dashboard(ctx, sel, v)
}

func (ec *executionContext) unmarshalNMTG_Color2magichelpergraphmodelMtgColor(ctx context.Context, v any) (model.MtgColor, error) {
	var res model.MtgColor
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNMTG_Color2magichelpergraphmodelMtgColor(ctx context.Context, sel ast.SelectionSet, v model.MtgColor) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNMTG_Color2magichelpergraphmodelMtgColor(ctx context.Context, v any) ([]model.MtgColor, error) {
	var vSlice []any
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]model.MtgColor, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNMTG_Color2magichelpergraphmodelMtgColor(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNMTG_Color2magichelpergraphmodelMtgColor(ctx context.Context, sel ast.SelectionSet, v []model.MtgColor) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMTG_Color2magichelpergraphmodelMtgColor(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNMTG_CreateCardPackageInput2magichelpergraphmodelMtgCreateCardPackageInput(ctx context.Context, v any) (model.MtgCreateCardPackageInput, error) {
	res, err := ec.unmarshalInputMTG_CreateCardPackageInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNMTG_CreateDeckInput2magichelpergraphmodelMtgCreateDeckInput(ctx context.Context, v any) (model.MtgCreateDeckInput, error) {
	res, err := ec.unmarshalInputMTG_CreateDeckInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNMTG_Deck2magichelpergraphmodelMtgDeck(ctx context.Context, sel ast.SelectionSet, v model.MtgDeck) graphql.Marshaler {
	return ec._MTG_Deck(ctx, sel, &v)
}

func (ec *executionContext) marshalNMTG_Deck2magichelpergraphmodelMtgDeck(ctx context.Context, sel ast.SelectionSet, v *model.MtgDeck) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._MTG_Deck(ctx, sel, v)
}

func (ec *executionContext) marshalNMTG_DeckCard2magichelpergraphmodelMtgDeckCard(ctx context.Context, sel ast.SelectionSet, v []*model.MtgDeckCard) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMTG_DeckCard2magichelpergraphmodelMtgDeckCard(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNMTG_DeckCard2magichelpergraphmodelMtgDeckCard(ctx context.Context, sel ast.SelectionSet, v *model.MtgDeckCard) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._MTG_DeckCard(ctx, sel, v)
}

func (ec *executionContext) unmarshalNMTG_DeckCardInput2magichelpergraphmodelMtgDeckCardInput(ctx context.Context, v any) ([]*model.MtgDeckCardInput, error) {
	var vSlice []any
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.MtgDeckCardInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNMTG_DeckCardInput2magichelpergraphmodelMtgDeckCardInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNMTG_DeckCardInput2magichelpergraphmodelMtgDeckCardInput(ctx context.Context, v any) (*model.MtgDeckCardInput, error) {
	res, err := ec.unmarshalInputMTG_DeckCardInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNMTG_DeckCardType2magichelpergraphmodelMtgDeckCardType(ctx context.Context, v any) (model.MtgDeckCardType, error) {
	var res model.MtgDeckCardType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNMTG_DeckCardType2magichelpergraphmodelMtgDeckCardType(ctx context.Context, sel ast.SelectionSet, v model.MtgDeckCardType) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNMTG_DeckCard_Dashboard2magichelpergraphmodelMtgDeckCardDashboard(ctx context.Context, sel ast.SelectionSet, v []*model.MtgDeckCardDashboard) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMTG_DeckCard_Dashboard2magichelpergraphmodelMtgDeckCardDashboard(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNMTG_DeckCard_Dashboard2magichelpergraphmodelMtgDeckCardDashboard(ctx context.Context, sel ast.SelectionSet, v *model.MtgDeckCardDashboard) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._MTG_DeckCard_Dashboard(ctx, sel, v)
}

func (ec *executionContext) marshalNMTG_DeckDashboard2magichelpergraphmodelMtgDeckDashboard(ctx context.Context, sel ast.SelectionSet, v []*model.MtgDeckDashboard) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMTG_DeckDashboard2magichelpergraphmodelMtgDeckDashboard(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNMTG_DeckDashboard2magichelpergraphmodelMtgDeckDashboard(ctx context.Context, sel ast.SelectionSet, v *model.MtgDeckDashboard) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._MTG_DeckDashboard(ctx, sel, v)
}

func (ec *executionContext) unmarshalNMTG_DeleteCardPackageInput2magichelpergraphmodelMtgDeleteCardPackageInput(ctx context.Context, v any) (model.MtgDeleteCardPackageInput, error) {
	res, err := ec.unmarshalInputMTG_DeleteCardPackageInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNMTG_DeleteDeckInput2magichelpergraphmodelMtgDeleteDeckInput(ctx context.Context, v any) (model.MtgDeleteDeckInput, error) {
	res, err := ec.unmarshalInputMTG_DeleteDeckInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNMTG_Filter_CardTypeInput2magichelpergraphmodelMtgFilterCardTypeInput(ctx context.Context, v any) ([]*model.MtgFilterCardTypeInput, error) {
	var vSlice []any
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.MtgFilterCardTypeInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNMTG_Filter_CardTypeInput2magichelpergraphmodelMtgFilterCardTypeInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNMTG_Filter_CardTypeInput2magichelpergraphmodelMtgFilterCardTypeInput(ctx context.Context, v any) (*model.MtgFilterCardTypeInput, error) {
	res, err := ec.unmarshalInputMTG_Filter_CardTypeInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNMTG_Filter_CardTypes2magichelpergraphmodelMtgFilterCardTypes(ctx context.Context, sel ast.SelectionSet, v []*model.MtgFilterCardTypes) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMTG_Filter_CardTypes2magichelpergraphmodelMtgFilterCardTypes(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNMTG_Filter_CardTypes2magichelpergraphmodelMtgFilterCardTypes(ctx context.Context, sel ast.SelectionSet, v *model.MtgFilterCardTypes) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._MTG_Filter_CardTypes(ctx, sel, v)
}

func (ec *executionContext) unmarshalNMTG_Filter_ColorInput2magichelpergraphmodelMtgFilterColorInput(ctx context.Context, v any) ([]*model.MtgFilterColorInput, error) {
	var vSlice []any
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.MtgFilterColorInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNMTG_Filter_ColorInput2magichelpergraphmodelMtgFilterColorInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNMTG_Filter_ColorInput2magichelpergraphmodelMtgFilterColorInput(ctx context.Context, v any) (*model.MtgFilterColorInput, error) {
	res, err := ec.unmarshalInputMTG_Filter_ColorInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNMTG_Filter_Entries2magichelpergraphmodelMtgFilterEntries(ctx context.Context, sel ast.SelectionSet, v model.MtgFilterEntries) graphql.Marshaler {
	return ec._MTG_Filter_Entries(ctx, sel, &v)
}

func (ec *executionContext) marshalNMTG_Filter_Entries2magichelpergraphmodelMtgFilterEntries(ctx context.Context, sel ast.SelectionSet, v *model.MtgFilterEntries) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._MTG_Filter_Entries(ctx, sel, v)
}

func (ec *executionContext) marshalNMTG_Filter_Expansion2magichelpergraphmodelMtgFilterExpansion(ctx context.Context, sel ast.SelectionSet, v []*model.MtgFilterExpansion) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMTG_Filter_Expansion2magichelpergraphmodelMtgFilterExpansion(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNMTG_Filter_Expansion2magichelpergraphmodelMtgFilterExpansion(ctx context.Context, sel ast.SelectionSet, v *model.MtgFilterExpansion) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._MTG_Filter_Expansion(ctx, sel, v)
}

func (ec *executionContext) unmarshalNMTG_Filter_GameInput2magichelpergraphmodelMtgFilterGameInput(ctx context.Context, v any) ([]*model.MtgFilterGameInput, error) {
	var vSlice []any
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.MtgFilterGameInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNMTG_Filter_GameInput2magichelpergraphmodelMtgFilterGameInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNMTG_Filter_GameInput2magichelpergraphmodelMtgFilterGameInput(ctx context.Context, v any) (*model.MtgFilterGameInput, error) {
	res, err := ec.unmarshalInputMTG_Filter_GameInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNMTG_Filter_LayoutInput2magichelpergraphmodelMtgFilterLayoutInput(ctx context.Context, v any) ([]*model.MtgFilterLayoutInput, error) {
	var vSlice []any
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.MtgFilterLayoutInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNMTG_Filter_LayoutInput2magichelpergraphmodelMtgFilterLayoutInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNMTG_Filter_LayoutInput2magichelpergraphmodelMtgFilterLayoutInput(ctx context.Context, v any) (*model.MtgFilterLayoutInput, error) {
	res, err := ec.unmarshalInputMTG_Filter_LayoutInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNMTG_Filter_Legality2magichelpergraphmodelMtgFilterLegality(ctx context.Context, sel ast.SelectionSet, v *model.MtgFilterLegality) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._MTG_Filter_Legality(ctx, sel, v)
}

func (ec *executionContext) unmarshalNMTG_Filter_LegalityEntryInput2magichelpergraphmodelMtgFilterLegalityEntryInput(ctx context.Context, v any) ([]*model.MtgFilterLegalityEntryInput, error) {
	var vSlice []any
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.MtgFilterLegalityEntryInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNMTG_Filter_LegalityEntryInput2magichelpergraphmodelMtgFilterLegalityEntryInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNMTG_Filter_LegalityEntryInput2magichelpergraphmodelMtgFilterLegalityEntryInput(ctx context.Context, v any) (*model.MtgFilterLegalityEntryInput, error) {
	res, err := ec.unmarshalInputMTG_Filter_LegalityEntryInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNMTG_Filter_LegalityInput2magichelpergraphmodelMtgFilterLegalityInput(ctx context.Context, v any) ([]*model.MtgFilterLegalityInput, error) {
	var vSlice []any
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.MtgFilterLegalityInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNMTG_Filter_LegalityInput2magichelpergraphmodelMtgFilterLegalityInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNMTG_Filter_LegalityInput2magichelpergraphmodelMtgFilterLegalityInput(ctx context.Context, v any) (*model.MtgFilterLegalityInput, error) {
	res, err := ec.unmarshalInputMTG_Filter_LegalityInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNMTG_Filter_ManaCostInput2magichelpergraphmodelMtgFilterManaCostInput(ctx context.Context, v any) ([]*model.MtgFilterManaCostInput, error) {
	var vSlice []any
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.MtgFilterManaCostInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNMTG_Filter_ManaCostInput2magichelpergraphmodelMtgFilterManaCostInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNMTG_Filter_ManaCostInput2magichelpergraphmodelMtgFilterManaCostInput(ctx context.Context, v any) (*model.MtgFilterManaCostInput, error) {
	res, err := ec.unmarshalInputMTG_Filter_ManaCostInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNMTG_Filter_PaginationInput2magichelpergraphmodelMtgFilterPaginationInput(ctx context.Context, v any) (model.MtgFilterPaginationInput, error) {
	res, err := ec.unmarshalInputMTG_Filter_PaginationInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNMTG_Filter_RarityInput2magichelpergraphmodelMtgFilterRarityInput(ctx context.Context, v any) ([]*model.MtgFilterRarityInput, error) {
	var vSlice []any
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.MtgFilterRarityInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNMTG_Filter_RarityInput2magichelpergraphmodelMtgFilterRarityInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNMTG_Filter_RarityInput2magichelpergraphmodelMtgFilterRarityInput(ctx context.Context, v any) (*model.MtgFilterRarityInput, error) {
	res, err := ec.unmarshalInputMTG_Filter_RarityInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNMTG_Filter_RatingInput2magichelpergraphmodelMtgFilterRatingInput(ctx context.Context, v any) (*model.MtgFilterRatingInput, error) {
	res, err := ec.unmarshalInputMTG_Filter_RatingInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNMTG_Filter_Search2magichelpergraphmodelMtgFilterSearch(ctx context.Context, sel ast.SelectionSet, v model.MtgFilterSearch) graphql.Marshaler {
	return ec._MTG_Filter_Search(ctx, sel, &v)
}

func (ec *executionContext) marshalNMTG_Filter_Search2magichelpergraphmodelMtgFilterSearch(ctx context.Context, sel ast.SelectionSet, v *model.MtgFilterSearch) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._MTG_Filter_Search(ctx, sel, v)
}

func (ec *executionContext) unmarshalNMTG_Filter_SearchInput2magichelpergraphmodelMtgFilterSearchInput(ctx context.Context, v any) (model.MtgFilterSearchInput, error) {
	res, err := ec.unmarshalInputMTG_Filter_SearchInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNMTG_Filter_SetInput2magichelpergraphmodelMtgFilterSetInput(ctx context.Context, v any) ([]*model.MtgFilterSetInput, error) {
	var vSlice []any
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.MtgFilterSetInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNMTG_Filter_SetInput2magichelpergraphmodelMtgFilterSetInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNMTG_Filter_SetInput2magichelpergraphmodelMtgFilterSetInput(ctx context.Context, v any) (*model.MtgFilterSetInput, error) {
	res, err := ec.unmarshalInputMTG_Filter_SetInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNMTG_Filter_SortBy2magichelpergraphmodelMtgFilterSortBy(ctx context.Context, v any) (model.MtgFilterSortBy, error) {
	var res model.MtgFilterSortBy
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNMTG_Filter_SortBy2magichelpergraphmodelMtgFilterSortBy(ctx context.Context, sel ast.SelectionSet, v model.MtgFilterSortBy) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNMTG_Filter_SortDirection2magichelpergraphmodelMtgFilterSortDirection(ctx context.Context, v any) (model.MtgFilterSortDirection, error) {
	var res model.MtgFilterSortDirection
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNMTG_Filter_SortDirection2magichelpergraphmodelMtgFilterSortDirection(ctx context.Context, sel ast.SelectionSet, v model.MtgFilterSortDirection) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNMTG_Filter_SortInput2magichelpergraphmodelMtgFilterSortInput(ctx context.Context, v any) ([]*model.MtgFilterSortInput, error) {
	var vSlice []any
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.MtgFilterSortInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNMTG_Filter_SortInput2magichelpergraphmodelMtgFilterSortInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNMTG_Filter_SortInput2magichelpergraphmodelMtgFilterSortInput(ctx context.Context, v any) (*model.MtgFilterSortInput, error) {
	res, err := ec.unmarshalInputMTG_Filter_SortInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNMTG_Filter_SubtypeInput2magichelpergraphmodelMtgFilterSubtypeInput(ctx context.Context, v any) ([]*model.MtgFilterSubtypeInput, error) {
	var vSlice []any
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.MtgFilterSubtypeInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNMTG_Filter_SubtypeInput2magichelpergraphmodelMtgFilterSubtypeInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNMTG_Filter_SubtypeInput2magichelpergraphmodelMtgFilterSubtypeInput(ctx context.Context, v any) (*model.MtgFilterSubtypeInput, error) {
	res, err := ec.unmarshalInputMTG_Filter_SubtypeInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNMTG_Filter_TagInput2magichelpergraphmodelMtgFilterTagInput(ctx context.Context, v any) ([]*model.MtgFilterTagInput, error) {
	var vSlice []any
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.MtgFilterTagInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNMTG_Filter_TagInput2magichelpergraphmodelMtgFilterTagInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNMTG_Filter_TagInput2magichelpergraphmodelMtgFilterTagInput(ctx context.Context, v any) (*model.MtgFilterTagInput, error) {
	res, err := ec.unmarshalInputMTG_Filter_TagInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNMTG_Game2magichelpergraphmodelMtgGame(ctx context.Context, v any) (model.MtgGame, error) {
	var res model.MtgGame
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNMTG_Game2magichelpergraphmodelMtgGame(ctx context.Context, sel ast.SelectionSet, v model.MtgGame) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNMTG_Game2magichelpergraphmodelMtgGame(ctx context.Context, v any) ([]model.MtgGame, error) {
	var vSlice []any
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]model.MtgGame, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNMTG_Game2magichelpergraphmodelMtgGame(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNMTG_Game2magichelpergraphmodelMtgGame(ctx context.Context, sel ast.SelectionSet, v []model.MtgGame) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMTG_Game2magichelpergraphmodelMtgGame(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNMTG_Layout2magichelpergraphmodelMtgLayout(ctx context.Context, v any) (model.MtgLayout, error) {
	var res model.MtgLayout
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNMTG_Layout2magichelpergraphmodelMtgLayout(ctx context.Context, sel ast.SelectionSet, v model.MtgLayout) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNMTG_Layout2magichelpergraphmodelMtgLayout(ctx context.Context, v any) ([]model.MtgLayout, error) {
	var vSlice []any
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]model.MtgLayout, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNMTG_Layout2magichelpergraphmodelMtgLayout(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNMTG_Layout2magichelpergraphmodelMtgLayout(ctx context.Context, sel ast.SelectionSet, v []model.MtgLayout) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMTG_Layout2magichelpergraphmodelMtgLayout(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNMTG_Rarity2magichelpergraphmodelMtgRarity(ctx context.Context, v any) (model.MtgRarity, error) {
	var res model.MtgRarity
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNMTG_Rarity2magichelpergraphmodelMtgRarity(ctx context.Context, sel ast.SelectionSet, v model.MtgRarity) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNMTG_RemoveCardFromCardPackageInput2magichelpergraphmodelMtgRemoveCardFromCardPackageInput(ctx context.Context, v any) (model.MtgRemoveCardFromCardPackageInput, error) {
	res, err := ec.unmarshalInputMTG_RemoveCardFromCardPackageInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNMTG_UpdateDeckInput2magichelpergraphmodelMtgUpdateDeckInput(ctx context.Context, v any) (model.MtgUpdateDeckInput, error) {
	res, err := ec.unmarshalInputMTG_UpdateDeckInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNMainOrSide2magichelpergraphmodelMainOrSide(ctx context.Context, v any) (model.MainOrSide, error) {
	var res model.MainOrSide
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNMainOrSide2magichelpergraphmodelMainOrSide(ctx context.Context, sel ast.SelectionSet, v model.MainOrSide) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNMap2map(ctx context.Context, v any) (map[string]any, error) {
	res, err := graphql.UnmarshalMap(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNMap2map(ctx context.Context, sel ast.SelectionSet, v map[string]any) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	res := graphql.MarshalMap(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNPhantom2magichelpergraphmodelPhantom(ctx context.Context, sel ast.SelectionSet, v []*model.Phantom) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPhantom2magichelpergraphmodelPhantom(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNPhantom2magichelpergraphmodelPhantom(ctx context.Context, sel ast.SelectionSet, v *model.Phantom) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Phantom(ctx, sel, v)
}

func (ec *executionContext) unmarshalNPhantomInput2magichelpergraphmodelPhantomInput(ctx context.Context, v any) ([]*model.PhantomInput, error) {
	var vSlice []any
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.PhantomInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNPhantomInput2magichelpergraphmodelPhantomInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNPhantomInput2magichelpergraphmodelPhantomInput(ctx context.Context, v any) (*model.PhantomInput, error) {
	res, err := ec.unmarshalInputPhantomInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNPosition2magichelpergraphmodelPosition(ctx context.Context, sel ast.SelectionSet, v *model.Position) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Position(ctx, sel, v)
}

func (ec *executionContext) unmarshalNPositionInput2magichelpergraphmodelPositionInput(ctx context.Context, v any) (*model.PositionInput, error) {
	res, err := ec.unmarshalInputPositionInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNRatableEntityType2magichelpergraphmodelRatableEntityType(ctx context.Context, v any) (model.RatableEntityType, error) {
	var res model.RatableEntityType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNRatableEntityType2magichelpergraphmodelRatableEntityType(ctx context.Context, sel ast.SelectionSet, v model.RatableEntityType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNRateInput2magichelpergraphmodelRateInput(ctx context.Context, v any) (model.RateInput, error) {
	res, err := ec.unmarshalInputRateInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNRemoveIgnoredCardInput2magichelpergraphmodelRemoveIgnoredCardInput(ctx context.Context, v any) (model.RemoveIgnoredCardInput, error) {
	res, err := ec.unmarshalInputRemoveIgnoredCardInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNResponse2magichelpergraphmodelResponse(ctx context.Context, sel ast.SelectionSet, v model.Response) graphql.Marshaler {
	return ec._Response(ctx, sel, &v)
}

func (ec *executionContext) marshalNResponse2magichelpergraphmodelResponse(ctx context.Context, sel ast.SelectionSet, v *model.Response) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Response(ctx, sel, v)
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v any) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v any) ([]string, error) {
	var vSlice []any
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNTag2magichelpergraphmodelTag(ctx context.Context, sel ast.SelectionSet, v model.Tag) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Tag(ctx, sel, v)
}

func (ec *executionContext) marshalNTag2magichelpergraphmodelTag(ctx context.Context, sel ast.SelectionSet, v []model.Tag) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTag2magichelpergraphmodelTag(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNTagType2magichelpergraphmodelTagType(ctx context.Context, v any) (model.TagType, error) {
	var res model.TagType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTagType2magichelpergraphmodelTagType(ctx context.Context, sel ast.SelectionSet, v model.TagType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNTernaryBoolean2magichelpergraphmodelTernaryBoolean(ctx context.Context, v any) (model.TernaryBoolean, error) {
	var res model.TernaryBoolean
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTernaryBoolean2magichelpergraphmodelTernaryBoolean(ctx context.Context, sel ast.SelectionSet, v model.TernaryBoolean) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNUnassignTagInput2magichelpergraphmodelUnassignTagInput(ctx context.Context, v any) (model.UnassignTagInput, error) {
	res, err := ec.unmarshalInputUnassignTagInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateTagInput2magichelpergraphmodelUpdateTagInput(ctx context.Context, v any) (model.UpdateTagInput, error) {
	res, err := ec.unmarshalInputUpdateTagInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUser2magichelpergraphmodelUser(ctx context.Context, sel ast.SelectionSet, v *model.User) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._User(ctx, sel, v)
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v any) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v any) ([]string, error) {
	var vSlice []any
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v any) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v any) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	return res
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v any) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalBoolean(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalBoolean(*v)
	return res
}

func (ec *executionContext) unmarshalOFloat2float64(ctx context.Context, v any) (*float64, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalFloatContext(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOFloat2float64(ctx context.Context, sel ast.SelectionSet, v *float64) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalFloatContext(*v)
	return graphql.WrapContextMarshaler(ctx, res)
}

func (ec *executionContext) unmarshalOID2string(ctx context.Context, v any) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalID(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOID2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalID(*v)
	return res
}

func (ec *executionContext) unmarshalOInt2int(ctx context.Context, v any) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalInt(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2int(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalInt(*v)
	return res
}

func (ec *executionContext) marshalOMTG_CardFace2magichelpergraphmodelMtgCardFace(ctx context.Context, sel ast.SelectionSet, v []*model.MtgCardFace) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMTG_CardFace2magichelpergraphmodelMtgCardFace(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOMTG_Color2magichelpergraphmodelMtgColor(ctx context.Context, v any) ([]model.MtgColor, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]model.MtgColor, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNMTG_Color2magichelpergraphmodelMtgColor(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOMTG_Color2magichelpergraphmodelMtgColor(ctx context.Context, sel ast.SelectionSet, v []model.MtgColor) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMTG_Color2magichelpergraphmodelMtgColor(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOMTG_DeckCardFrontImageInput2magichelpergraphmodelMtgDeckCardFrontImageInput(ctx context.Context, v any) (*model.MtgDeckCardFrontImageInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputMTG_DeckCardFrontImageInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOMTG_Deck_CardFrontImage2magichelpergraphmodelMtgDeckCardFrontImage(ctx context.Context, sel ast.SelectionSet, v *model.MtgDeckCardFrontImage) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._MTG_Deck_CardFrontImage(ctx, sel, v)
}

func (ec *executionContext) marshalOMTG_Image2magichelpergraphmodelMtgImage(ctx context.Context, sel ast.SelectionSet, v *model.MtgImage) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._MTG_Image(ctx, sel, v)
}

func (ec *executionContext) unmarshalOMTG_Layout2magichelpergraphmodelMtgLayout(ctx context.Context, v any) (*model.MtgLayout, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.MtgLayout)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOMTG_Layout2magichelpergraphmodelMtgLayout(ctx context.Context, sel ast.SelectionSet, v *model.MtgLayout) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v any) ([]string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v any) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalString(*v)
	return res
}

func (ec *executionContext) marshalOTag2magichelpergraphmodelTag(ctx context.Context, sel ast.SelectionSet, v model.Tag) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Tag(ctx, sel, v)
}

func (ec *executionContext) marshalOUserRating2magichelpergraphmodelUserRating(ctx context.Context, sel ast.SelectionSet, v *model.UserRating) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._UserRating(ctx, sel, v)
}

func (ec *executionContext) marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************
